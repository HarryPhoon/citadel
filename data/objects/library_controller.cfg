{
	id: "library_controller",
	prototype: ["citadel_controller_base"],
	is_human: true,
	is_strict: true,
	always_active: true,
	hidden_in_game: false,

	types: {
		CardEntry: "{
			name: string,
			card: class card,
			num_copies: int,
			obj: null|obj card
		}",
		CardGroup: "{
			entries: [CardEntry],
			name: string,
		}",
	},

	properties: {
		font: "lib.font.regular_font",

		//the dimensions we use for our display. Don't use the bottom
		//80 pixels of the screen.
		level_width: "int :: level.dimensions[2] - level.dimensions[0]",
		level_height: "int :: level.dimensions[3] - level.dimensions[1]",

		//the left/right side of the 'usable' area -- i.e. cutting off edges
		//to make for a 4:3 display.
		gui_left_edge: "int :: (level_width - (level_height*4)/3)/2",
		gui_right_edge: "int :: level_width - gui_left_edge",

		px: "def(int pixels) ->int lib.citadel.px(pixels)",
		py: "def(int pixels) ->int lib.citadel.py(pixels)",

		deck_rules: { type: "class deck_rules" },

		specified_deck: { type: "null|[string]" },
		specified_collection: { type: "null|[string]" },

		get_collection: "def() -> [string]
		if(specified_collection != null,
		   specified_collection,
		   map(filter(_mm_client_state.account_info.collection, value.name in cards_in_sets), value.name)
		   where cards_in_sets = lib.citadel.get_cards_in_set('core')
		  )",

		_max_decks: "int :: 9",

		_decks: {
			variable: false,
			type: "DeckMap",
			get: "DeckMap :: _mm_client_state.account_info.decks",
			set: "[
				set(_mm_client_state.account_info.decks, value),
				tbs_send(object<- mm_client, { type: 'set_decks', decks: value, user: _mm_client_state.username }),
			]",
		},

		editing_deck: { default: false },
		_deck_summary: { type: "null|obj library_deck_summary" },
		_done_editing_button: { type: "null|obj button_controller" },

		_deck_summaries: { type: "[obj library_deck_summary]", default: []},

		_title_deck_summary_ypos: "int :: 0",

		_deck_summary_ypos: "def(int n) ->int
			lib.citadel.py(82) + lib.citadel.py(82)*n
		",

		_spawn_deck_summaries: "def() ->commands
		[
			map(_deck_summaries, remove_object(value)),
			set(_deck_summaries, []),

			map(sort(values(_decks)[:_max_decks], [a.creation_time,lower(a.name)] < [b.creation_time,lower(b.name)]),
			schedule(2 + index*3,
				bind_command(def() ->commands
				spawn('library_deck_summary', 0, 0, {
					selected: false,
					deck_name: value.name,
					_controller: me,
					_mm: me,
					x2: gui_right_edge - lib.citadel.py(24),
					y: _deck_summary_ypos(index),
					alpha: 0,
				}, [
					add(_deck_summaries, [child]),
					animate(child, {
						alpha: 255,
					}, {
						duration: 20,
					})
				]))
			)
			);

			_spawn_create_deck()
		]
		",

		_create_deck: { type: "null|obj library_new_deck" },
		_spawn_create_deck: "def() ->commands
		if(specified_deck = null,
		[
		if(size(_decks) >= _max_decks, [
			remove_object(_create_deck),
			set(_create_deck, null),
		],

		if(_create_deck = null,
			spawn('library_new_deck', 0, 0, {
				x2: xpos,
				y: ypos,
				_controller: me,
			}, [
				set(me._create_deck, child),
			]),
			animate(_create_deck, {
				x2: xpos,
				y: ypos,
			}, {
				duration: 10,
				name: 'move_about',
				replace_existing: true,
			})
		)
			where xpos = gui_right_edge - lib.citadel.py(24)
			where ypos = _deck_summary_ypos(size(_decks))
		)
		]
		)
		",

		_view: { type: "obj library_view_controller", dynamic_initialization: true },
		view: "obj library_view_controller<- _view",

		_all_cards: { type: "[CardEntry]", default: [] },
		_visible_cards: { type: "[CardGroup]", default: [] },

		_default_sort: "def([CardEntry] entries) ->[CardEntry]
			sort(entries, [a.card.cost + a.card.loyalty_cost, a.card.cost, a.card.type, a.card.name] < [b.card.cost + b.card.loyalty_cost, b.card.cost, b.card.type, b.card.name])
		",

		_mouse_x: "int <- head_or_die(level.player.ctrl_mice)[0]",
		_mouse_y: "int <- head_or_die(level.player.ctrl_mice)[1]",

		_delete_item_button: { type: "obj svg_button|null" },

		cards_widget: { type: "obj scrollable_pane|null" },

		deck: "[obj library_deck_entry] <- if(cards_widget = null, [], map(cards_widget.elements, value.obj))",

		exit_to_titlescreen: "def() ->commands [
			if(editing_deck, done_editing_deck()),
			teleport('lobby.cfg', '', 'fade', playable)
			  where playable = object_playable('title_controller', 0, 0, 0, {
					 _mm_client_state: _mm_client_state,
				})
		]",

		_play_card_add_sound: "def() ->commands
			sound(fname, lib.citadel.sound_volume(fname)) where fname = 'interface/card-add${1d4}.wav',
		",

		_focus_card: { type: "null|obj card" },
		_focus_card_restore: { type: "null|map" },

		card_right_clicked: "def(obj card card) ->commands
		if(card = _focus_card,
		[
			card.clear_card_tips(),
			remove_object(find(level.chars, value is obj blur_controller)),
			set(_focus_card, null),
			animate(card, map<- _focus_card_restore, {
				duration: 20,
				name: 'focus',
				on_complete: add(card.zorder, -10000),
			}),

			[set(c.paused, false) | c <- level.chars],
		],

		(not card.animated_movements) and card in (list<- _card_cache.enumerate),
		[
			
			set(_focus_card, card),
			[set(c.paused, true) | c <- level.chars, c not in [card,me]],
			spawn('blur_controller', 0, 0, {
				begin_zorder: -10000,
				end_zorder: 1000,
				blur_darken: 0.4,
			}, [
			]),

			add(card.zorder, 10000),
			set(_focus_card_restore, { mid_x: card.mid_x, mid_y: card.mid_y, card_size: card.card_size }),
			animate(card, {
				mid_x: level_width/2,
				mid_y: level_height/2,
				card_size: 3.0,
			}, {
				duration: 20,
				name: 'focus',
				on_complete: bind_command(card.show_card_tips),
			})
		])",

		card_clicked: "def(obj card card) ->commands
		if(card = _focus_card or not editing_deck, card_right_clicked(card),
		editing_deck,
		[
			add_deck_item(card.card_type)
		]
		)",

		remove_deck: "def(obj library_deck_summary summary) ->commands
		[
			if(_delete_item_button, [
				remove_object(_delete_item_button),
				set(_delete_item_button, null),
			]),

			(set(_deck_summaries, new_deck_summaries); _spawn_create_deck()),

			remove_object(summary),

			map(new_deck_summaries,
				animate(value, {
					y: _deck_summary_ypos(index),
				}, {
					name: 'animate_removal',
					replace_existing: false,
					duration: 20,
				})
			),


			set(_decks, remove_from_map(_decks, summary.deck_name)),
		]
		where new_deck_summaries = filter(_deck_summaries, value != summary)
		",

		enter_deck_summary: "def(obj library_deck_summary summary) ->commands
		[
			if(_delete_item_button, remove_object(_delete_item_button)),
			spawn('svg_button', 0, 0, {
				icon: 'cancel.svg',
				zorder: 1000,
				mid_x: summary.x2 - px(12),
				mid_y: summary.y + px(12),
				mouseover_color: [255, 0, 0],
				mouseoff_color: [196, 0, 0],
				size: px(24),
				click_handler: (def()->commands remove_deck(summary)),
				user_info: summary,
				clip_area: summary.clip_area,
				use_absolute_screen_coordinates: true,
			}, [
				set(_delete_item_button, child),
			]),
		]",

		leave_deck_summary: "def(obj library_deck_summary summary) ->commands
		[
			if(_delete_item_button != null and _delete_item_button.user_info = summary, [
				remove_object(_delete_item_button),
				set(_delete_item_button, null)
			])
		]",

		create_new_deck: "def() ->commands execute(me, [
			spawn('library_deck_summary', 0, 0, {
				selected: false,
				deck_name: deck_name,
				_controller: me,
				_mm: me,
				x2: gui_right_edge - lib.citadel.py(24),
				y: _deck_summary_ypos(count(level.chars, value is obj library_deck_summary)),
			}, [
				add(_deck_summaries, [child]);
				deck_summary_clicked(child)
			])
		]
		where deck_name = find_or_die(map(range(100), 'New Deck ' + str(value+1)), _decks[value] = null))",

		deck_summary_clicked: "def(obj library_deck_summary summary) ->commands
		execute(me,
		if(editing_deck = false,
		execute(me, [
			leave_deck_summary(summary),
			set(summary.highlighted, false),
			set(editing_deck, true),
			map(_deck_summaries, if(value != summary, remove_object(value))),
			set(_deck_summary, summary),

			animate(summary, {
				y: _title_deck_summary_ypos,
			}, {
				duration: 20,
			}),

			spawn('button_controller', 0, 0, {
				mid_x: gui_right_edge - lib.citadel.py(60),
				mid_y: lib.citadel.py(800),
				text: 'Done',
				on_click: me.done_editing_deck,
			}, [
				set(me._done_editing_button, child),
			]),

			remove_object(_create_deck),
			set(_create_deck, null),

			_create_deck_widget(map(unique_cards, {card_name: value, count: count(deck.cards, value = context.value)} ))
			  where unique_cards = unique(sort(deck.cards))
			  where deck = Deck<- (account_info.decks[summary.deck_name] or {cards: [], name: summary.deck_name, schools: [] }),
		])
		)
		)",
		
		done_editing_deck: "def() ->commands execute(me, [
			remove_object(cards_widget),
			set(cards_widget, null),

			if(not deck, [
				remove_object(_deck_summary),
				set(_deck_summaries, filter(_deck_summaries, value != _deck_summary)),
			]),

			set(editing_deck, false),
			set(_deck_summary, null),

			remove_object(_done_editing_button),
			set(_done_editing_button, null),

			map(_deck_summaries, [
				if(value not in level.chars, add_object(value)),
				animate(value, {
					y: _deck_summary_ypos(index)
				}, {
					duration: 20,
				})
			]),

			set(_decks, if(new_deck.cards, old_decks + {(new_deck.name): new_deck}, remove_from_map(old_decks, new_deck.name)))
			  where new_deck = {
					name: summary.deck_name,
					schools: [],
					cards: fold(map(deck, [value.card.name]*value.count), a+b) or [],
					creation_time: if(existing_deck, existing_deck.creation_time, time().unix),
					mod_time: time().unix,
				}
			  where existing_deck = account_info.decks[summary.deck_name]
		  where old_decks = remove_from_map(account_info.decks, summary.original_deck_name or summary.deck_name)

		]; _spawn_create_deck()) where summary = find_or_die(level.chars, value is obj library_deck_summary)
		",

		_spawn_specified_deck: "def([string] specified_deck) ->commands
		[
		set(editing_deck, true),
		_create_deck_widget(entries)
		]
		where entries = map(unique(sort(specified_deck)), {card_name: value, count: count(specified_deck, value = context.value)})
		",

		_create_deck_widget: "def([{card_name: string, count: int}] cards) ->commands [
			remove_object(cards_widget),

			spawn('scrollable_pane', 0, 0, {
				x: gui_right_edge - lib.citadel.py(290),
				y: lib.citadel.py(78),
				area_width: lib.citadel.py(290),
				area_height: lib.citadel.py(680),
				left_align: false,
				step_size: lib.citadel.py(36),

				elements: map(ordered_cards, {
					ypos: lib.citadel.py(36)*index,
					obj: object('library_deck_entry', 0, 0, {
						card: class card<- card_map[value.card_name],
						count: value.count,
						controller: me,
						_delay_drawing_frames: level.cycle + index + 1,
					})
				}),
			}, [
				set(me.cards_widget, child)
			]);

			map(filter(level.chars, value is obj library_deck_entry), [
				set(value.alpha, 0),
				animate(value, {
					alpha: 0,
				}, {
					duration: index,
					name: 'fade_in',
					replace_existing: false,
				}),
				animate(value, {
					alpha: 196,
				}, {
					duration: 20,
					name: 'fade_in',
					replace_existing: false,
				}),
			]),
		]
		where ordered_cards = sort(cards, [card_a.cost, card_a.name] < [card_b.cost, card_b.name] where card_a = class card<- card_map[a.card_name] where card_b = class card<- card_map[b.card_name])
		where card_map = fold(map(cards, {(value.card_name): lib.citadel.create_card(value.card_name)}), a+b, {})",

		add_deck_item: "def(class card_base card) -> commands
		if(entry != null and entry.count < deck_rules.max_duplicates and entry.count < count(account_info.collection, value.name = card.name),
		[
			add(entry.count, 1); entry.render_entry(),
			entry.pulse(),
		],

		if(entry = null and cards_widget != null,
		[
			let old_elements = map(cards_widget.elements, {obj: value.obj, ypos: value.ypos});
			[
			[
				add(s.ypos, (obj library_deck_entry<- s.obj).area.height)
				| s <- cards_widget.elements, s.ypos >= ypos
			],

			set(cards_widget.elements, cards_widget.elements[:insert_index] + [{ypos: ypos, obj: new_obj}] + cards_widget.elements[insert_index:]),
			];

			cards_widget.recalculate();
			cards_widget.animate_element_movement_from_previous_position(old_elements, 20);
			set(new_obj.alpha, 0);
			new_obj.pulse()
		]
		)
		where ypos = lib.citadel.py(36)*insert_index
		where insert_index = if(insert_before, index(deck, insert_before), size(deck))
		where insert_before = find(deck, [card.cost, card.name] < [value.card.cost, value.card.name])
		where new_obj = object('library_deck_entry', 0, 0, {
			card: card,
			count: 1,
			controller: me,
		})
		)
		where entry = find(deck, value.card.name = card.name)
		",

		remove_deck_item: "def(class card card) -> commands
		if(entry != null and cards_widget != null,
		execute(me,
		[
			remove_object(entry),
			
			let old_elements = map(cards_widget.elements, {obj: value.obj, ypos: value.ypos});
			[
			[
				add(s.ypos, - (obj library_deck_entry<- s.obj).area.height)
				| s <- cards_widget.elements, s.ypos > item.ypos
			],

			set(cards_widget.elements, filter(cards_widget.elements, value.obj != entry)),

			];

			cards_widget.recalculate();
			cards_widget.animate_element_movement_from_previous_position(old_elements, 20)
		]
		)
		where item = find_or_die(cards_widget.elements, value.obj = entry)
		)
		where entry = find_or_die(deck, value.card.name = card.name)
		",

		refresh_view: "def() ->commands view.set_visible_cards(_visible_cards)",

		set_card_preloads: "def([class card] cards) ->commands [
			set(_card_preloads, filter(cards, find(existing, value.card_type = context.value) = null))
		] where existing = [obj card]<- _card_cache.enumerate",

		_process_card_preloads: "def() ->commands
		if(_card_preloads, [
			if(create_card(_card_preloads[0]) != null,
			   set(_card_preloads, _card_preloads[1:])),
		])
		",

		_card_preloads: { type: "[class card]", default: [] },

		_card_cache: { type: "object", init: "create_cache()" },

		create_card: "def(class card card) ->obj card
		query_cache(_card_cache, card,
			object('card', 0, 0, {
				card_type: card,
				controller: me,
				in_hand: false,
				allow_drag: false,
				card_size: 1.5,
				show_shadow: false,
				use_absolute_screen_coordinates: true,
				search_string: _search_terms,
			})
		)
		",

		set_all_cards_visible: "def() ->commands
		set(_visible_cards, map(filter(range(1,6), school_in_filter(value)), {
			name: string<- ENGLISH_SCHOOL_NAMES[value],
			entries: _default_sort(filter(_all_cards, value.card.first_school = context.value))
		}))
		",

		_search_terms: { type: "null|[string]", set: "[set(_data, value), map(cards, set(value.search_string, context.value)) where cards = [obj card]<- _card_cache.enumerate]" },

		_school_icons: { type: "[obj game_icon]", default: [] },
		_school_filter: { type: "[int]", default: [] },

		school_in_filter: "def(int nschool) ->bool (_school_filter = []) or ((nschool-1) in _school_filter)",

		select_school_filter: "def(int num) ->commands
		(
		[
			set(_school_filter, new_filter),
			map(_school_icons, set(value.brightness, if(new_filter = [] or index in new_filter, 255, 64))),
		]
		where new_filter = [int] :: if(num in _school_filter, filter(_school_filter, num != value), _school_filter + [num])
		) ; if(_text_entry.text not in ['Search', ''], set(_text_entry.text, ''));
		    set_all_cards_visible(); refresh_view()
		",

		_text_entry: "text_editor_widget<- widgets.search_entry",

		_view_type_icons: { type: "[obj game_icon]", default: [] },
		_mouseover_view_type_icon_selected: {
			type: "null|obj game_icon",
			set: "if(value != _data, [
				if(_data != null and _data != _mouseover_view_type_icon,
					animate(_data, {
						red: 160,
						green: 160,
						blue: 196,
					}, {
						duration: 10
					})
				),
				set(_data, value),
				if(value != null,
					animate(value, {
						red: 255,
						green: 255,
						blue: 255,
					}, {
						duration: 10
					})
				),
			])",
		},
		_mouseover_view_type_icon: {
			type: "null|obj game_icon",
			set: "if(value != _data, [
				if(_data != null and _data != _mouseover_view_type_icon_selected,
					animate(_data, {
						red: 160,
						green: 160,
						blue: 196,
					}, {
						duration: 10
					})
				),
				set(_data, value),
				if(value != null,
					animate(value, {
						red: 255,
						green: 255,
						blue: 255,
					}, {
						duration: 10
					})
				),
			])"
		},

		_mouse_enter_view_type_icon: "def(obj game_icon icon) ->commands set(_mouseover_view_type_icon, icon)",
		_mouse_leave_view_type_icon: "def(obj game_icon icon) ->commands if(_mouseover_view_type_icon = icon, set(_mouseover_view_type_icon, null))",

		_reset_cached_cards: "def() ->commands
		map(cards, [
			set(value.alpha, 255),
			set(value.clip_area, null),
		])
		 where cards = [obj card]<- _card_cache.enumerate
		",

		_select_view_type: "def(obj game_icon icon) ->commands
		[
			set(_mouseover_view_type_icon_selected, icon),

			set(lib.citadel.preferences, lib.citadel.preferences + {library_view: icon.user_info}),

			_reset_cached_cards(),

			remove_object(_view),

			spawn('library_' + (string<- icon.user_info) + '_controller', 0, 0, {
				x: 0, y: 0,
				controller: me,
			}, [
				set(_view, obj library_view_controller<- child),
			]); refresh_view()
		]",

		_select_default_view: "def() ->commands
		_select_view_type(find_or_die(level.chars, value is obj game_icon and value.user_info = lib_view_type))
			where lib_view_type = lib.citadel.preferences['library_view'] or 'book_view'
		",

		_keys_pressed: "[string] ::
			if(level.player.ctrl_up, ['up'], []) +
			if(level.player.ctrl_down, ['down'], []) +
			if(level.player.ctrl_left, ['left'], []) +
			if(level.player.ctrl_right, ['right'], [])",

		_last_keys_pressed: { type: "[string]|null" },
		_key_just_pressed: "def(string key, [string] pressed) ->bool
			((key in pressed) and (key not in _last_keys_pressed)) or
			streak > 30 and streak%6 = 0
			where streak = (_key_press_streak[key] or 0)
		",

		_key_press_streak: { type: "{string -> int}", default: {} }
	},

	on_construct: "[]",

	on_create: "execute_instrumented(me, 'create', [
		set(x,0),
		set(y,0),
		set(alpha, 0),
		spawn('combo_label', 0, 0, {
			x: gui_left_edge + py(14),
			y: level_height - py(54),
			_text: 'Main Menu',
			_font_size: py(26),
			grouping: 'back',
			index: 0,
			click_handler: def(obj combo_label lb) ->commands me.exit_to_titlescreen(),
		}, [
		]),

		map(range(1,6), spawn('game_icon', gui_left_edge + lib.citadel.py(190) + lib.citadel.py(50)*index, level_height - lib.citadel.py(34), {
			icon: 'school-' + (string<- SCHOOL_NAMES[value]) + '.svg',
			size: lib.citadel.py(48),
			click_handler: def(obj game_icon icon) ->commands select_school_filter(index),
			mouse_enter_handler: def(obj game_icon icon) ->commands set(icon.brightness, 512),
			mouse_leave_handler: def(obj game_icon icon) ->commands set(icon.brightness, if(_school_filter = [] or index in _school_filter, 255, 64)),
			use_absolute_screen_coordinates: true,
		}, [
			add(_school_icons, [child])
		])),

		set(_all_cards, collection_items);
		set_all_cards_visible();

		set_widgets([
		{
			type: 'text_editor',
			id: 'search_entry',
			x: gui_left_edge + lib.citadel.py(460),
			y: level_height - lib.citadel.py(46),
			font_size: lib.citadel.py(20),
			text: 'Search',
			clear_on_focus: true,
			width: lib.citadel.py(180),
			bg_color: [0.1, 0.1, 0.1],
			no_border: true,
			on_change: q(fire_event('search_changed')),
		}]),

		set(_view_type_icons, []),

		spawn('game_icon', 0, 0, {
			mid_x: gui_left_edge + lib.citadel.py(840),
			mid_y: lib.citadel.py(870),
			icon: 'open-book.svg',
			size: lib.citadel.py(24),
			force_no_alpha: true,
			red: 160, green: 160, blue: 196,
			user_info: 'book_view',

			mouse_enter_handler: me._mouse_enter_view_type_icon,
			mouse_leave_handler: me._mouse_leave_view_type_icon,
			click_handler: me._select_view_type,
			use_absolute_screen_coordinates: true,
		}, [
			add(_view_type_icons, [child]),
		]
		),

		spawn('game_icon', 0, 0, {
			mid_x: gui_left_edge + lib.citadel.py(870),
			mid_y: lib.citadel.py(870),
			icon: 'library-grid.svg',
			size: lib.citadel.py(24),
			force_no_alpha: true,
			red: 160, green: 160, blue: 196,
			user_info: 'scroll_view',

			mouse_enter_handler: me._mouse_enter_view_type_icon,
			mouse_leave_handler: me._mouse_leave_view_type_icon,
			click_handler: me._select_view_type,
			use_absolute_screen_coordinates: true,
		}, [
			add(_view_type_icons, [child]),
		]
		); _select_default_view(),

		if(specified_deck, _spawn_specified_deck(specified_deck), _spawn_deck_summaries()),
	]) where collection_items = sort(map(unique(sort(collection)), {name: value, num_copies: count(collection, value = context.value), card: lib.citadel.create_card(value)}), a.name < b.name)
	  where collection = get_collection()",

	on_process: "[
		_process_card_preloads(),

		if(_view != null, [

			if(_key_just_pressed('up', pressed), _view.scroll_up()),
			if(_key_just_pressed('down', pressed), _view.scroll_down()),
			if(_key_just_pressed('left', pressed), _view.scroll_left()),
			if(_key_just_pressed('right', pressed), _view.scroll_right()),

			map(pressed, set(_key_press_streak[value], (_key_press_streak[value] or 0)+1));
			[set(_key_press_streak[k], 0) | k <- keys(_key_press_streak), k not in pressed],
		]),

		set(_last_keys_pressed, pressed),
	] where pressed = _keys_pressed",

	on_ctrl_up: "debug('CONTROL UP')",

	on_window_resize: "[
		set(level.dimensions, [0,0,new_width,new_height]),
		fire_event('dimensions_updated'),
	] where new_width = max(int<- arg.width,800)-1
	  where new_height = max(int<- arg.height, 600)-1",
	
	on_dimensions_updated: "[
	]",
	
	on_type_updated: "fire_event('create')",

	on_being_removed: "[
	]",

	on_search_changed: "
	if(widgets.search_entry != null,
	if(not regex_match(search_str, '^.*[a-zA-Z].*$'),
	[
		set(_search_terms, null),
		set_all_cards_visible();
		refresh_view()
	],

	[
		set(_search_terms, map(filter(map(tokens, regex_replace(value, '[^0-9a-zA-Z]', '')), value), '\\b' + value) or null);
		if(new_visible_cards != _visible_cards,
			set(_visible_cards, new_visible_cards);
			refresh_view()
		)
	]
		
	  where new_visible_cards = [{ name: 'Search Results', entries: _default_sort(filter(_all_cards, value.card.matches_search(map(tokens, '.*\\b' + value + '.*')))) }]
	  where tokens = map(filter(split(search_str, ' '), value), lower(regex_replace(value, '([^0-9a-zA-Z])', '\\$1')))
	)
	  where search_str = (text_editor_widget<- widgets.search_entry).text
	)",
}
