{
	id: "campaign_controller",
	is_human: true,
	hitpoints: 20,
	editor_info: { category: "player" },
    hidden_in_game: true,
	
	is_strict: true,

	types: {

	},

	consts: {
		FONT: "RobotoCondensed-Regular",
		FONT_COLOR: "antique_white",
	},
	
    properties: {
		//set the area we take up. Don't use the bottom 80 pixels.
		level_width: "int :: level.dimensions[2]",
		level_height: "int :: level.dimensions[3] - 80",

		_mm_client_state: { type: "class mm_client_state" },

		_progress_scenario: { default: false },

		nscenarios: "int :: min(size(_campaign.scenarios), if(s != null, s+1, 1))
		    where s = int|null <- _mm_client_state.account_info.campaign_scenario",

		victory: "def() ->commands [
			if(selected_scenario_index = nscenarios-1 and nscenarios < size(_campaign.scenarios), [
				add(_mm_client_state.account_info.campaign_scenario, 1),
				set(_progress_scenario, true),
			])
		]",

		visible_scenarios: "_campaign.scenarios[:nscenarios]",

	  	selected_scenario_index: "int :: if(_campaign_items = [], nscenarios-1, index(_campaign_items, find_or_die(_campaign_items, value.selected)))",

		_displayed_scenario_index: { type: "int|null" },

		chosen_deck: "string :: find_or_die(level.chars, value is obj library_deck_summary and value.selected).deck_name
		  asserting find(level.chars, value is obj library_deck_summary) != null",

		_decks: "DeckMap :: lib.citadel.get_decks()",

		_campaign_items: { type: "[obj campaign_item]", default: [] },

		_go_button: { type: "null|obj button_controller" },

		_internal_client: { type: "object|null" },
		_session_id: { type: "int|null" },
		_campaign: { type: "Campaign", init: "Campaign<- lib.json.get_document_map('data/campaign.cfg')" }, //'data/campaign2.cfg')" },
		
		_parent: { type: "custom_obj|null" },

		return_from_game: "
		  def(bool result) ->commands [
		  	if(result, me.victory()),
			teleport('lobby.cfg', '', 'fade', me._parent asserting me._parent != null)
		]
		",

		_handle_logout: "def(obj combo_label label) ->commands [
			write_document('citadel_cookie', null),
			teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0)),
		]",
    },

	on_process: "[
		if(_internal_client != null, tbs_process(_internal_client)),
		if(_displayed_scenario_index != selected_scenario_index, fire_event('show_objects')),

	]",


	on_message_received: "switch(message.type,
		'game_created',
		[
		set(_session_id, null),
		teleport('level1.cfg', '', 'fade', playable)
		  where playable = object_playable('citadel_controller', 336, 372, 0, {
			_mm_client_state: _mm_client_state,
			game_server_address: '',
			game_server_port: 23456,
			session_id: _session_id asserting _session_id != null,
			game_created: true,
			selected_deck: chosen_deck,
			return_callback: me.return_from_game,
			campaign_scenario: selected_scenario_index,
			victory_unlock: if(unlock not in _mm_client_state.account_info.unlocks, unlock) where unlock = _campaign.scenarios[selected_scenario_index].unlock,
		  })
		]
	) where message = map<- arg.message",

	on_play_game: "if(_session_id = null, [
		add(lib.citadel.preferences, { selected_deck: chosen_deck }),

		set(me._internal_client, cl),
		set(me._session_id, sid),
		tbs_send(cl, {
			type: 'create_game',
			game_type: 'citadel',
			starting_units: visible_scenarios[selected_scenario_index].starting_units,
			map_dimensions: visible_scenarios[selected_scenario_index].map_dimensions,
			map_lanes: visible_scenarios[selected_scenario_index].map_lanes,
			users: [{user: _mm_client_state.username, avatar: _mm_client_state.account_info.avatar, session_id: sid}, {user: bot_name, bot_type: bot_type, args: {rules: 'data/campaign/' + bot_file}, bot: true, session_id: 1d30000, avatar: visible_scenarios[selected_scenario_index].avatar}],
			tutorial: visible_scenarios[selected_scenario_index].tutorial,
		}),
	]) where cl = tbs_internal_client()
	  where sid = 1d10000
	  where bot_name = visible_scenarios[selected_scenario_index].enemy_name
	  where bot_type = visible_scenarios[selected_scenario_index].bot_type or 'evolutionary'
	  where bot_file = visible_scenarios[selected_scenario_index].bot
	",

	on_being_removed: "map(spawned_children, remove_object(value))",

	on_show_objects: "[
		set(_displayed_scenario_index, selected_scenario_index),

		map(spawned_children, remove_object(value)),

		spawn('combo_label', level_width - 52, 80, {
			_text: 'LOGOUT',
			_font_size: 14,
			_halign: 'right',
			grouping: 'logout',
			selected: false,
			index: 0,
			click_handler: me._handle_logout,
		}),


		spawn('label', 10, 10, {
			_text: [ selected_scenario.name ],
			_halign: 'left',
			_valign: 'top',
			x: 10,
			y: 10,
			zorder: 100,
			_outline_width: 0.0,
		}, [
		]),
	
		spawn('label', 10, 30, {
			_text: selected_scenario.text,
			_halign: 'left',
			_valign: 'top',
			_font_size: 16,
			x: 10,
			y: 44,
			zorder: 100,
			_outline_width: 0.0,
		}, [
		]),
		
		map(level.chars, if(value is obj campaign_avatar,
		  if(value.portrait != selected_scenario.portrait,
		  [
		    add(value.zorder, 10),
		  	animate(value, {
				alpha: 0,
			}, {
				duration: 50,
				on_complete: remove_object(value),
			}),
		  ],
		  remove_object(value))
		)),
		spawn('campaign_avatar', level_width/2, level_height*0.4, {
			portrait: selected_scenario.portrait,
			zorder: -10,
		}, [
			//see if we want to fade this in while the new avatar fades out.
			if(find(level.chars, value is obj campaign_avatar and value.portrait != visible_scenarios[selected_scenario_index].portrait) != null, [
				set(child.alpha, 0),
				animate(child, {
					alpha: 255,
				}, {
					duration: 50,
				}),
			])
		]),

		map(level.chars, if(value is obj library_deck_summary, remove_object(value))),

		map(_campaign_items, remove_object(value)),
		set(_campaign_items, []),

		map(visible_scenarios, spawn('campaign_item', 0, level_height-64, {
			selected: index = selected_scenario_index,
			show_next: index < size(visible_scenarios)-1,
			mid_x: (level_width - 196*(size(visible_scenarios)-1))/2 + 196*index,
			scenario: value,
		}, [
			add(_campaign_items, [child]),
			if(_progress_scenario and index = nscenarios-2, [
				set(child.show_next_progress, 0.0),
				animate(child, {
					show_next_progress: 1.0,
				}, {
					duration: 50,
				}),
			]),

			if(_progress_scenario and index = nscenarios-1, [
				set(child.alpha, 0),
				animate(child, {
					alpha: 0,
				}, {
					duration: 50,
					name: 'fade_in',
				}),
				animate(child, {
					alpha: 255,
				}, {
					duration: 50,
					name: 'fade_in',
				}),

				if(index = 1, [
					spawn('tip_dialog', level_width - 200, level_height/2, {
						zorder: 10000,
						_tip: {
							key: 'unlock',
							text: 'You have unlocked a new scenario, click on it to play it.',
							max_shows: 3,
							targets: [child],
						},

						_width: 260,
						_height: 200,
					})
				])
			]),
		])),

		schedule(50, set(me._progress_scenario, false)),

		map(_decks, spawn('library_deck_summary', 0, 0, {selected: index = if(selected_index >= 0, selected_index, 0), zorder: 500, deck_name: key, x2: level_width + if('LIBRARY' in _mm_client_state.account_info.unlocks, 0, 500), y: 28 + 72 + 72*index}))
		  where selected_index = index(keys(_decks), find(keys(_decks), value = lib.citadel.preferences.selected_deck) or _decks[0]),

		if(_go_button, [remove_object(_go_button), set(_go_button, null)]),

		spawn('button_controller', level_width - 220, level_height - 50, {
			text: 'Play',
			on_click: (def() -> commands fire_event(me, 'play_game')),
			button_width: 240,
			button_height: 50,
		}, [
			set(_go_button, child)
		]),

	] where selected_scenario = visible_scenarios[selected_scenario_index]",

	on_being_added: "[
		set(_parent, find_or_die(level.chars, value is obj title_controller)),
		fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),
	]",

	on_window_resize: "[
		set(level.dimensions, [0,0,new_width,new_height]),

		fire_event('show_objects'),
	] where new_width = max(int<- arg.width,1024)-1
	  where new_height = max(int<- arg.height, 768)-1",
}
