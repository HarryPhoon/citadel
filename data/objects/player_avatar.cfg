{
id: "player_avatar",
is_strict: true,

types: {
	AvatarInfo: "{
		path: string,
		translate: null|[decimal,decimal],
		scale: null|decimal,
		flip: null|bool,
	}",
},

properties: {
	_avatar: { type: "string" },

	avatar_info: "{string -> AvatarInfo} ::
	  query_cache(global_cache(), 0, {string -> AvatarInfo} <- get_document('data/avatars.cfg'))",
	
	info: "AvatarInfo :: avatar_info[_avatar] asserting _avatar in avatar_info",

	_reverse: "bool :: if(info.flip, true, false)",

	_top: { type: "int" },
	_edge: { type: "int" },
	_available_space: { type: "int" },
	_width: { type: "int" },
	_height: { type: "int" },

	highlight: { default: true },

	selectable: { default: false },

	player_num: { default: 0 },

	current_desaturation: { default: 0.0 },
	target_desaturation: { default: 0.0 },

	_nick: { type: "string" },

	_nick_font_size: 14,

	_nick_area: "canvas().text_extents(lib.citadel.sans_font, _nick_font_size, _nick)",

	_nick_width: "decimal :: 0.4*_width - max(0, _width - _available_space)",
	_nick_right: "decimal :: 0.4*_width",
	_nick_left: "_nick_right - _nick_width",

	_controller: "null|obj citadel_controller :: find(level.chars, value is obj citadel_controller)",

	_render_key: "[_width, _height, _avatar, facing, _nick_width]",

	render: "def(int ww, int hh) ->commands [
	set(animation, {
		id: 'fbo',
		image: 'fbo',
		x: 0, y: 0, w: ww, h: hh,
		scale: 1, frames: 1,
		fbo: query_cache(global_cache(2), _render_key, c.render(ww, hh, [
			c.save(),
			c.move_to(0*ww, 0*hh),
			c.line_to(0.4*ww, 0*hh),
			c.line_to(1*ww, 0.5*hh),
			c.line_to(0.4*ww, 1*hh),
			c.line_to(0*ww, 1*hh),

			c.clip(),

			c.new_path(),

			if(info.scale, c.scale(info.scale)),
			if(info.translate, c.translate(-info.translate[0], -info.translate[1])),

			c.scale(if(_reverse, -1, 1) * ww/256.0, hh/512.0),
			if(_reverse, c.translate(-ww*2, 0)),


			c.paint_image(info.path),
			c.restore(),
		] +

		if(_nick_width < _nick_area.width+20, [],
		[

			c.save(),
			c.move_to(_nick_left - if(facing = 1, 0, -1) * _nick_area.width + 6, _nick_area.height + 11),
			c.set_font(lib.citadel.sans_font),
			c.set_font_size(_nick_font_size),
			c.scale(facing, 1),
			c.text_path(_nick),
			c.set_source_rgba(1, 1, 1, 1),
			c.fill(),
			c.restore(),

		]) + [

			c.save(),
			c.move_to(0.4*ww - 16, 0*hh),
			c.line_to(0.4*ww, 0*hh),
			c.line_to(1*ww, 0.5*hh),
			c.line_to(0.4*ww, 1*hh),
			c.line_to(0.4*ww - 16, 1*hh),
			c.line_to(1*ww - 16, 0.5*hh),

			c.set_source_rgba(0.09, 0.23, 0.25, 1.0),
			c.fill(),
			c.restore(),

			c.move_to(0.35*ww, 0.01*hh),
			c.line_to(0.41*ww, 0.06*hh),
			c.line_to(0.35*ww, 0.11*hh),
			c.line_to(0.25*ww, 0.11*hh),
			c.line_to(0.19*ww, 0.06*hh),
			c.line_to(0.25*ww, 0.01*hh),
			c.line_to(0.35*ww, 0.01*hh),

			c.move_to(0.19*ww, 0.06*hh),
			c.line_to(0.0*ww, 0.06*hh),
			c.set_line_width(2),
			c.set_source_rgba(1, 1, 1, 1),
			c.stroke(),

			c.move_to(0.35*ww, hh - 0.01*hh),
			c.line_to(0.41*ww, hh - 0.06*hh),
			c.line_to(0.35*ww, hh - 0.11*hh),
			c.line_to(0.25*ww, hh - 0.11*hh),
			c.line_to(0.19*ww, hh - 0.06*hh),
			c.line_to(0.25*ww, hh - 0.01*hh),
			c.line_to(0.35*ww, hh - 0.01*hh),

			c.set_line_width(2),
			c.set_source_rgba(1, 1, 1, 1),
			c.stroke(),

		])) where c = canvas()
	})]",
},

on_type_updated: "fire_event('create')",

on_create: "[
	render(_width, _height),
	set(y, _top),
	if(facing = 1, set(x2, _edge), set(x, _edge)),
]",

shader: {
	name: "player_avatar_render",
	vertex: "
	uniform mat4 u_anura_mvp_matrix;
	uniform vec4 u_anura_sprite_area;
	uniform vec4 u_anura_draw_area;
	uniform vec2 u_target;
	uniform float u_alt_zoom;
	uniform vec2 u_alt_target;
	uniform float u_ratio;
	attribute vec4 a_anura_vertex;
	attribute vec2 a_anura_texcoord;
	varying vec2 v_texcoord;
	varying vec2 v_alt_texcoord;
	void main()
	{
		gl_Position = u_anura_mvp_matrix * a_anura_vertex;
		v_texcoord = a_anura_texcoord;
	}
	",

	fragment: "
	uniform sampler2D u_anura_tex_map;
	uniform float u_ratio;
	uniform vec4 u_anura_sprite_area;
	uniform bool u_highlight;
	uniform float u_desaturation;
	varying vec2 v_texcoord;
	void main()
	{
		gl_FragColor = texture2D(u_anura_tex_map, v_texcoord);

		if(u_highlight) {
			vec2 pos = vec2(v_texcoord[0] + 0.06, v_texcoord[1]);
			if(gl_FragColor[3] == 1.0 && (pos[0] < 0.0 || pos[0] > 1.0 || texture2D(u_anura_tex_map, pos)[3] < 0.2)) {
	
				float count = 7.0;
				for(float i = 0.01; i < 0.06; i += 0.01) {
					pos = vec2(v_texcoord[0] + i, v_texcoord[1]);
					if(pos[0] < 0.0 || pos[0] > 1.0 || texture2D(u_anura_tex_map, pos)[3] < 0.2) {
						count -= 1.0;
					}
				}

				count /= 7.0;
				count = mix(count, 0.0, 0.6);
				gl_FragColor = mix(gl_FragColor, vec4(1,1,1,1), count);
			}
		}
		
		if(u_desaturation > 0.0) {
			float gray = sqrt(pow(gl_FragColor.r,2.2) * 0.2126 + pow(gl_FragColor.g,2.2) * 0.7152 + pow(gl_FragColor.b,2.2) * 0.0722);
			vec4 desaturated = vec4(gray, gray, gray, gl_FragColor[3]);
			gl_FragColor = mix(gl_FragColor, desaturated, u_desaturation);
		}
	}
	",

	draw: "[
		set(uniform_commands.u_highlight, parent.highlight),
		set(uniform_commands.u_desaturation, parent.current_desaturation),
	]
	",
},

on_process: "if(target_desaturation > current_desaturation,
	set(current_desaturation, min(target_desaturation, current_desaturation+0.05)),
	target_desaturation < current_desaturation,
	set(current_desaturation, max(target_desaturation, current_desaturation-0.05))
)",

on_click: "if(_controller != null, _controller.avatar_clicked(me))",

}
