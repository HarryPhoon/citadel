{
	is_strict: true,
	"animation": [

		{
			"id": "creature",
			"image": "citadel-creatures.png",
			"pad": 3,
			x: 0, y: 0, w: 80, h: 80,
			scale: 1,
			frames: 1,
			duration: 1
		},

	],
	
 	"hitpoints": 1,
	"id": "creature",
	mouseover_delay: 20,

	on_click: "[
		if(controller.awaiting_input = false and arg.mouse_button = 3 and creature_object and creature_object.is_on_board,
		   if(abilities_widget, [
			set(me.widgets.tooltip, null),
			set(me.widgets.child, abilities_widget),
		]) where abilities_widget = create_activated_ability_widget(creature_object)),
		controller.creature_clicked(me)
	]",
	
	on_mouse_enter: "null",
	
	on_mouse_move: "[
		if(creature_object.is_on_board and widgets.tooltip = null and
		   (existing_obj = null or existing_obj.zorder < zorder) and

		   //make sure there is no ability dialog showing.
		   find(level.chars, value is obj creature and value.widgets.ability_dialog != null) = null,

		[
			if(existing_obj != null, set(existing_obj.widgets.tooltip, null)),
			set(me.widgets.child, tooltip_w),
			set(tooltip_w.x, if(facing < 0, -tooltip_w.width, me.img_w)),
			set_gui_stats_alpha(255),
		] where tooltip_w = create_tooltip_widget(creature_object, 'tooltip')
		)
		where existing_obj = find(level.chars, value is obj creature and value.widgets.tooltip != null)
	]",

	on_mouse_leave: "[if(me.widgets.tooltip, set(me.widgets.tooltip, null)), if(creature_object, set_gui_stats_alpha(creature_object.stats_alpha))]",

	on_process: "[
	  if(creature_object.is_on_board and (not creature_object.summoned), set(me.alpha, 128 + (64*wave(cycle*10))/1000)),
	   if(_targetxy != null,
	  if(mid_xy = _targetxy, set(_targetxy, null),
	   [if(abs(_targetxy[0] - mid_x) <= move_speed,
	          set(mid_x, _targetxy[0]), add(mid_x, move_speed*sign(_targetxy[0] - mid_x))),
	    if(abs(_targetxy[1] - mid_y) <= move_speed,
	          set(mid_y, _targetxy[1]), add(mid_y, move_speed*sign(_targetxy[1] - mid_y)))]) where move_speed = _animate_move_speed)]",
	
	on_destroy: "[remove_object(me)]",

	on_end_explosion_anim: "destroy()",

	on_render: "[set(animation, if(creature_object.is_construct, render_creature(100, 100), render_creature(80, 80)))]",

	properties: {
		play_sound: "def(string|null fname) ->commands
			if(fname != null, sound(fname, lib.citadel.sound_volume(fname)))",
	
		regen_start_position: { type: "null|object" },
		regen_attrib_cycle: { type: "null|object" },

		regen_start_cycle: { type: "int", default: 0 },
		regen_end_cycle: { type: "int", default: -1 },

		//this is just an avatar in the status bar and shouldn't show
		//on map etc.
		status_avatar: { type: "bool", default: false },

		furthest_animation_hint: { type: "int", default: 0 },
		texture: { type: "null|object" },

		_animate_move_speed: { type: "int", default: 0 },
		_targetxy: { type: "null|Loc" },
		controller: { type: "obj citadel_controller" },
		destroy: "def() ->commands execute(me, fire_event('destroy'))",
		image_num: { variable: false, type: "int", dynamic_initialization: true, set: "[set(time_in_animation, value), set(time_in_animation_delta, 0)]", get: "time_in_animation" },
		
		set_gui_stats_alpha: "def(decimal alpha_value) ->commands
		  if(stats_grid, set(stats_grid.alpha, int(alpha_value))) where stats_grid = widget|null<- me.widgets.gui_stats_grid",

		create_activated_ability_widget: "def(class creature creature) ->null|object
		  if(size(abilities) > 0, widget(me, {
			 type: 'dialog', alpha: 175,
			 clear_background_alpha: 128,
			 padding: 0,
			 frame_padding: [10,10],
			 zorder: 1500,
			 cursor: [10,10],
			 y:-20,
			 background_frame: 'empty_window',
			 id: 'ability_dialog',
			 on_close: q(set(me.widgets.ability_dialog, null)),
			 children: [
			 	{
					type: 'grid',
					columns: 3,
					horizontal_padding: 15,
					swallow_clicks: true,
					allow_draw_highlight: true,
					allow_selection: true,
					must_select: true,
					on_select: q([
						swallow_mouse_event(),
						set(me.widgets.ability_dialog, null),
						if(selection != -1,
						   controller.ability_clicked(creature_object, creature_object.activated_abilities[selection].name)
						)
					]),
					children: fold(map(abilities, [{
						type: 'label',
						font: 'RobotoCondensed-Regular',
						alpha: 255,
						size: 16,
						color: if(can_use, 'white', 'red'),
						text: value.name,
					},

					{
						type: 'label',
						font: 'RobotoCondensed-Regular',
						alpha: 255,
						size: 16,
						color: if(can_use, 'white', 'red'),
						text: str(value.cost),
					},
					
					{
						type: 'label',
						font: 'RobotoCondensed-Regular',
						alpha: 255,
						size: 16,
						color: 'white',
						text: value.rules,
					
					}] where can_use = controller.can_use_ability(creature_object, value.name)
                   ), a+b)
				}
			 ]
		  })) where abilities =
		    if(game_state.nplayer != creature.controller or
			   game_state.current_player_index != creature.controller, [],
			   creature.activated_abilities)",
		
		create_tooltip_widget: "def(class creature creature, string tooltip_id) ->object widget(me, {type:'dialog', alpha:175, clear_background_alpha:128, padding:0, frame_padding:[10,10], zorder:1000, cursor:[10, 10], y:-20, background_frame:'empty_window', id:tooltip_id, children:[
			({type:'label', font:'RobotoCondensed-Regular', alpha:255, size:16, color:switch(creature.controller, -1, 'light_gray', 0, 'yellow', 1, 'orange'), text:creature.name} asserting creature.name != null | creature)]
			+ if(creature.rules, [{type: 'rich_text_label', width: 400, font: 'RobotoCondensed-Regular', size: 14, color: 'antique_white', children: singleton('gui_widgets').parse_markup_into_widgets(creature.rules, 14, 'antique_white')}], [])
			+ map(creature.status_effects, {type: 'label', font: 'RobotoCondensed-Regular', size: 14, color: 'crimson', text: value})
			+ map(creature.abilities, {type: 'label', font: 'RobotoCondensed-Regular', size: 14, color: 'lime_green', text: value})
			+ if(callable_abilities, [{type:'grid', columns:2, column_alignments:['left', 'center'], children:[{type:'grid', columns:1, horizontal_padding:5, children:map(callable_abilities, {type: 'label', font: 'RobotoCondensed-Regular', size: 14, color: 'chocolate', text: value.name})},
				{type:'grid', columns:1, horizontal_padding:5, children:map(callable_abilities, {type: 'label', font: 'RobotoCondensed-Regular', size: 14, color: 'coral', text: value.rules})}]}], [])
			+ if(triggered_abilities, [{type:'grid', columns:2, column_alignments:['left', 'center'], children:[{type:'grid', columns:1, horizontal_padding:5, children:map(triggered_abilities, {type: 'label', font: 'RobotoCondensed-Regular', size: 14, color: if(value.duration_hint, 'dark_turquoise','dodger_blue'), text: value.name})},
				{type:'grid', columns:1, horizontal_padding:5, children:map(triggered_abilities, {type: 'label', font: 'RobotoCondensed-Regular', size: 14, color:if(value.duration_hint,'aquamarine','deep_sky_blue'), text: value.rules})}]}], [])
			}) where callable_abilities = creature.activated_abilities, triggered_abilities = creature.triggered_abilities",
		
		play_animation_hint: "def(class creature obj, map hint) ->commands execute(me, switch(hint.type,
		  'summoned', [
		    play_sound(obj.sound_summoned),
		  	set(me.alpha, 0),
			[schedule(cycle, set(me.alpha, min(255, cycle*10))) | cycle <- range(27)]
		  ],
		  'regeneration', [
		    play_sound(obj.sound_regeneration),
		  	set(regen_start_cycle, cycle+10),
		  	set(regen_end_cycle, cycle+70),
		  ],
		  null))",

		play_attack_animation: "def(class creature new_creature) ->commands
		[
		  play_sound(new_creature.sound_attack),
		  if(size(new_creature.attack_hint.attacks) = 1,
		     [
			  if(new_creature.range <= 1,
			     null,
				 execute(me, map(range(attack.damage),
				   [
				    schedule(controller.animation_move_time + 10 + (value*30)/attack.damage,
				     spawn('creature.missile', src_x, src_y, sign(dst_x - src_x),
					       [set(child.zorder, zorder+950),
						    set(child.velocity_x, ((dst_x - src_x)*100)/10)]))
					 ]
					 where src_x = calculate_x(new_creature, new_creature.loc)
					 where src_y = calculate_y(new_creature, new_creature.loc)
					 where dst_x = calculate_x(class creature<- attack.target, attack.target_loc)))),
				    controller.reserve_animation_time(controller.animation_move_time + 20),

					  ]
					  where attack = new_creature.attack_hint.attacks[0]
		  )]
		",

		play_death_animation: "def(class creature new_creature) ->commands [
			animate(me, {
				alpha: 0,
			}, {
				duration: 25,
				on_complete: me.destroy(),
			}),
			switch(new_creature.death_animation_hint,
			'explosion',
			[
			]),

		]",

		play_endzone_animation: "def() ->commands [
		  play_sound(creature_object.sound_endzone),
		  controller.reserve_animation_time(controller.animation_move_time + 52),
		  execute(me, [map(range(30), schedule(controller.animation_move_time + 20 + value, add(me.brightness, 10))),
		     schedule(controller.animation_move_time + 52, me.destroy())])
		  ]
		  ",

		teleport_and_walk_from: "def(Loc from) ->commands [
			set(me.mid_xy,  [from_x, from_y]),
			set(me._targetxy, [dest_x, dest_y]),
			play_sound(creature_object.sound_walk),
			set(_animate_move_speed, max(abs(dest_x - from_x), abs(dest_y - from_y))/30),
		]
		  where from_x = calculate_x(creature_object, from),
		  where from_y = calculate_y(creature_object, from),
		  where dest_x = calculate_x(creature_object, creature_object.loc),
		  where dest_y = calculate_y(creature_object, creature_object.loc)
		",

		creature_object: {
		type: "class creature",
		set_type: "class creature",
		default: null,
		set: "
		  execute(me, if(status_avatar, set(_data, value),
		  [
			set(shader.uniform_commands.is_poisoned, if(value, 'Poisoned' in value.status_effects, false)) asserting shader,
		    set(me.attached_objects, []),
		    set(me.alpha, 255),
		    set(_data, value),

			set(me.animation, 'creature'),
			set(me.image_num, value.image_num),

			if(value.is_on_board,
			 (if(_data = null,
			     set(me.mid_xy, [target_x, target_y]),
			    [set(me._targetxy, [target_x, target_y]),
				 [
				 if(move_speed > 0, play_sound(value.sound_walk)),
				 set(me._animate_move_speed, max(5, move_speed))
				 ]
				   where move_speed = max(abs(target_x - mid_x), abs(target_y - mid_y))/30,
				 
					if(_data.wounds != value.wounds,
					[
		  			controller.reserve_animation_time(controller.animation_move_time + 40),
					set(shader.uniform_commands.start_cycle, cycle + controller.animation_move_time + 15),
					set(shader.uniform_commands.end_cycle, cycle + controller.animation_move_time + 25),
					set(shader.uniform_commands.cycle, {value: cycle, increment: true}),
					]) asserting shader,
				 ])
			    where target_x = calculate_x(value, value.loc)
				where target_y = calculate_y(value, value.loc))
				 ),
			if(value.is_on_board, set(me.zorder, (value.loc[0]+1)*10 + if(not value.is_construct, 1, 0))),
			if(_data != null and
			   value.attack_hint and ((not _data.attack_hint) or
			   _data.attack_hint.turn != value.attack_hint.turn),
			   me.play_attack_animation(value)),

			if(not value.alive, me.play_death_animation(value)),
			if(value.reached_endzone, me.play_endzone_animation()),

			[play_animation_hint(value, hint) |
			 hint <- value.animation_hints,
			 hint.hint_id > furthest_animation_hint],

			if(value.animation_hints, set(furthest_animation_hint, int<- value.animation_hints[size(value.animation_hints)-1].hint_id)),

			fire_event('render'),
			]))" },

	  calculate_x: "def(class creature value, Loc loc) ->int (level.dimensions[2] - 500)/2 + loc[0]*100 + 50 - if(value.is_construct, 5, 0)",
	  calculate_y: "def(class creature value, Loc loc) ->int 100 + loc_on_screen(loc)[1]*100 + 50 + shift_due_to_engagement
	     where shift_due_to_engagement = if(value.is_construct and value.is_engaged(game_state), if(value.controller != game_state.nplayer, 25, -25), 0) asserting game_state",

	  loc_on_screen: "def(Loc loc) ->Loc [loc[0], if(game_state.nplayer = 0, (game_state.columns-1) - loc[1], loc[1])]",

	  _ability_icons: "[{icon: string, value: int|null}] ::
	  filter([
	    if(creature_object.resistance > 0, { icon: 'resistance.svg', value: creature_object.resistance }),

		if(creature_object.move > 1, { icon: 'movement.svg', value: if(creature_object.move > 2, creature_object.move) }),
	  ], value != null)
	  ",

	  game_state: { type: "class game" },

	  render_creature: "def(int w, int h) ->map {
		id: 'fbo',
		image: 'fbo',
		fbo: c.render(w, h,

		outline(0, 0, w, h) + [
			c.set_radial_pattern(0, h*0.3, w*2.0, w*0.8, h*0.25, w*0.01,
			[
			  { offset: 0, red: 0.4, green: 0.4, blue: 0.4 },
			  { offset: 0.9, red: 0.6, green: 0.6, blue: 0.6 },
			  { offset: 1, red: 1, green: 1, blue: 1 },
			]),
			c.fill(),
		] +

		outline(0, 0, w, h) + [
			c.close_path(),
			c.set_source_rgba(0, 0, 0, 1),
			c.set_line_width(1),
			c.stroke(),
		] +
		
		outline(0.05*w, 0.05*h, 0.9*w, 0.9*h) + [

			c.set_radial_pattern(0.3*w, h*0.3, w*2.0, w, h*0.2, w*0.01,
			[
			  { offset: 0, red: 0.25, green: 0.32, blue: 0.44 },
			  { offset: 1, red: 0.05, green: 0.05, blue: 0.1 },
			]),

			c.fill(),
		] + if(portrait = null, [], outline(0.05*w, 0.05*h, 0.9*w, 0.9*h) + [
			c.clip(),

			c.new_path(),

			c.save(),

			c.translate(-(c.image_dim('images/portraits/' + portrait)[0]*portrait_scale - w)/2.0, 0.0),
			c.scale(portrait_scale, portrait_scale),
			c.set_source_rgba(1, 0, 0, 1),
			c.fill(),

			c.paint_image('images/portraits/' + portrait),

			c.restore(),
		]) + outline(0.05*w, 0.05*h, 0.9*w, 0.9*h) +
		
		if(creature_object.is_construct, [], [
			c.set_source_rgba(0, 0, 0, 1),
			c.set_line_width(1),
			c.stroke(),

			c.reset_clip(),

			c.save(),
			c.translate(w*0.70, h*if(direction_facing > 0, 0.7, 0)),
			c.scale(0.30*h/512.0),
			c.draw_svg('images/icons/life.svg'),
			c.restore(),

			c.save(),
			c.translate(w*0.0, h*if(direction_facing > 0, 0.7, 0)),
			c.scale(0.30*h/512.0),
			c.draw_svg('images/icons/attack.svg'),
			c.restore(),

			c.set_font('Roboto_Condensed/RobotoCondensed-Bold.ttf'),

			//draw the creature's attack.
			c.save(),
			c.translate(0.09*w, if(direction_facing > 0, 0.94, 0.24)*h),
			c.set_font_size(28*h*0.01),

			c.text_path(str(creature_object.attack)),

			c.set_source_rgba(1, 1, 1, 1),
			c.fill(),

			c.text_path(str(creature_object.attack)),

			c.set_line_width(1),
			c.set_source_rgba(0, 0, 0, 1),
			c.stroke(),
			c.restore(),

			//draw the creature's life.
			c.save(),
			c.translate(0.79*w, if(direction_facing > 0, 0.94, 0.24)*h),
			c.set_font_size(28*h*0.01),

			c.text_path(str(max(0, creature_object.life - creature_object.wounds))),

			c.set_source_rgba(1, 1, 1, 1),
			c.fill(),

			c.text_path(str(max(0, creature_object.life - creature_object.wounds))),

			c.set_line_width(1),
			c.set_source_rgba(0, 0, 0, 1),
			c.stroke(),
			c.restore(),

		] +
		
		fold(map(_ability_icons[:min(size(_ability_icons), size(ability_icon_pos))], [

			c.save(),
			c.translate(w*pos[0], h*if(direction_facing > 0, pos[1], 0.7 - pos[1])),
			c.scale(0.30*h/512.0),
			c.draw_svg('images/icons/' + icon_info.icon),
			c.restore(),
			
		] +

		if(icon_info.value = null, [],
		[
			//draw the value on top of this icon
			c.save(),
			c.translate((pos[0] + 0.09)*w, if(direction_facing > 0, pos[1] + 0.24, 0.7 - pos[1] + 0.24)*h),
			c.set_font_size(28*h*0.01),

			c.text_path(str(icon_info.value)),

			c.set_source_rgba(1, 1, 1, 1),
			c.fill(),

			c.text_path(str(icon_info.value)),

			c.set_line_width(1),
			c.set_source_rgba(0, 0, 0, 1),
			c.stroke(),
			c.restore()
		])
		 where pos = ability_icon_pos[index]
		
		where icon_info = value), a+b, [])

		 where ability_icon_pos = [[0.46, 0.7], [0.23, 0.7]]
		
		) where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		if(creature_object.is_construct,
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*0.1, hh*dir(0.1)),
			c.line_to(ww*0.5, hh*dir(0.05)),
			c.line_to(ww*1.0, hh*dir(0.1)),

			c.line_to(ww*1.0, hh*dir(1.0)),
			c.line_to(ww*0.1, hh*dir(1.0)),

			c.restore(),
		],

		if(creature_object.is_building,
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(0.2), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(0.2), hh*dir(0)),

			c.line_to(ww*dir(0.8), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(0.8), hh*dir(1.0)),

			c.restore(),
		],
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(0.1), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.curve_to(ww*dir(0.1), hh*dir(0.2), ww*dir(0.2), hh*dir(0.1), ww*dir(0.5), hh*dir(0)),

			c.curve_to(ww*dir(0.8), hh*dir(0.1), ww*dir(0.9), hh*dir(0.2), ww*dir(1), hh*dir(0.5)),

			c.line_to(ww*dir(0.9), hh*dir(1)),

			c.restore(),
		])) where dir = if(direction_facing > 0, def(decimal a) a, def(decimal a) 1.0 - a)
		) where c = canvas()
		  where portrait = string|null<- if(creature_object.base_card, creature_object.base_card.portrait, null)
		  where portrait_scale = 0.2
		  where direction_facing = if(ctrl != null and ctrl.state.nplayer = 1 where ctrl = find(level.chars, value is obj citadel_controller), -1, 1) * creature_object.direction_moving,
		x: 0, y: 0, w: w, h: h,
		scale: 1,
		frames: 1,
	  }",
	},

	object_type: [

		{
			id: "missile",
			animation: [
				{
					id: "normal",
					image: "missile.png",
					rect: [0,0,71,71],
					frames: 1,
					duration: 10,
					scale: 1,
				}
			],

			on_end_normal_anim: "die()"
		},

	],

	shader: {
		program: "hurt_flash",
		create: "[
			set(uniforms.u_tex_map, 0),
			set(uniform_commands.cycle, {value: parent.cycle, increment: true}),
			set(uniform_commands.start_cycle, 0),
			set(uniform_commands.end_cycle, 0),
			set(uniform_commands.is_poisoned, if(co, 'Poisoned' in co.status_effects, false)) where co = parent.creature_object,
		]"
	},

	effects: [{
		program: "particle1",
		zorder: 1,
		create: "[
			set(parent.texture, load_texture('images/red-cross.png')),
			set(uniforms.u_tex_map, 1),
			set(uniforms.u_color, [255,255,255,255]),
			
			set(parent.regen_start_position, float_array(flatten(map(range(5), [1d70 - 35, 40 - 1d20])), 2)),
			set(parent.regen_attrib_cycle, float_array(flatten(map(range(5), 1d50)), 1)),
		]",
		
		draw: "[
			bind_texture(parent.texture.id, 1),
			
			set(uniforms.u_cycle, parent.cycle),
			set(uniforms.u_start_cycle, parent.regen_start_cycle),
			set(uniforms.u_end_cycle, parent.regen_end_cycle),
			set(uniforms.u_centre_position, [parent.mid_x, parent.mid_y]),
			set(attributes.a_position, parent.regen_start_position),
			set(attributes.a_start_cycle, parent.regen_attrib_cycle),
			draw_arrays('points', 0, 5),
		]",
	}],
}
