{
	is_strict: true,
	"animation": [
		{
			"id": "creature",
			"image": "citadel-creatures.png",
			"pad": 3,
			x: 0, y: 0, w: 80, h: 80,
			scale: 1,
			frames: 1,
			duration: 1
		},
	],
	
 	"hitpoints": 1,
	"id": "creature",

	on_being_removed: "[
	]",

	on_click: "if(_is_preview = false, [
		if(controller.awaiting_input = false and /*arg.mouse_button = 3 and*/ creature_object and creature_object.is_on_board and creature_object.activated_abilities and creature_object.controller = controller.myplayer.player_index,
		[
			swallow_mouse_event(),
			controller.spawn_activated_ability_cards(me)
		],
		    controller.creature_clicked(me),
		),
	])",
	
	on_mouse_enter: "if(_is_preview = false, [
		set(has_mouseover, true),
		animate(me, { mouseover_focus: 1.0 }, { duration: 25 }),
	])",
	
	on_mouse_move: "[

	]",

	on_mouse_leave: "if(_is_preview = false, [
		set(has_mouseover, false),
		animate(me, { mouseover_focus: 0.0 }, { duration: 25 }),
		if(creature_object, set_gui_stats_alpha(creature_object.stats_alpha))
	])",

	on_process: "[

	  if(_in_attack_animation, null, //pass on attack animation right now.
	     creature_object.is_on_board and creature_moving = false and _has_unused_movement and controller.in_combat_animation = false,
	  [
	    if(level.cycle%100 < 18, set(rotate, if(aggressive_anim, 1.0, 0.3)*10*sin((level.cycle%100)*40)), set(rotate, 0)),
		if(_basexy = null,
		[
		   set(_basexy, [mid_x, mid_y]),
		   set(_basez, zorder),
		   set(zorder, zorder+10),
		],
		   if(cycle_pos < 70, [
			set(mid_y, _basexy[1] + if(aggressive_anim, 1.0, 0.3)*sin(cycle_pos*360.0/70.0)*cycle_pos*0.5*direction_moving)
			  where direction_moving = if(game_state.nteam = creature_object.controller, 1, -1),
		   ], [
		   	set(mid_x, _basexy[0]),
		   	set(mid_y, _basexy[1]),
		   ]),
		) where cycle_pos = (level.cycle+50)%100 
	  ] where aggressive_anim = creature_object.targets_attacking(controller.state) != [],
	  [
	    if(_basexy != null, [
			set(mid_x, _basexy[0]),
			set(mid_y, _basexy[1]),
			set(zorder, int<- _basez),
			set(_basexy, null),
		]),
	  	set(rotate, 0),
	  ]
	  ),

		if(_animate_sizing and _current_sizing != null and (_animate_move_delay <= 0),
		[
			add(_current_sizing, sign(sizing - _current_sizing)*0.01),
			fire_event('render'),
		]),

		//animate captures (change of color) only when creatures have
		//finished moving.
		if(_animate_color and find(level.chars, value is obj creature and value.creature_moving) = null, [
			animate(me, {
				_current_bg_color: bg_color,
			}, {
				on_process: [fire_event('render'), set(me._animate_color, false)],
				duration: 25,
			}),
		]),

		if(_animate_move_delay > 0, add(_animate_move_delay, -1))]",
	
	on_destroy: "[remove_object(me)]",

	on_end_explosion_anim: "destroy()",

	on_type_updated: "fire_event('render')",

	on_render: "[
		set(_dirty, true),
	]",

	on_draw: "if(_dirty, [
		set(_dirty, false),
		if(hud_alpha > 0.0, set(hud_texture, render_hud(round_to_even(hex_height*1.3*sz), round_to_even(hex_height*sz)))),
		set(animation, render_image(anim_w, int(mix(anim_h, anim_w*996.0/800.0, if(size_override < 2.0, 0.0, size_override > 3.0, 1.0, size_override - 2.0)))))
		  where anim_w = round_to_even(hex_height*1.3*sz)
		  where anim_h = round_to_even(hex_height*sz),
		set(_current_bg_color, col),
		set(_animate_color, col != bg_color),
		set(_current_sizing, sz),
		set(_animate_sizing, sz != sizing and sz <= 1.0),
	] where sz = if(_current_sizing != null, _current_sizing, sizing)
	  where col = if(_current_bg_color != null, _current_bg_color, bg_color))",

	properties: {
		has_mouseover: { type: "bool", default: false },
		mouseover_focus: { type: "decimal", default: 0.0 },

		scale_x: { type: "decimal", default: 1.0 },
		scale_y: { type: "decimal", default: 1.0 },

		hud_alpha: { type: "decimal", default: 1.0 },


		play_sound: "def(string|null fname) ->commands
			if(_is_preview = false and fname != null, sound(fname, lib.citadel.sound_volume(fname)))",
	
		regen_start_position: { type: "null|object" },
		regen_attrib_cycle: { type: "null|object" },

		regen_start_cycle: { type: "int", default: 0 },
		regen_end_cycle: { type: "int", default: -1 },

		//this is just an avatar in the status bar and shouldn't show
		//on map etc.
		status_avatar: { type: "bool", default: false },

		furthest_animation_hint: { type: "int", default: 0 },
		texture: { type: "null|object" },

		hex_height: { type: "int" },

		_is_preview: { type: "bool", default: false },

		_animate_move_speed: { type: "int", default: 0 },
		_animate_move_delay: { type: "int", default: 0 },
		_basexy: { type: "null|Loc" },
		_basez: { type: "null|int" },
		creature_moving: "bool :: level.cycle < _animating_until",
		_animating_until: { type: "null|int" },

		_has_unused_movement: "bool ::
		  game_state.current_player_turn_index = creature_object.controller and
		  creature_object.move > creature_object.spaces_moved_this_turn",

		controller: { type: "obj citadel_controller" },
		destroy: "def() ->commands execute(me, fire_event('destroy'))",
		image_num: { variable: false, type: "int", dynamic_initialization: true, set: "[set(time_in_animation, value), set(time_in_animation_delta, 0)]", get: "time_in_animation" },
		
		set_gui_stats_alpha: "def(decimal alpha_value) ->commands
		  if(stats_grid, set(stats_grid.alpha, int(alpha_value))) where stats_grid = widget|null<- me.widgets.gui_stats_grid",

		hand_card_entered: "def() ->commands [
		]",

		play_animation_hint: "def(class creature obj, map hint) ->commands execute(me, switch(hint.type,
		  'summoned', [
		    play_sound(obj.sound_summoned),
		  	set(me.alpha, 0),
			[schedule(cycle, set(me.alpha, min(if(_is_preview, 128, 255), cycle*10))) | cycle <- range(27)]
		  ],
		  'regeneration', [
		    debug(['REGEN SOUND', obj.sound_regeneration]),
		    play_sound(obj.sound_regeneration),
		  	set(regen_start_cycle, cycle+10),
		  	set(regen_end_cycle, cycle+70),
		  ],
		  null))",

		furthest_attack_id: { type: "int", default: -1 },

		play_attack_animation: "def(class creature new_creature) ->commands
		[
		  play_sound(new_creature.sound_attack),
		  if(size(new_creature.attack_hint.attacks) = 1,
		     [
			 debug('ATTACK_HINT'),
			  if(new_creature.range <= 1,
			     null,
				 execute(me, map(range(attack.damage),
				   [
				    schedule(controller.animation_move_time + 10 + (value*30)/attack.damage,
				     spawn('creature.missile', src_x, src_y, sign(dst_x - src_x),
					       [set(child.zorder, zorder+950),
						    set(child.velocity_x, ((dst_x - src_x)*100)/10)]))
					 ]
					 where src_x = calculate_x(new_creature.loc)
					 where src_y = calculate_y(new_creature.loc)
					 where dst_x = calculate_x(attack.target_loc)))),
				    controller.reserve_animation_time('creature_attack_anim', controller.animation_move_time + 20),

			  ]
			  where attack = new_creature.attack_hint.attacks[0]
		  )]
		",

		play_death_animation: "def(class creature new_creature) ->commands

		if(controller is obj citadel_controller and controller.time_to_resolve_card > 0,
		   schedule(controller.time_to_resolve_card, cmd),
		   cmd
		)
		
		where cmd = [
			if(new_creature.sound_death, play_sound(new_creature.sound_death)),
			animate(me, {
				alpha: 0,
			}, {
				duration: 25,
				on_complete: me.destroy(),
			}),
			switch(new_creature.death_animation_hint,
			'explosion',
			[
			]),

		]",

		play_endzone_animation: "def(int damage) ->commands [

			animate(me, { zorder: 20000, size_override: 3.0, hud_alpha: 0.0, mid_x: level_mid_x, mid_y: level_mid_y }, { name: 'endzone', duration: 50 }),

			animate(me, { mid_x: target_x, mid_y: target_avatar.mid_y, scale_x: 0.9, scale_y: 1.1 }, { name: 'endzone', duration: 8, easing: def(decimal ratio)->decimal sin(ratio*90.0 - 180.0)*0.2 }),
			animate(me, { mid_x: target_x, mid_y: target_avatar.mid_y, scale_x: 1.2, scale_y: 0.8, image_zoom_override: 1.0 }, { name: 'endzone', duration: 8, easing: def(decimal ratio)->decimal ratio, on_complete: [
			  controller.screen_shake(min(20, damage*2), 30, 5),
			  target_avatar.flash_hit() ;
			  controller.avatar_life[target_avatar.player_num].remove_modify_life(me)

			] }),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y, scale_x: 1.0, scale_y: 1.0 }, { name: 'endzone', duration: 8, easing: def(decimal ratio)->decimal ratio*0.2 }),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y }, { name: 'endzone', duration: 20, easing: def(decimal ratio)->decimal ratio*0.5 }),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y, alpha: 0, scale_x: 1.5, scale_y: 1.5 }, { name: 'endzone', duration: 25, easing: def(decimal ratio)->decimal ratio, on_complete: remove_object(me) }),

		] where target_x = if(target_avatar.mid_x > me.mid_x, target_avatar.x, target_avatar.x + target_avatar.img_w)
		  where target_avatar = find_or_die(level.chars, value is obj player_avatar and controller.state.team_index(creature_object.controller) != controller.state.team_index(value.player_num))
		  where level_mid_x = controller.level_width/2
		  where level_mid_y = controller.level_height/2
		  ",

		_display_life: { type: "int|null" },
		displayed_life: "int :: if(_display_life != null, _display_life, creature_object.life)",

		animate_movement: "def(Loc to, string anim_type) ->commands [
			if(anim_type = 'blink',
			[
			//spawn_particle_example(),
			blink_particles(),
			animate(me, {
				scale: 0,
			}, {
				duration: 10,
				name: 'blink',
			}),
			schedule(25, blink_particles_end()),
			schedule(25, animate(me, {
				scale: 1,
			}, {
				duration: 10,
				name: 'blink',
			})),
			schedule(10, animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 1,
				name: 'blink',
			}))
			]),
		
			if(anim_type = 'swap',
			[
			animate(me, {
				mid_x: end_x + controller.tile_width * if(end_y < mid_y, -1, 1),
				mid_y: (mid_y+end_y)/2,
			}, {
				duration: 25,
				name: 'swap',
			}),
			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 25,
				name: 'swap',
			})
			]),

			if(anim_type = 'move',
			[
			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 50,
			})
			]),
		]
		where end_x = calculate_x(to)
		where end_y = calculate_y(to)",

		creature_object: {
		type: "class creature",
		set_type: "class creature",
		default: null,
		set: "
		  execute(me, if(status_avatar, set(_data, value),
		  [
		    set(attack_animation_priority, false),
			set(shader.uniform_commands.is_poisoned, if(value, 'Poisoned' in value.status_effects, false)) asserting shader,
			set(shader.uniform_commands.is_sleeping, value.is_sleeping) asserting shader,
		    set(me.attached_objects, []),
		    set(me.alpha, 255),
		    set(_data, value),

			set(me.animation, 'creature'),
			set(me.image_num, value.image_num),

			set(me._display_life, value.life),

			if(value.is_on_board,

			 [
				map(value.movement_log, [
				  debug(['ANIMATE MOVEMENT LOG: ', value]),
				  schedule(50*index, [
				  	set(mid_xy, [begin_x, begin_y]),
				  	bind_command(me.animate_movement, Loc<- value[1], string<- value[2])
				  ])
				] 
		             where begin_x = calculate_x(from)
		             where begin_y = calculate_y(from)
				  where from = Loc<- value[0]

			   ),

			   set(_animating_until, level.cycle + 50*size(value.movement_log)),

			   schedule(50*size(value.movement_log)+1, set(mid_xy, [target_x, target_y])),
			 (if(_data = null,
			     set(me.mid_xy, [target_x, target_y]),

				//_data != null meaning we're updating the object
				//rather than being a new object
			    [
				//spawn a life change label
				if(_display_life != null and _display_life != value.life,
				   spawn('label', mid_x, mid_y, {
						zorder: me.zorder+1000,
						_text: [str(value.life - _display_life)],
						red: if(_display_life > value.life, 255, 0),
						green: if(_display_life < value.life, 255, 0),
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ])),
				    
				 [
				 if(move_speed > 0, play_sound(value.sound_walk)),
				 set(me._animate_move_speed, max(5, move_speed)),

				 ]
				   where move_speed = max(abs(target_x - mid_x), abs(target_y - mid_y))/30,
				 
					if(_data.life != value.life,
					[
		  			controller.reserve_animation_time('creature_life_change', controller.animation_move_time + 40),
					]) asserting shader,
				 ])
			   )
			 ]
			    where target_x = calculate_x(value.loc)
				where target_y = calculate_y(value.loc)
		   ), //end value.is_on_board
			if(value.is_on_board, set(me.zorder, (value.loc[0]+1)*10 + if(not value.is_construct, 1, 0))),


			if(_data != null and value.attack_hint and value.attack_hint.id > furthest_attack_id,
			[
			   me.play_attack_animation(value),
			   set(furthest_attack_id, value.attack_hint.id),
			]),

			if(not value.alive, me.play_death_animation(value)),

			[play_animation_hint(value, hint) |
			 hint <- value.animation_hints,
			 hint.hint_id > furthest_animation_hint],

			if(value.animation_hints, set(furthest_animation_hint, int<- value.animation_hints[size(value.animation_hints)-1].hint_id)),

			fire_event('render'),
			]))" },

	  calculate_x: "def(Loc loc) ->int (level.dimensions[2] - controller.board_width)/2 + loc[0]*controller.tile_x_spacing - controller.tile_x_spacing/4 + int(hex_height*1.3/2)",
	  calculate_y: "def(Loc loc) ->int controller.board_ypos + loc_on_screen(loc)[1]*controller.tile_y_spacing + if(loc[0]%2 = 0, controller.tile_height/2, if(game_state.nteam = 1, controller.tile_height, 0))
	      asserting game_state",
	  
	  get_hit_animation: "def(int damage) ->commands execute(me, [
	    [set(c.attack_animation_priority, false) | c <- level.chars, c is obj creature],
		set(attack_animation_priority, true),
		set(shader.uniform_commands.is_flashing, true) asserting shader,
		schedule(3, set(shader.uniform_commands.is_flashing, false)) asserting shader,

		if(damage > 0, [
			set(_display_life, displayed_life - damage),
			set(_dirty, true),

			spawn('label', int(x + img_w*0.82), mid_y, {
						zorder: me.zorder+1000,
						_text: [str(damage)],
						red: 255,
						green: 0,
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ]),
		]),
	  ])",
	  
	  drain_animation: "def(int drain, obj creature target_creature) ->commands [
		if(drain > 0, [
			set(_display_life, displayed_life + drain),
			set(_dirty, true),

			spawn('label', int(x + img_w*0.82), mid_y, {
						zorder: me.zorder+1000,
						_text: [str(drain)],
						red: 0,
						green: 255,
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ]),

			map(range(60),
				spawn('game_icon', 0, 0, {
					size: controller.px(32),
					icon: 'drop.svg',
					blue: 0,
					green: 0,
					red: 128,
					alpha: 32 + 1d64,
					mid_x: target_creature.mid_x + 1d(controller.px(64)) - 1d(controller.px(64)),
					mid_y: target_creature.mid_y + 1d(controller.px(64)) - 1d(controller.px(64)),
					zorder: 2000,
				}, [
					animate(child, {
						mid_x: mid_x,
						mid_y: mid_y,
						alpha: 0,
					}, {
						duration: 20,
						on_complete: remove_object(child),
					}),
				]
				)
			)
		]),
	  ]",

	  spawn_attack_info_label: "def(string text) ->commands execute(me, [
			spawn('label', mid_x, mid_y, {
						zorder: me.zorder+1000,
						_text: [text],
						_font_size: controller.px(24),
						red: 255,
						green: 255,
						blue: 255,
				   }, [
				    schedule(50, remove_object(child))
				   ]),
	  ])",

	  combat_die_animation_priority: { type: "bool", default: false },

	  attack_animation_priority: { type: "bool", default: false },

	  _in_attack_animation: { type: "bool", default: false },
	  do_attack_animation: "def(class creature new_creature) ->commands
	  execute(me, [
	    set(attack_animation_priority, false),
	  	set(furthest_attack_id, attack_hint.id),
		if(size(attack_hint.attacks) = 1, [
		   controller.reserve_animation_time('creature_attack_animation', 55),

		   set(_in_attack_animation, true),

		   add(me.brightness, 50),
		   add(me.zorder, 100),

		   animate(me, {
			rotate: 0.0,
		   }, {
			name: 'straighten',
			duration: 5,
		   }),

		   if(('First Strike' in creature_object.abilities) and target_creature != null and ('First Strike' not in target_creature.creature_object.abilities),
			spawn_attack_info_label('First Strike!')
		   ),

		   if(creature_object.range = 0,
		   [
			   animate(me, {
				 mid_x: target_x,
				 mid_y: target_y,
				 scale_y: 0.88,
				 scale_x: 1.08,
			   }, {
				 name: 'attack',
				 easing: def(decimal ratio)->decimal
				   sin(ratio*90.0 - 180.0)*0.2,
				 duration: 10,
			   }),

			   animate(me, {
				 rotate: 0.0,
				 scale_y: 0.85,
				 scale_x: 1.1,
			   }, {
				 name: 'attack',
				 duration: 5,
			   }),

			   animate(me, {
				 mid_x: target_x,
				 mid_y: target_y,
				 scale_y: 1.4,
				 scale_x: 0.6,
			   }, {
				 name: 'attack',
				 easing: def(decimal ratio)->decimal ratio*0.7,
				 on_complete: [
				 	controller.screen_shake(min(20, int(attack.damage*1.5)), 30, 5),
					if(target_creature, [
						target_creature.get_hit_animation(attack.damage),
						drain_animation(attack.drain, target_creature),
					]),
				 ],
				 duration: 5,
				 replace_existing: false,
			   }),

			   animate(me, {
				 mid_x: mid_x,
				 mid_y: mid_y,
				 scale_y: 1.0,
				 scale_x: 1.0,
			   }, {
					 name: 'attack',
				 easing: def(decimal ratio)->decimal ratio*0.2,
				 duration: 5,
				 replace_existing: false,
			   }),

			   animate(me, {
				 mid_x: if(_basexy, _basexy[0], mid_x),
				 mid_y: if(_basexy, _basexy[1], mid_y),
				 scale_y: 1.0,
				 scale_x: 1.0,
			   }, {
				 name: 'attack',
				 replace_existing: false,
				 duration: 20,
				 on_complete: [set(_in_attack_animation, false), add(me.zorder, -100)],
			   }),
		   ],

		   //ranged attack
		   [
		   		spawn('game_icon', 0, 0, {
					size: controller.px(48),
					icon: 'arrows.svg',
					mid_x: mid_x,
					mid_y: mid_y,
					zorder: 2000,
				}, [
					animate(child, {
						mid_x: target_x,
						mid_y: target_y,
					}, {
						duration: 20,
						on_complete: [
							if(target_creature, [
								target_creature.get_hit_animation(attack.damage),
								drain_animation(attack.drain, target_creature),
							]),

							remove_object(child),
						]
					}),
				]
				),

				schedule(50, [set(_in_attack_animation, false), add(me.zorder, -100)])
		   ]),

		   schedule(50, add(me.brightness, -50)),

		] where target_x = calculate_x(attack.target_loc)
		  where target_y = calculate_y(attack.target_loc)
		  where target_creature = find(level.chars, value is obj creature and value.creature_object.summon_id = attack.target.summon_id)
		  where attack = attack_hint.attacks[0])
	  ])
	  	where attack_hint = class animation.attacks<- new_creature.attack_hint
	  ",

	  loc_on_screen: "def(Loc loc) ->Loc [loc[0], if(game_state.nteam = 0, (game_state.columns-1) - loc[1], loc[1])]",

	  game_state: { type: "class game" },

      _animate_sizing: { default: false },
	  _current_sizing: { type: "null|decimal" },

	  size_override: { variable: false, type: "decimal", get: "if(_current_sizing != null, _current_sizing, sizing)", set: "[set(_dirty, true), set(_current_sizing, value)]" },

	  sizing: "decimal :: if(creature_object.is_construct = false and game_state.construct_at_loc(creature_object.loc) != null, 0.75, 1.0)",

	  bg_color: "[decimal,decimal,decimal] ::
			switch(creature_object.controller,
			       0, if(creature_object.is_construct, [0.53, 0.25, 0.31], [0.34, 0.12, 0.16]),
			       1, if(creature_object.is_construct, [0.31, 0.25, 0.53], [0.16, 0.12, 0.34]),
			       if(creature_object.is_construct, [0.7, 0.8, 0.7], [0.16, 0.12, 0.16]))
	  ",

	  _current_bg_color: { type: "null|[decimal,decimal,decimal]" },
	  _animate_color: { default: false },

	  _dirty: { default: true },

	  hud_texture: { type: "null|texture_object" },

	  image_zoom_override: { type: "decimal", default: 0.0, set: "[set(_data, value), set(_dirty, true)]" },

	  render_image: "def(int w, int h) ->Animation
		lib.citadel.render_frame(c, w, h,

		[
			c.translate(w*if(creature_object.is_construct, 0.06, 0.04), h*if(creature_object.is_construct, 0.04, 0.0)),
			c.scale(0.92, 0.92),

			c.save(),
			outline(0, 0, w, h),
			c.set_linear_pattern(0, 0, 100, 10, [
				{ offset: 0, red: 0, green: 0, blue: 0.1 },
				{ offset: 1, red: 0.1, green: 0.1, blue: 0.3 },
			]),
			c.fill(),
			c.restore(),

			outline(0, 0, w, h),

			c.clip(),

			c.new_path(),

			c.save(),

			if(creature_object.portrait_focus != null, [
				c.translate(w/2, h/2),
				c.scale(min([
					mix(if(creature_object.portrait_focus_width is int, decimal(w)/decimal(creature_object.portrait_focus_width), 1.0), w/800.0, size_override_ratio),
					mix(if(creature_object.portrait_focus_height is int, decimal(h)/decimal(creature_object.portrait_focus_height), 1.0), h/996.0, size_override_ratio),
				])),

				c.paint_image('images/portraits/' + portrait, [-int(mix(creature_object.portrait_focus[0], 800/2, size_override_ratio)), -int(mix(creature_object.portrait_focus[1], 996/2, size_override_ratio))])
			] where size_override_ratio = if(size_override <= 2.0, 0.0, size_override >= 3.0, 1.0, size_override - 2.0) - image_zoom_override, [

				c.translate(-(c.image_dim('images/portraits/' + portrait)[0]*portrait_scale - w)/2.0 - portrait_x_offset, portrait_scale*90.0 - portrait_y_offset),
				c.scale(portrait_scale, portrait_scale),

				c.paint_image('images/portraits/' + portrait),
			]),

			c.restore(),
		]

		) where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent), hh*dir(0)),

			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1.0)),

			c.line_to(ww*dir(hex_indent), hh*dir(1)),

			c.restore(),
		]
		 where dir = def(decimal a) a
		 where hex_indent_inverse = 1.0 - hex_indent
		 where hex_indent = if(size_override > 2.0, 0.0, if(size_override < 1.0, 1.0, 2.0 - size_override)*(w - h)/decimal(w))

		 where c = canvas()
		 where portrait = creature_object.calculate_portrait
		 where portrait_x_offset = creature_object.portrait_x_offset*scaling
		 where portrait_y_offset = creature_object.portrait_y_offset*scaling
		 where portrait_scale = creature_object.portrait_scale*scaling
		 where scaling = w/120.0
	  ",

	  render_hud: "def(int w, int h) ->texture_object
		c.render(w, h,

		[
			c.translate(w*if(creature_object.is_construct, 0.06, 0.04), h*if(creature_object.is_construct, 0.04, 0.0)),
			c.scale(0.92, 0.92),
			c.save(),

			if(creature_object.is_construct = false, [

			//render the 3D 'sides' of the creature.
			c.save(),
			c.move_to(w*dir(0), h*(0.5)),
			c.line_to(w*dir(0), h*(0.6)),
			c.line_to(w*dir(hex_indent), h*(1.1)),
			c.line_to(w*dir(hex_indent), h*(1)),
			c.set_source_rgba(0.61*0.4,0.84*0.4,0.65*0.4,1),
			c.fill(),
			c.restore(),

			c.save(),
			c.line_to(w*dir(hex_indent), h*(1.1)),
			c.line_to(w*dir(hex_indent), h*(1)),
			c.line_to(w*dir(hex_indent_inverse), h*(1)),
			c.line_to(w*dir(hex_indent_inverse), h*(1.1)),
			c.set_source_rgba(0.61*0.6,0.84*0.6,0.65*0.6,1),
			c.fill(),
			c.restore(),

			c.save(),
			c.move_to(w*dir(1), h*(0.5)),
			c.line_to(w*dir(1), h*(0.6)),
			c.line_to(w*dir(hex_indent_inverse), h*(1.1)),
			c.line_to(w*dir(hex_indent_inverse), h*(1)),
			c.set_source_rgba(0.61*0.5,0.84*0.5,0.65*0.5,1),
			c.fill(),
			c.restore(),
			]),

			if(creature_object.controller != -1, map(range(creature_object.actions), [
				c.save(),
				c.set_source_rgba(1, 1, 1, 1),
				c.move_to(w*(0.3 + index*0.1), h*(0.62 - 0.05*direction_moving)),
				c.line_to(w*(0.35 + index*0.1), h*(0.62 + 0.05*direction_moving)),
				c.line_to(w*(0.25 + index*0.1), h*(0.62 + 0.05*direction_moving)),
				c.fill(),
				c.restore(),
			]
			  where direction_moving = if(game_state.nteam = creature_object.controller, 1, -1)
			))

		] +

		if(creature_object.is_construct and creature_object.controller != -1, [
			outline(w*0.05, h*0.05, w*0.9, h*0.9),

			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 0.5), c.set_source_rgba(0, 0, 0, 1)),
			c.set_line_width(4),
			c.stroke(),
		], []) +

		if(creature_object.is_construct = false, [
			outline(w*0.02, h*0.37, w*0.25, h*0.25),
			if(creature_object.controller = ctrl.state.nteam, white_col, black_col),
			c.fill(),

			outline(w*0.72, h*0.37, w*0.25, h*0.25),
			if(creature_object.controller = ctrl.state.nteam, white_col, black_col),
			c.fill(),

			c.set_font(lib.font.regular_font),
			c.set_font_size(24*font_scaling),

			c.save(),
			c.translate(w*0.13 - attack_extents.width/2, h*0.57),
			if(creature_object.controller = ctrl.state.nteam, black_col, white_col),
			c.text_path(str(creature_object.attack)),
			c.fill(),
			c.restore(),

			c.save(),
			c.translate(w*0.83 - life_extents.width/2, h*0.57),
			if(creature_object.controller = ctrl.state.nteam, black_col, white_col),
			c.text_path(str(displayed_life)),
			c.fill(),
			c.restore(),
		] where attack_extents = c.text_extents(lib.font.regular_font, 24*font_scaling, str(creature_object.attack))
		  where life_extents = c.text_extents(lib.font.regular_font, 24*font_scaling, str(creature_object.life)),
		
		if(creature_object.energy > 0, [

			outline(w*0.72, h*0.37, w*0.25, h*0.25),
			if(creature_object.controller = ctrl.state.nteam, white_col, black_col),
			c.fill(),

			c.set_font(lib.font.regular_font),
			c.set_font_size(24*font_scaling),

			c.save(),
			c.translate(w*0.79, h*0.57),
			if(creature_object.controller = ctrl.state.nteam, black_col, white_col),
			c.text_path(str(creature_object.energy)),
			c.fill(),
			c.restore(),
		], [
		])) +

		if(doomed, [
			c.save(),

			c.translate(w*0.3, h*0.2),
			c.draw_svg(if(ascended, 'images/icons/angel-wings.svg', 'images/icons/skull-crack.svg'), h/2, h/2),

			c.restore(),
			
		], []) +

		map(ability_info[:size(ability_draw_areas)],
		[

			c.save(),
			c.rectangle(0*w, draw_area.rect_offset*h, 1*w, 0.1*h),
			c.clip(),
			c.new_path(),

			outline(0.05*w, 0.05*h, 0.9*w, 0.9*h),
			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 1), c.set_source_rgba(0, 0, 0, 1)),
			c.fill(),

			c.restore(),

			c.save(),
			c.translate(0.5*w - text_area.width*0.5, (draw_area.rect_offset+0.09)*h),
			c.set_font(lib.font.regular_font),
			c.set_font_size(12*font_scaling),
			c.text_path(value.text),
			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(0, 0, 0, 1), c.set_source_rgba(1, 1, 1, 1)),
			c.fill(),
			c.restore(),

			if(value.is_activated, [
				c.save(),
				outline(left_hex, top_hex, 0.1*w, 0.1*h) where left_hex = 0.5*w - text_area.width*0.5 - 0.1*w where top_hex = draw_area.rect_offset*h,
				if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(0, 0, 0, 1), c.set_source_rgba(1, 1, 1, 1)),
				c.fill(),
				c.restore(),

				c.save(),
				c.set_source_rgba(1, 1, 1, 1),
				c.translate(0.5*w - text_area.width*0.5 - 0.07*w, (draw_area.rect_offset+0.09)*h),
				if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 1), c.set_source_rgba(0, 0, 0, 1)),
				c.set_font(lib.font.regular_font),
				c.set_font_size(10*font_scaling),
				c.text_path(str(value.cost)),
				c.fill(),

				c.restore(),
			]),

		] where text_area = c.text_extents(lib.font.regular_font, 12*font_scaling, value.text)
		  where draw_area = ability_draw_areas[index])

		where ability_draw_areas = if(creature_object.controller = ctrl.state.nteam,
		[
			{
				rect_offset: 1.0 - 0.95,
			},
			{
				rect_offset: 1.0 - 0.8,
			},

			{
				rect_offset: 0.85,
			},
			{
				rect_offset: 0.7,
			},
		
		], [
			{
				rect_offset: 0.85,
			},
			{
				rect_offset: 0.7,
			},
			{
				rect_offset: 1.0 - 0.95,
			},
			{
				rect_offset: 1.0 - 0.8,
			}
		])

		where ability_info =
		if(creature_object.controller = -1, [],
		map(creature_object.abilities + creature_object.rules_short +
		    map(filter(creature_object.triggered_abilities, value.hidden_on_creature = false), value.summary) +
		 if(creature_object.is_construct, [],
		  if(creature_object.resistance = 0, [], [str(creature_object.resistance) + ' Armor']) +
		  if(creature_object.range = 0, [], [str(creature_object.range) + ' Range']) +
		  if(creature_object.move = 1, [], creature_object.is_building, ['Building'], [str(creature_object.move) + ' Moves'])),
		  {
			text: value,
			is_activated: false,
			cost: 0,
		}) +
		
		map(filter(creature_object.activated_abilities, if(value is class activated_ability, value.hidden_on_creature = false, true)), {
			text: value.name,
			is_activated: true,
			cost: value.cost,
		}))

		) where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent), hh*dir(0)),

			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1.0)),

			c.line_to(ww*dir(hex_indent), hh*dir(1)),

			c.restore(),
		]

		 where outline_top = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.move_to(ww*dir(hex_indent), hh*dir(0)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.restore(),
		 ]

		 where outline_bot = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1)),
			c.restore(),
		 ]

		 where outline_portrait = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.3)),

			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.7)),

			c.restore(),
		 ]
		 where font_scaling = h/100.0
		 where hex_indent_inverse = 1.0 - hex_indent
		 where hex_indent = (w - h)/decimal(w)
		 where dir = if(direction_facing > 0, def(decimal a) a, def(decimal a) 1.0 - a)
		 where white_col = c.set_source_rgba(1, 1, 1, 1)
		 where black_col = c.set_source_rgba(0, 0, 0, 1)
		 where c = canvas()
		  where portrait = creature_object.calculate_portrait
		  where portrait_x_offset = creature_object.portrait_x_offset*scaling
		  where portrait_y_offset = creature_object.portrait_y_offset*scaling
		  where portrait_scale = creature_object.portrait_scale*scaling
		  where scaling = w/120.0
		  where direction_facing = if(ctrl != null and ctrl.state.nteam = 1, -1, 1) * creature_object.direction_moving
		  where ascended = ctrl.end_of_turn_state != null and doomed and find(ctrl.end_of_turn_state.endzoned_creatures, value = creature_object.summon_id) != null
		  where doomed = (_is_preview = false) and ctrl.end_of_turn_state != null and
		                (creature_object.is_construct = false and (future_me = null or future_me.controller != creature_object.controller)
		    where future_me = find(ctrl.end_of_turn_state.creatures, value.summon_id = creature_object.summon_id))
		  where ctrl = find_or_die(level.chars, value is obj citadel_controller)
	  ",

	  _tooltip_text: "string ::

		if(creature_object.is_building, 'Building', creature_object.is_construct, 'Land', 'Creature' + c.emdash + str(creature_object.attack) + ' Atk, ' + str(creature_object.life) + ' Life') + '\n' +


		if(creature.is_construct = false and creature_object.resistance > 0,
			'Armor' + c.emdash + str(creature_object.resistance) + '\n(The first ' + str(creature_object.resistance) + ' damage from any attack is prevented)\n', '') +

		if(creature.is_construct = false and creature.is_building = false and creature.move != 1,
			'Movement' + c.emdash + str(creature_object.move) + '\n(Moves ' + creature.move + ' tiles each turn)\n', '') +


		if(creature.is_construct = false and creature.range != 0,
			'Range' + c.emdash + str(creature_object.range) + if(creature_object.range = 1, '\n(Attacks adjacent enemies even if not engaged in melee combat)', '\n(Attacks enemies up to ' + str(creature.range) + ' tiles away)' + '\n'), ''
		) +

		if(creature.abilities, fold(map(creature.abilities,
			value + if(help_str = null, '', ' (' + str(help_str) + ')' + '\n') where help_str = help[value]
		), a+b), '') +

		if(creature.passive_abilities, fold(map(filter(creature.passive_abilities, value.hidden_on_creature = false),
		value.name + q( <font tag='circle' size='-4'>P</font> &emdash;) + value.rules
		), a+b), '') +

		if(creature.triggered_abilities, fold(map(filter(creature.triggered_abilities, value.hidden_on_creature = false),
		value.name + q( <font tag='circle' size='-4'>T</font> &emdash;) + value.rules
		), a+b), '') +

		creature.rules

		where creature = creature_object
		where help = lib.json.get_document_map('data/help-abilities.cfg')
		where c = canvas()
	  ",
	  
		blink_particles: "def() ->commands [
			set(me.particles, {
				id: 'blinkparticles_start',
				camera: { name: 'psc_cam', type: 'orthogonal', ortho_window: [0,controller.level_width,0,controller.level_height] },
				scale_velocity: 1,
				technique: [{
					position: [mid_x,mid_y],
					ignore_global_model: true,
					visual_particle_quota: 1000,
					texture: 'particles/flare-128x128.png',
					blend: 'alpha_blend',
					depth_write: false,
					depth_check: false,
					default_particle_width: 48,
					default_particle_height: 48,
					renderer: {
						type: 'billboard',
					},
					emitter: [{
						type: 'circle',
						position: [0, 0, 0],
						emission_rate: 700.0,
						circle_radius: 30,
						direction: [0, 1, 0],
						duration: 0.1,
						repeat_delay: 20,
						time_to_live: 1,
						velocity: 75,
						angle: { type: 'dyn_random', min: 0.0, max: 360.0 },
						color: [1, 1, 1, 1],
					}],
					affector: [{
						type: 'color',
						time_colour: [{time: 0, color: [1, 1, 1, 1]}, {time: 1, color: [1, 1, 1, 0]}],
					}],
				}]
			}),
			schedule(15, set(me.particles, null)),
		]",
	
		blink_particles_end: "def() ->commands [
			set(me.particles, {
				id: 'blinkparticles_end',
				camera: { name: 'psc_cam', type: 'orthogonal', ortho_window: [0,controller.level_width,0,controller.level_height] },
				scale_velocity: 1,
				technique: [{
					position: [mid_x,mid_y],
					ignore_global_model: true,
					visual_particle_quota: 1000,
					texture: 'particles/flare-128x128.png',
					blend: 'alpha_blend',
					depth_write: false,
					depth_check: false,
					default_particle_width: 48,
					default_particle_height: 48,
					renderer: {
						type: 'billboard',
					},
					emitter: [{
						type: 'circle',
						position: [0, 0, 0],
						emission_rate: 700.0,
						circle_radius: 50,
						direction: [0, -1, 0],
						duration: 0.1,
						repeat_delay: 20,
						time_to_live: 1,
						velocity: 75,
						angle: { type: 'dyn_random', min: 0.0, max: 180.0 },
						color: [1, 1, 1, 1],
					}],
					affector: [{
						type: 'color',
						time_colour: [{time: 0, color: [1, 1, 1, 1]}, {time: 1, color: [1, 1, 1, 0]}],
					}],
				}]
			}),
			schedule(15, set(me.particles, null)),
		]",
	
	
	  //an example of a particle effect.
	  spawn_particle_example: "def() ->commands [
	  	set(me.particles, {
			id: 'test',
			camera: { name: 'psc_cam', type: 'orthogonal', ortho_window: [0,controller.level_width,0,controller.level_height] },
			scale_velocity: 1,
			technique: [{
				position: [mid_x,mid_y],
				ignore_global_model: true,
				visual_particle_quota: 2000,
				texture: 'particles/flare-128x128.png',
				blend: ['src_alpha', 'one_minus_src_alpha'],
				depth_write: false,
				depth_check: false,
				default_particle_width: 32,
				default_particle_height: 32,
				renderer: {
					type: 'billboard',
				},
				emitter: [{
					type: 'box',
					emission_rate: 50.0,
					position: [0, 0, 0],
					box_width: 32,
					box_height: 32,
					direction: [1, 0, 0],
					duration: 10,
					repeat_delay: { type: 'dyn_random', min: 1, max: 3.5 },
					time_to_live: 5,
					velocity: { type: 'dyn_random', min: 20, max: 30 },
					angle: { type: 'dyn_random', min: 0.0, max: 360.0 },
				}],

				//make the particles fade out over time.
				affector: [{
					type: 'color',
					time_colour: [{time: 0, color: [1, 1, 1, 1]}, {time: 1, color: [1, 1, 1, 0]}],
				}],
			}]
		})
	  ]",
	},

	object_type: [

		{
			id: "missile",
			animation: [
				{
					id: "normal",
					image: "missile.png",
					rect: [0,0,71,71],
					frames: 1,
					duration: 10,
					scale: 1,
				}
			],

			on_end_normal_anim: "die()"
		},

	],

	shader: {
		name: "creature_shader",
		vertex: "
        uniform mat4 u_anura_mvp_matrix;
		uniform float u_scale_x;
		uniform float u_scale_y;
		uniform vec4 u_anura_sprite_area;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
        varying vec2 v_texcoord;

		void main()
		{
            v_texcoord = a_anura_texcoord;

			if(u_scale_x != 1.0 || u_scale_y != 1.0) {
				vec4 vertex = a_anura_vertex;
				float x_center_delta = vertex[0] - (u_anura_sprite_area[0] + u_anura_sprite_area[2])/2.0;
				float y_center_delta = vertex[1] - (u_anura_sprite_area[1] + u_anura_sprite_area[3])/2.0;

				vertex[0] = (u_anura_sprite_area[0] + u_anura_sprite_area[2])/2.0 + x_center_delta*u_scale_x;
				vertex[1] = (u_anura_sprite_area[1] + u_anura_sprite_area[3])/2.0 + y_center_delta*u_scale_y;

            	gl_Position = u_anura_mvp_matrix * vertex;
			} else {
            	gl_Position = u_anura_mvp_matrix * a_anura_vertex;
			}
		}
		",

		fragment: "
		#version 120
		uniform sampler2D u_anura_tex_map;
		uniform sampler2D u_hud;
		uniform vec4 u_anura_sprite_area;
		uniform bool is_poisoned;
		uniform bool is_sleeping;
		uniform bool is_flashing;
		uniform float u_alpha;
		uniform float u_focus;
		uniform float u_hud_alpha;
		uniform float u_edge_fade;
		varying vec2 v_texcoord;
		void main()
		{
			vec2 center_sprite;
			center_sprite[0] = (u_anura_sprite_area[0] + u_anura_sprite_area[2]) * 0.5;
			center_sprite[1] = (u_anura_sprite_area[1] + u_anura_sprite_area[3]) * 0.5;
			gl_FragColor = texture2D(u_anura_tex_map, mix(v_texcoord, center_sprite, u_focus*0.2));
			gl_FragColor[3] = texture2D(u_anura_tex_map, v_texcoord)[3];
			float grayscale = (gl_FragColor[0] + gl_FragColor[1] + gl_FragColor[2])/3.0;
			gl_FragColor[0] = mix(grayscale, gl_FragColor[0], 0.8 + u_focus*0.2);
			gl_FragColor[1] = mix(grayscale, gl_FragColor[1], 0.8 + u_focus*0.2);
			gl_FragColor[2] = mix(grayscale, gl_FragColor[2], 0.8 + u_focus*0.2);
			gl_FragColor[3] *= u_alpha;

			if(is_sleeping) {
				gl_FragColor[0] = 1.0 - (1.0 - gl_FragColor[0])/2.0;
				gl_FragColor[2] = 1.0 - (1.0 - gl_FragColor[2])/2.0;
			}

			if(is_poisoned) {
				gl_FragColor[1] = 1.0 - (1.0 - gl_FragColor[1])/2.0;
			}

			vec4 col = texture2D(u_hud, v_texcoord);
			col[3] *= u_hud_alpha;
			gl_FragColor[0] = gl_FragColor[0]*(1.0-col[3]) + col[0]*col[3];
			gl_FragColor[1] = gl_FragColor[1]*(1.0-col[3]) + col[1]*col[3];
			gl_FragColor[2] = gl_FragColor[2]*(1.0-col[3]) + col[2]*col[3];

			if(is_flashing) {
				gl_FragColor[0] = gl_FragColor[1] = gl_FragColor[2] = 1.0;
			}

			if(u_edge_fade > 0.0) {
				float h_dist = abs(v_texcoord[0] - center_sprite[0])/(u_anura_sprite_area[2] - u_anura_sprite_area[0]);
				float v_dist = abs(v_texcoord[1] - center_sprite[1])/(u_anura_sprite_area[3] - u_anura_sprite_area[1]);

				float fade = 0.0;

				if(h_dist > 0.3) {
					fade += (h_dist - 0.3)*5.0;
				}

				if(v_dist > 0.3) {
					fade += (v_dist - 0.3)*5.0;
				}

				fade *= u_edge_fade;

				gl_FragColor[3] *= (1.0 - clamp(fade, 0, 1));
			}
		}
		",


		create: "[
			set(uniform_commands.u_hud, 1),
			set(uniform_commands.is_flashing, false),
		]",

		draw: "[
		  set(uniform_commands.u_scale_x, parent.scale_x),
		  set(uniform_commands.u_scale_y, parent.scale_y),
		  set(uniform_commands.u_hud_alpha, parent.hud_alpha),
		  set(uniform_commands.u_edge_fade, if(parent.size_override < 2.0, 0.0, parent.size_override - 2.0)),
		  if(tex, [
			set(uniform_commands.u_alpha, parent.alpha/255.0),
			set(textures, [tex]),
			set(tex.binding_point, 1),

			set(uniform_commands.u_focus, parent.mouseover_focus),

		]) where tex = parent.hud_texture
		]",
	},

	on_show_tooltip: "
		if(_is_preview = false and creature_object.base_card != null,
		[
			spawn('tip_dialog', mid_x + ctrl.px(220), mid_y, {
				zorder: lib.citadel.zorder('card_tips'),
				_title: creature_object.name,
				_tip: {
					key: 'tip',
					text: _tooltip_text,
					targets: [me],
				},

				_width: 240,
				_height: 220,
				_has_close: false,
				_delay_widgets: 20,
				alpha: 0,

			}, [
				ctrl.set_tooltip(child),
				animate(child, {
					alpha: 255,
				}, {
					duration: 20,
				}),
			]),

			spawn('card', mid_x - ctrl.px(220), mid_y, {
				zorder: lib.citadel.zorder('card_tips'),
				in_hand: false,
				card_size: 1.0,
				card_type: construct('card', creature_object.base_card),
				controller: ctrl,
			}, [
				ctrl.append_tooltip(child),
				animate(child, {
					alpha: 255,
				}, {
					duration: 20,
				}),
			]),
		]
		) where ctrl = obj citadel_controller <- arg.controller
	",

	effects: [{
		name: "particle1",
		zorder: 1,
		create: "[
			set(parent.texture, load_texture('images/red-cross.png')),
			set(uniforms.u_tex_map, 1),
			set(uniforms.u_color, [255,255,255,255]),
			set(draw_mode, 'points'),
			
			set(parent.regen_start_position, float_array(flatten(map(range(5), [1d70 - 35, 40 - 1d20])), 2)),
			set(parent.regen_attrib_cycle, float_array(flatten(map(range(5), 1d50)), 1)),
		]",
		
		draw: "[
			bind_texture(parent.texture, 1),
			
			set(uniforms.u_cycle, parent.cycle),
			set(uniforms.u_start_cycle, parent.regen_start_cycle),
			set(uniforms.u_end_cycle, parent.regen_end_cycle),
			set(uniforms.u_centre_position, [parent.mid_x, parent.mid_y]),
			set(attributes.a_position, parent.regen_start_position),
			set(attributes.a_start_cycle, parent.regen_attrib_cycle),
		]",
	}],
}
