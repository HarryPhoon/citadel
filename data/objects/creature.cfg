{
	is_strict: true,
	
 	"hitpoints": 1,
	"id": "creature",

	types: {
		ParticleEffectEntry: "{
			obj: [obj creature_particle_effect],
		}"
	},

	on_being_removed: "[
		map(particle_effects, value.fade_away_and_die()),
		remove_object(_land_flag),
		map(creature_effects, value.remove()),
	]",

	on_click: "if(option_index != null,
	    controller.option_clicked(option_index, option_index),
	    _is_preview = false, [
		if(controller.awaiting_input = false and /*arg.mouse_button = 3 and*/ creature_object and creature_object.is_on_board and creature_object.activated_abilities and creature_object.controller = controller.myplayer.player_index,
		[
			swallow_mouse_event(),
			controller.spawn_activated_ability_cards(me)
		],
		    controller.creature_clicked(me),
		),
	])",

	on_drag_start: "[
		controller.mouse_drag_creature_start(me),
		mouse_drag_start_handler(me),
	]",
	on_drag: "[
		controller.mouse_drag_creature(me),
		mouse_drag_handler(me),
	]",
	on_drag_end: "[
		controller.mouse_drag_creature_end(me),
		mouse_drag_end_handler(me),
	]",
	
	on_mouse_enter: "if(_is_preview = false, [
		set(has_mouseover, true),
		animate(me, { mouseover_focus: 1.0 }, { name: 'mouseover', duration: 25 }),
	])",
	
	on_mouse_move: "[

	]",

	on_mouse_leave: "if(_is_preview = false, [
		set(has_mouseover, false),
		animate(me, { mouseover_focus: 0.0 }, { name: 'mouseover', duration: 25 }),
		if(creature_object, set_gui_stats_alpha(creature_object.stats_alpha))
	])",

	on_process: "[

	  if(_in_move_animation or _in_summoning_animation or _in_attack_animation or animated_movements != [] and animated_movements != ['mouseover'],
		 [
		 if(_basexy != null and [mid_x,mid_y] != _basexy,
			animate(me, {
				mid_x: _basexy[0],
				mid_y: _basexy[1],
			}, {
				duration: 5,
			})
		 ),
		 set(_basexy, null), //pass on attack animation right now.
		 ],
	     creature_object.is_on_board and creature_moving = false and _has_unused_movement and controller.in_combat_animation = false,
	  [
	    //Code which handles creatures wanting to move in this block.
	    if(level.cycle%100 < 18, set(rotate, if(aggressive_anim, 1.0, 0.3)*10*sin((level.cycle%100)*40)), set(rotate, 0)),
		if(_basexy = null,
		[
		   set(_basexy, [mid_x, mid_y]),
		   set(_basez, zorder),
		   set(zorder, zorder+10),
		],
		   if(cycle_pos < 70, [
			set(mid_y, _basexy[1] + if(aggressive_anim, 1.0, 0.3)*sin(cycle_pos*360.0/70.0)*cycle_pos*0.5*direction_moving)
			  where direction_moving = if(game_state.nteam = creature_object.controller, 1, -1),
		   ], [
		   	set(mid_x, _basexy[0]),
		   	set(mid_y, _basexy[1]),
		   ]),
		) where cycle_pos = (level.cycle+50)%100 
	  ] where aggressive_anim = creature_object.targets_attacking(controller.state) != [],
	  [
	    if(_basexy != null, [
			set(mid_x, _basexy[0]),
			set(mid_y, _basexy[1]),
			set(zorder, int<- _basez),
			set(_basexy, null),
		]),
	  	set(rotate, 0),
	  ]
	  ),

		if(_animate_sizing and _current_sizing != null and (_animate_move_delay <= 0),
		[
			add(_current_sizing, sign(sizing - _current_sizing)*0.01),
			fire_event('render'),
		]),

		//animate captures (change of color) only when creatures have
		//finished moving.
		if(_animate_color and find(level.chars, value is obj creature and value.creature_moving) = null, [
			animate(me, {
				_current_bg_color: bg_color,
			}, {
				on_process: [fire_event('render'), set(me._animate_color, false)],
				duration: 25,
			}),
		]),

		if(_animate_move_delay > 0, add(_animate_move_delay, -1))]",
	
	on_destroy: "[remove_object(me)]",

	on_end_explosion_anim: "destroy()",

	on_type_updated: "fire_event('render')",

	on_render: "[
		set(_dirty, true),
	]",

	on_draw: "if(_dirty, [
		set(_dirty, false),
		if(hud_alpha > 0.0, set(hud_texture, render_hud(round_to_even(lib.hex.width_from_height(hex_height*sz)), round_to_even(hex_height*sz)))),
		set(animation, render_image(anim_w, anim_h))
		  where anim_w = round_to_even(lib.hex.width_from_height(hex_height*sz))
		  where anim_h = round_to_even(hex_height*sz),
		set(_current_bg_color, col),
		set(_animate_color, col != bg_color),
		set(_current_sizing, sz),
		set(_animate_sizing, sz != sizing and sz <= 1.0),

	] where sz = if(_current_sizing != null, _current_sizing, sizing)
	  where col = if(_current_bg_color != null, _current_bg_color, bg_color))",

	properties: {
		has_mouseover: { type: "bool", default: false },
		mouseover_focus: { type: "decimal", default: 0.0 },

		scale_x: { type: "decimal", default: 1.0 },
		scale_y: { type: "decimal", default: 1.0 },

		hud_alpha: { type: "decimal", default: 1.0 },

		mouse_drag_start_handler: { type: "function(obj creature) ->commands", init: "def(obj creature c)->commands null" },
		mouse_drag_handler: { type: "function(obj creature) ->commands", init: "def(obj creature c)->commands null" },
		mouse_drag_end_handler: { type: "function(obj creature) ->commands", init: "def(obj creature c)->commands null" },

		option_index: { type: "null|int" },

		play_sound: "def(string|null fname) ->commands
			if(_is_preview = false and fname != null, lib.citadel.play_sound(me, fname))
		",
	
		regen_start_position: { type: "null|object" },
		regen_attrib_cycle: { type: "null|object" },

		regen_start_cycle: { type: "int", default: 0 },
		regen_end_cycle: { type: "int", default: -1 },

		//this is just an avatar in the status bar and shouldn't show
		//on map etc.
		status_avatar: { type: "bool", default: false },

		furthest_animation_hint: { type: "int", default: 0 },
		texture: { type: "null|object" },

		hex_height: { type: "int" },

		_is_preview: { type: "bool", default: false },

		_animate_move_delay: { type: "int", default: 0 },
		_basexy: { type: "null|Loc" },
		_basez: { type: "null|int" },
		creature_moving: "bool :: level.cycle < _animating_until",
		_animating_until: { type: "null|int" },

		_has_unused_movement: "bool ::
		  game_state.current_player_turn_index = creature_object.controller and
		  creature_object.move > creature_object.spaces_moved_this_turn",

		controller: { type: "obj citadel_controller" },
		destroy: "def() ->commands execute(me, fire_event('destroy'))",
		
		set_gui_stats_alpha: "def(decimal alpha_value) ->commands
		  if(stats_grid, set(stats_grid.alpha, int(alpha_value))) where stats_grid = widget|null<- me.widgets.gui_stats_grid",

		hand_card_entered: "def() ->commands [
		]",

		play_animation_hint: "def(class creature obj, map hint) ->commands execute(me, if(not _is_preview, switch(hint.type,
		  'summoned', ; [
		    play_sound(obj.sound_summoned),
		  	set(me.alpha, 0),

			if(source_card, [
				set(mid_x, source_card.mid_x),
				set(mid_y, source_card.mid_y),
				source_card.morph_into_creature(me, lib.animation_timings.card_cast_movement_time),
				set(me.hud_alpha, 0.05),
				schedule(lib.animation_timings.card_cast_movement_time, animate(me, {
					hud_alpha: 1.0,
				}, {
					duration: lib.animation_timings.creature_hud_fade_time,
				})),
			]),

			animate(me, {
				mid_x: controller.get_tile_pos(target_loc)[0],
				alpha: 255,
			}, {
				easing: lib.math.linear,
				duration: lib.animation_timings.card_cast_movement_time,
				name: 'summoning',
			}) where target_loc = Loc<- hint.loc,

			animate(me, {
				mid_y: controller.get_tile_pos(target_loc)[1],
			}, {
				easing: lib.math.ease_in_cubic,
				duration: lib.animation_timings.card_cast_movement_time,
			}) where target_loc = Loc<- hint.loc,

			if(not _is_preview, controller.reserve_animation_time('summoning', lib.animation_timings.card_cast_movement_time + 2)),

		  ] where source_card = find(level.chars, _is_preview = false and value is obj card and value.stack_id is int and value.card_type.name = obj.card_name),
		  'regeneration', [
		    debug(['REGEN SOUND', obj.sound_regeneration]),
		    play_sound(obj.sound_regeneration),
		  	set(regen_start_cycle, cycle+10),
		  	set(regen_end_cycle, cycle+70),
		  ],
		  null)))",

		furthest_attack_id: { type: "int", default: -1 },

		play_attack_animation: "def(class creature new_creature) ->commands
		[
//		  play_sound(new_creature.sound_attack),
		  if(size(new_creature.attack_hint.attacks) = 1,
		     [
			  if(new_creature.range <= 1,
			     null,
				 execute(me, map(range(attack.damage),
				   [
				    schedule(controller.animation_move_time + 10 + (value*30)/attack.damage,
				     spawn('creature.missile', src_x, src_y, sign(dst_x - src_x),
					       [set(child.zorder, zorder+950),
						    set(child.velocity_x, ((dst_x - src_x)*100)/10)]))
					 ]
					 where src_x = calculate_x(new_creature.loc)
					 where src_y = calculate_y(new_creature.loc)
					 where dst_x = calculate_x(attack.target_loc)))),
				    controller.reserve_animation_time('creature_attack_anim', controller.animation_move_time + 20),

			  ]
			  where attack = new_creature.attack_hint.attacks[0]
		  )]
		",

		play_death_animation: "def(class creature new_creature) ->commands

		if(controller is obj citadel_controller and controller.time_to_resolve_card > 0,
		   schedule(controller.time_to_resolve_card, cmd),
		   cmd
		)
		
		where cmd = [
			if(new_creature.sound_death, lib.citadel.play_sound(me, new_creature.sound_death)),
			animate(me, {
				alpha: 0,
			}, {
				duration: 25,
				on_complete: me.destroy(),
			}),
			switch(new_creature.death_animation_hint,
			'explosion',
			[
			]),

		]",

		_extend_bloodcord: "def(obj player_avatar target) ->commands if(controller is obj citadel_controller, [
			lib.citadel.play_sound(me, 'gameplay/blood-altar-zap'),
			
			spawn('creature_particle_effect', mid_x, mid_y, {
				_creature: me,
				zorder: me.zorder+10000,
				mid_x: mid_x,
				mid_y: mid_y,
				alpha: 0,
			}, [
				child.bloodcord(target),

				animate(child, {
					alpha: 255,
				}, {
					name: 'bloodcord',
					duration: 20,
					replace_existing: false,
				}),
	
				animate(child, {
					alpha: 0,
				}, {
					name: 'bloodcord',
					duration: 20,
					replace_existing: false,
					on_complete: remove_object(child),
				}),
			]),

			schedule(20,
			   [
			   	target.flash_hit(),
			    controller.avatar_life[target.player_num].remove_modify_life(me),
			   ])
		])",
		 // where delta_y = int((target.mid_y - y)*0.1) + 1d(lib.citadel.px(50)) - 1d(lib.citadel.px(50))",

		play_endzone_animation: "def(int damage, null|int target_index=null, null|string anim_type=null) ->commands
		if(controller is obj citadel_controller,
	    if(animation_type = 'bloodcord', [
			add(zorder, 10000),

			bind_command(_extend_bloodcord, target_avatar),

			schedule(50, [
				add(zorder, -10000),
			]),
		],
		
		//normal player damage animation
		[
			lib.citadel.play_sound(me, creature_object.sound_breach),
			animate(me, { zorder: 20000, size_override: 1.5, hud_alpha: 0.0, mid_x: level_mid_x, mid_y: level_mid_y, image_zoom_override: 0.3 }, { name: 'endzone', duration: lib.animation_timings.creature_attack_player_zoom_time }),

			animate(me, { mid_x: target_x, mid_y: target_avatar.mid_y, scale_x: 0.9, scale_y: 1.1 }, {
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_windup_time,
				easing: def(decimal ratio)->decimal sin(ratio*90.0 - 180.0)*0.2,
			}),
			animate(me, { mid_x: target_x, mid_y: target_avatar.mid_y, scale_x: 1.2, scale_y: 0.8, image_zoom_override: 1.0 }, { name: 'endzone', duration: lib.animation_timings.creature_attack_player_lunge_time, easing: def(decimal ratio)->decimal ratio, on_complete: [
			  controller.screen_shake(min(20, damage*2), 30, 5),
			  target_avatar.flash_hit() ;
			  controller.avatar_life[target_avatar.player_num].remove_modify_life(me)

			] }),
			animate(me, {mid_x: level_mid_x, mid_y: level_mid_y, scale_x: 1.0, scale_y: 1.0 },{
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_moveback_time,
				easing: def(decimal ratio)->decimal ratio*0.2,
			}),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y }, {
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_withdraw_time,
				easing: def(decimal ratio)->decimal ratio*0.5,
			}),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y, alpha: 0, scale_x: 1.5, scale_y: 1.5 }, { name: 'endzone', duration: lib.animation_timings.creature_attack_player_fadeout_time, easing: def(decimal ratio)->decimal ratio, on_complete: remove_object(me) }),

		]) where target_x = if(target_avatar.mid_x > me.mid_x, target_avatar.x, target_avatar.x + target_avatar.img_w)
		  where target_y = level_mid_y
		  where target_avatar = find_or_die(level.chars, value is obj player_avatar and if(target_index = null, controller.state.team_index(creature_object.controller) != controller.state.team_index(value.player_num), target_index = controller.state.team_index(value.player_num)))
		  where level_mid_x = controller.level_width/2
		  where level_mid_y = controller.level_height/2
		  where animation_type = anim_type or creature_object.attack_player_anim
		 )
		  ",

		_display_life: { type: "int|null" },
		displayed_life: "int :: if(_display_life != null, _display_life, creature_object.net_life)",

		animate_movement: "def(Loc to, string anim_type) ->commands [
			if(anim_type = 'blink',
			[
			//spawn_particle_example(),
			blink_particles(),
			animate(me, {
				scale: 0,
			}, {
				duration: 10,
				name: 'blink',
			}),
			schedule(25, blink_particles_end()),
			schedule(25, animate(me, {
				scale: 1,
			}, {
				duration: 10,
				name: 'blink',
			})),
			schedule(10, animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 1,
				name: 'blink',
			}))
			]),
		
			if(anim_type = 'swap',
			[
			animate(me, {
				mid_x: end_x + controller.tile_width * if(end_y < mid_y, -1, 1),
				mid_y: (mid_y+end_y)/2,
			}, {
				duration: 25,
				name: 'swap',
			}),
			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 15,
				name: 'swap',
			})
			]),

			if(anim_type = 'move',
			[
			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: lib.animation_timings.creature_move_time,
				name: 'move',
			})
			]),
		]
		where end_x = calculate_x(to)
		where end_y = calculate_y(to)",

		color_adjust: {
			type: "[decimal,decimal,decimal,decimal]",
			default: [1.0,1.0,1.0,1.0],
			set: "if(value != _data, [
				set(_data, value),
				animate(me, {
					_color_adjust_anim: value,
				}, {
					duration: 20,
				})
			])",
		},

		_color_adjust_anim: {
			type: "[decimal,decimal,decimal,decimal]",
			default: [1.0,1.0,1.0,1.0],
			set: "if(value != _data, [
				set(shader.uniform_commands.u_color_adjust, value),
				set(_data, value),
			] asserting shader)",
		},

		_poisoned: {
			type: "bool",
			default: false,
			set: "if(value != _data, [
				set(_data, value),
				set(color_adjust, map(color_adjust, if(index = 1, if(context.value, 0.5, -0.5), 0.0) + value)),
			])",
		},

		creature_effects: {
			type: "[obj creature_effect]",
			default: [],
		},

		creature_object: {
		type: "class creature",
		set_type: "class creature",
		default: null,
		set: "
		  execute(me, if(status_avatar, set(_data, value),
		  [
		    set(attack_animation_priority, false),
			set(_poisoned, 'Poisoned' in value.status_effects),
		    set(me.attached_objects, []),
		    set(me.alpha, 255),
		    set(_data, value),

			set(me._display_life, value.net_life),

			[

			[effect.remove() | effect <- creature_effects, effect.type not in effect_tags],
			set(creature_effects, filter(creature_effects, value.type in effect_tags)),

			[
			spawn(effect, {
				mid_x: mid_x,
				mid_y: mid_y,
				zorder: zorder+10,
				creature: me,
				controller: controller
			}, [
				add(creature_effects, [obj creature_effect<- child])
			]
			) | effect <- effect_tags, effect not in map(creature_effects, value.type)
			],

			] where effect_tags = value.effect_tags,

			if(value.is_on_board,

			 [
			 	if(value.movement_log, controller.reserve_animation_time('creature_move', if(being_summoned, 30, 0) + 50*size(value.movement_log))),
				map(value.movement_log, [
				  debug(['ANIMATE MOVEMENT LOG: ', value]),
				  schedule(if(being_summoned, 30, 0) + 50*index, [
				  	set(mid_xy, [begin_x, begin_y]),
				  	bind_command(me.animate_movement, Loc<- value[1], string<- value[2])
				  ])
				] 
		             where begin_x = calculate_x(from)
		             where begin_y = calculate_y(from)
				  where from = Loc<- value[0]

			   ),

			   set(_animating_until, level.cycle + 50*size(value.movement_log)),

			   //is this needed anymore? the movement log should make sure of this.
			   //schedule(if(being_summoned, 30, 0) + 50*size(value.movement_log)+1, set(mid_xy, [target_x, target_y])),
			 (if(_data = null,
			     set(me.mid_xy, [target_x, target_y]),

				//_data != null meaning we're updating the object
				//rather than being a new object
			    [

				if(not value.movement_log, set(me.mid_xy, [target_x, target_y])),

				//spawn a life change label
				if(_display_life != null and _display_life != value.net_life,
				   spawn('label', mid_x, mid_y, {
						zorder: me.zorder+1000,
						_text: [str(value.net_life - _display_life)],
						red: if(_display_life > value.net_life, 255, 0),
						green: if(_display_life < value.net_life, 255, 0),
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ])),

					if(_data.net_life != value.net_life,
					[
		  			controller.reserve_animation_time('creature_life_change', controller.animation_move_time + 40),
					]) asserting shader,
				 ])
			   )
			 ] where being_summoned = find(value.animation_hints, value.type = 'summoned') != null
			   where target_x = calculate_x(value.loc)
			   where target_y = calculate_y(value.loc)
		   ), //end value.is_on_board
			if(value.is_on_board, set(me.zorder, (value.loc[0]+1)*10 + if(not value.is_construct, 100, 0))),


			if(_data != null and value.attack_hint and value.attack_hint.id > furthest_attack_id,
			[
			   me.play_attack_animation(value),
			   set(furthest_attack_id, value.attack_hint.id),
			]),

			if(not value.alive, me.play_death_animation(value)),

			[play_animation_hint(value, hint) |
			 hint <- value.animation_hints,
			 hint.hint_id > furthest_animation_hint],

			if(value.animation_hints, set(furthest_animation_hint, int<- value.animation_hints[size(value.animation_hints)-1].hint_id)),

			fire_event('render'),
			set_particle_effects(value.particle_effects),

			if(value.is_construct and value.controller != -1,

			if(_land_flag = null or _land_flag.is_enemy != is_enemy or capture_anim,
			spawn('creature_land_flag', 0, 0, {
				controller: controller,
				creature: me,
				is_enemy: value.controller != controller.state.nplayer,
				zorder: 0,
			}, [
				if(capture_anim != null,
					child.animate_flag_raise()
				),
				set(_land_flag, child),
			])) where is_enemy = value.controller != controller.state.nplayer
			   where capture_anim = find(value.animation_hints, value.hint_id > furthest_animation_hint and value.type = 'captured'),

			set(_land_flag, null),
			)
			]))"
	  },

	  calculate_x: "def(Loc loc) ->int controller.get_tile_pos(loc)[0]",
	  calculate_y: "def(Loc loc) ->int controller.get_tile_pos(loc)[1]",
	  
	  get_hit_animation: "def(int damage) ->commands execute(me, [
	    [set(c.attack_animation_priority, false) | c <- level.chars, c is obj creature],
		set(attack_animation_priority, true),
		set(shader.uniform_commands.is_flashing, true) asserting shader,
		schedule(3, set(shader.uniform_commands.is_flashing, false)) asserting shader,

		if(damage > 0, [
			set(_display_life, displayed_life - damage),
			set(_dirty, true),

			spawn('label', int(x + img_w*0.82), mid_y, {
						zorder: me.zorder+1000,
						_text: [str(damage)],
						red: 255,
						green: 0,
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ]),
		]),
	  ])",
	  
	  drain_animation: "def(int drain, obj creature target_creature) ->commands execute(me, [
		if(drain > 0, [
			lib.citadel.play_sound(me, 'gameplay/life-drain'),
			set(_display_life, displayed_life + drain),
			set(_dirty, true),

			spawn('label', int(x + img_w*0.82), mid_y, {
						zorder: me.zorder+1000,
						_text: [str(drain)],
						red: 0,
						green: 255,
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ]),

			map(range(60),
				spawn('game_icon', 0, 0, {
					size: lib.citadel.px(32),
					icon: 'drop.svg',
					blue: 0,
					green: 0,
					red: 128,
					alpha: 32 + 1d64,
					mid_x: target_creature.mid_x + 1d(lib.citadel.px(64)) - 1d(lib.citadel.px(64)),
					mid_y: target_creature.mid_y + 1d(lib.citadel.px(64)) - 1d(lib.citadel.px(64)),
					zorder: 2000,
				}, [
					animate(child, {
						mid_x: mid_x,
						mid_y: mid_y,
						alpha: 0,
					}, {
						duration: 20,
						on_complete: remove_object(child),
					}),
				]
				)
			)
		]),
	  ])",

	  spawn_attack_info_label: "def(string text) ->commands execute(me, [
			spawn('label', mid_x, mid_y, {
						zorder: me.zorder+1000,
						_text: [text],
						_font_size: lib.citadel.px(24),
						red: 255,
						green: 255,
						blue: 255,
				   }, [
				    schedule(50, remove_object(child))
				   ]),
	  ])",

	  combat_die_animation_priority: { type: "bool", default: false },

	  attack_animation_priority: { type: "bool", default: false },

	  _in_move_animation: "bool :: 'move' in animated_movements",
	  _in_summoning_animation: "bool :: 'summoning' in animated_movements",

	  _in_attack_animation: { type: "bool", default: false },
	  do_attack_animation: "def(class creature new_creature) ->commands
	  if(controller is obj citadel_controller,
	  execute(me, [
	    set(attack_animation_priority, false),
	  	set(furthest_attack_id, attack_hint.id),
		if(size(attack_hint.attacks) = 1, [
		   controller.reserve_animation_time('creature_attack_animation', lib.animation_timings.creature_attack_animation_total_time),

		   set(_in_attack_animation, true),

		   add(me.brightness, 50),
		   add(me.zorder, 100),

		   animate(me, {
			rotate: 0.0,
		   }, {
			name: 'straighten',
			duration: 5,
		   }),

		   if(('First Strike' in creature_object.abilities) and target_creature != null and ('First Strike' not in target_creature.creature_object.abilities),
			spawn_attack_info_label('First Strike!')
		   ),

		   if(creature_object.range = 0,
		   [
			   play_sound(creature_object.sound_attack),
			   animate(me, {
				 mid_x: target_x,
				 mid_y: target_y,
				 scale_y: 0.88,
				 scale_x: 1.08,
			   }, {
				 name: 'attack',
				 easing: def(decimal ratio)->decimal
				   sin(ratio*90.0 - 180.0)*0.2,
				 duration: lib.animation_timings.creature_attack_animation_windup_time,
			   }),

			   animate(me, {
				 rotate: 0.0,
				 scale_y: 0.85,
				 scale_x: 1.1,
			   }, {
				 name: 'attack',
				 duration: lib.animation_timings.creature_attack_animation_windup_time/2,
			   }),

			   animate(me, {
				 mid_x: target_x,
				 mid_y: target_y,
				 scale_y: 1.4,
				 scale_x: 0.6,
			   }, {
				 name: 'attack',
				 easing: def(decimal ratio)->decimal ratio*0.7,
				 on_complete: [
				 	controller.screen_shake(min(20, int(attack.damage*1.5)), 30, 5),
					if(target_creature, [
						target_creature.get_hit_animation(attack.damage),
						drain_animation(attack.drain, target_creature),
					]),
				 ],
				 duration: lib.animation_timings.creature_attack_animation_lunge_time,
				 replace_existing: false,
			   }),

			   animate(me, {
				 mid_x: mid_x,
				 mid_y: mid_y,
				 scale_y: 1.0,
				 scale_x: 1.0,
			   }, {
					 name: 'attack',
				 easing: def(decimal ratio)->decimal ratio*0.2,
				 duration: lib.animation_timings.creature_attack_animation_finish_time/5,
				 replace_existing: false,
			   }),

			   animate(me, {
				 mid_x: if(_basexy, _basexy[0], mid_x),
				 mid_y: if(_basexy, _basexy[1], mid_y),
				 scale_y: 1.0,
				 scale_x: 1.0,
			   }, {
				 name: 'attack',
				 replace_existing: false,
				 duration: (lib.animation_timings.creature_attack_animation_finish_time*4)/5,
				 on_complete: [set(_in_attack_animation, false), add(me.zorder, -100)],
			   }),
		   ],

		   //ranged attack
		   [
			    play_sound(creature_object.sound_attack),
		   		spawn('game_icon', 0, 0, {
					size: lib.citadel.px(48),
					icon: 'ranged-icon.svg',
					mid_x: mid_x,
					mid_y: mid_y,
					zorder: 2000,
				}, [
					animate(child, {
						mid_x: target_x,
						mid_y: target_y,
					}, {
						duration: 20,
						on_complete: [
							if(target_creature, [
								target_creature.get_hit_animation(attack.damage),
								drain_animation(attack.drain, target_creature),
							]),

							remove_object(child),
						]
					}),
				]
				),

				schedule(50, [set(_in_attack_animation, false), add(me.zorder, -100)])
		   ]),

		   schedule(50, add(me.brightness, -50)),

		] where target_x = calculate_x(attack.target_loc)
		  where target_y = calculate_y(attack.target_loc)
		  where target_creature = find(level.chars, value is obj creature and value.creature_object.summon_id = attack.target.summon_id)
		  where attack = attack_hint.attacks[0])
	  ])
	  	where attack_hint = class animation.attacks<- new_creature.attack_hint
	  )
	  ",

	  loc_on_screen: "def(Loc loc) ->Loc [loc[0], if(game_state.nteam = 0, (game_state.columns-1) - loc[1], loc[1])]",

	  game_state: { type: "class game" },

      _animate_sizing: { default: false },
	  _current_sizing: { type: "null|decimal" },

	  size_override: { variable: false, type: "decimal", get: "if(_current_sizing != null, _current_sizing, sizing)", set: "[set(_dirty, true), set(_current_sizing, value)]" },

	  sizing: "decimal :: 0.9",

	  bg_color: "[decimal,decimal,decimal] ::
			switch(creature_object.controller,
			       0, if(creature_object.is_construct, [0.53, 0.25, 0.31], [0.34, 0.12, 0.16]),
			       1, if(creature_object.is_construct, [0.31, 0.25, 0.53], [0.16, 0.12, 0.34]),
			       if(creature_object.is_construct, [0.7, 0.8, 0.7], [0.16, 0.12, 0.16]))
	  ",

	  _current_bg_color: { type: "null|[decimal,decimal,decimal]" },
	  _animate_color: { default: false },

	  _dirty: { default: true },

	  hud_texture: { type: "null|texture_object" },

	  image_zoom_override: { type: "decimal", default: 0.0, set: "[set(_data, value), set(_dirty, true)]" },

	  image_translate_x: { type: "decimal|null" },
	  image_translate_y: { type: "decimal|null" },
	  image_scale: { type: "decimal|null" },

	  calculate_image_translate_x: "decimal :: image_translate_x or ((adjustments['translate_x'] or 0.0) + (adjustments[if(is_friend,'translate_friend_x','translate_enemy_x')] or 0.0))
			where is_friend = (creature_object.controller = controller.state.nteam)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}",
	  calculate_image_translate_y: "decimal :: image_translate_y or ((adjustments['translate_y'] or 0.0) + (adjustments[if(is_friend,'translate_friend_y','translate_enemy_y')] or 0.0))
			where is_friend = (creature_object.controller = controller.state.nteam)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}",
	  calculate_image_scale: "decimal :: (image_scale or ((adjustments['scale'] or 1.0) * (adjustments[if(is_friend,'scale_friend','scale_enemy')] or 1.0)))
			where is_friend = (creature_object.controller = controller.state.nteam)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}",

	  render_image: "def(int w, int h) ->frame
		lib.citadel.render_frame(c, w, h,

		[
			outline(0, 0, w, h),

			c.clip(),

			c.new_path(),

			outline(0, 0, w, h),
			c.set_source_rgba(0,0,0,1),
			c.fill(),

			c.save(),

			[
				c.translate(-translate_x*w, -translate_y*h),
				c.scale((1.0/scaling)*decimal(w)/decimal(image_dim[0])),
				c.paint_image('images/portraits/card-size/' + portrait),

				c.save(),
				c.scale(-1.0, 1.0),
				c.paint_image('images/portraits/card-size/' + portrait),
				c.restore(),

				c.save(),
				c.scale(1.0, -1.0),
				c.paint_image('images/portraits/card-size/' + portrait),
				c.restore(),

				c.save(),
				c.translate(image_dim[0]*2, 0.0),
				c.scale(-1.0, 1.0),
				c.paint_image('images/portraits/card-size/' + portrait),
				c.restore(),

			]
			where translate_x = calculate_image_translate_x
			where translate_y = calculate_image_translate_y
			where scaling = calculate_image_scale
			where image_dim = c.image_dim('images/portraits/card-size/' + portrait),

			c.restore(),
		]

		)
		 where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent), hh*dir(0)),

			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1.0)),

			c.line_to(ww*dir(hex_indent), hh*dir(1)),

			c.restore(),
		]
		 where dir = def(decimal a) a
		 where hex_indent_inverse = 1.0 - hex_indent
		 where hex_indent = 0.25

		 where c = canvas()
		 where portrait = creature_object.calculate_portrait
		 where portrait_x_offset = creature_object.portrait_x_offset*scaling
		 where portrait_y_offset = creature_object.portrait_y_offset*scaling
		 where portrait_scale = creature_object.portrait_scale*scaling
		 where scaling = w/120.0
	  ",

	  render_hud: "def(int w, int h) ->texture_object
		c.render(w, h,

		[

			outline(0, 0, w, h),
			c.set_source_rgba(0, 0, 0, 1),
			c.set_line_width(lib.citadel.py(6)),
			c.stroke(),

			outline(w*0.02, h*0.02, w*0.96, h*0.96),
			c.clip(),
			c.new_path(),

			c.save(),

		] +

		if(creature_object.is_construct and creature_object.controller != -1, [
			outline(w*0.05, h*0.05, w*0.9, h*0.9),

			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 0.5), c.set_source_rgba(0, 0, 0, 1)),
			c.set_line_width(4),
			c.stroke(),
		], []) +

		if(creature_object.is_construct = false, [
			c.save(),

			if(creature_object.controller != ctrl.state.nteam, [
				c.translate(0, h),
				c.scale(1, -1),
			]),

			c.move_to(0, h),
			c.line_to(w*0.5, h*0.65),
			c.line_to(w, h),
			black_col,
			c.set_line_width(lib.citadel.py(6)),
			c.stroke(),

			c.move_to(w*0.5, h),
			c.line_to(0, h),
			c.line_to(w*0.5, h*0.65),
			white_col,
			c.fill(),

			c.move_to(w*0.5, h),
			c.line_to(w, h),
			c.line_to(w*0.5, h*0.65),
			c.set_source_rgba(0.50, 0.09, 0.12, 1.0),
			c.fill(),

			c.restore(),


			c.set_font(lib.font.regular_font),
			c.set_font_size(22*font_scaling),

			c.save(),
			black_col,
			c.translate(w*0.42 - attack_extents.width/2, h*if(is_enemy, 0.22, 0.922)),
			c.text_path(str(creature_object.attack)),
			c.fill(),
			c.restore(),

			c.save(),
			white_col,
			c.translate(w*0.60 - life_extents.width/2, h*if(is_enemy, 0.22, 0.92)),
			c.text_path(str(displayed_life)),
			c.fill(),
			c.restore(),
		] where attack_extents = c.text_extents(lib.font.regular_font, 24*font_scaling, str(creature_object.attack))
		  where life_extents = c.text_extents(lib.font.regular_font, 24*font_scaling, str(creature_object.net_life)),
		
		if(creature_object.energy > 0, [

			outline(w*0.72, h*0.37, w*0.25, h*0.25),
			if(creature_object.controller = ctrl.state.nteam, white_col, black_col),
			c.fill(),

			c.set_font(lib.font.regular_font),
			c.set_font_size(24*font_scaling),

			c.save(),
			c.translate(w*0.79, h*0.57),
			if(creature_object.controller = ctrl.state.nteam, black_col, white_col),
			c.text_path(str(creature_object.energy)),
			c.fill(),
			c.restore(),
		], [
		])) +

		if(doomed, [
			c.save(),

			c.translate(w*0.3, h*0.2),
			c.draw_svg(if(ascended, if(ctrl.state.trophies[(creature_object.controller+1)%2][creature_object.loc[0]] > 0, 'images/icons/breach-icon.svg', 'images/icons/breach-no-seal-icon.svg'), 'images/icons/death-icon.svg'), h/2, h/2),

			c.restore(),
			
		], []) +

		map(ability_info[:size(ability_draw_areas)],
		[

			c.save(),
			c.rectangle(0*w, draw_area.rect_offset*h, 1*w, 0.1*h),
			c.clip(),
			c.new_path(),

			outline(0.05*w, 0.05*h, 0.9*w, 0.9*h),
			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 1), c.set_source_rgba(0, 0, 0, 1)),
			c.fill(),

			c.restore(),

			c.save(),
			c.translate(0.5*w - text_area.width*0.5, (draw_area.rect_offset+0.09)*h),
			c.set_font(lib.font.regular_font),
			c.set_font_size(adjusted_font_size),
			c.text_path(value.text),
			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(0, 0, 0, 1), c.set_source_rgba(1, 1, 1, 1)),
			c.fill(),
			c.restore(),

			if(value.is_activated, [
				c.save(),
				outline(left_hex, top_hex, 0.1*w, 0.1*h) where left_hex = 0.5*w - text_area.width*0.5 - 0.1*w where top_hex = draw_area.rect_offset*h,
				if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(0, 0, 0, 1), c.set_source_rgba(1, 1, 1, 1)),
				c.fill(),
				c.restore(),

				c.save(),
				c.set_source_rgba(1, 1, 1, 1),
				c.translate(0.5*w - text_area.width*0.5 - 0.07*w, (draw_area.rect_offset+0.09)*h),
				if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 1), c.set_source_rgba(0, 0, 0, 1)),
				c.set_font(lib.font.regular_font),
				c.set_font_size(10*font_scaling),
				c.text_path(str(value.cost)),
				c.fill(),

				c.restore(),
			]),

		] 
		  where text_area = c.text_extents(lib.font.regular_font, adjusted_font_size, value.text)
		  where adjusted_font_size = if(text_area_base.width <= available_width, 12*font_scaling, 12*font_scaling*decimal(available_width)/decimal(text_area_base.width))
		  where text_area_base = c.text_extents(lib.font.regular_font, 12*font_scaling, value.text)
		  where available_width = w - w*abs(0.5 - draw_area.rect_offset)*1.2
		  where draw_area = ability_draw_areas[index])

		where ability_draw_areas = if(creature_object.controller = ctrl.state.nteam,
		[
			{
				rect_offset: 0.05,
			},
			{
				rect_offset: 0.2,
			},

			{
				rect_offset: 0.35,
			},
			{
				rect_offset: 0.5,
			},
		
		], [
			{
				rect_offset: 0.85,
			},
			{
				rect_offset: 0.7,
			},
			{
				rect_offset: 0.55,
			},
			{
				rect_offset: 0.4,
			}
		])

		where ability_info =
		if(creature_object.controller = -1, [],
		map(creature_object.abilities + creature_object.rules_short +
		    map(filter(creature_object.triggered_abilities, value.hidden_on_creature = false), value.summary) +
		    map(filter(creature_object.passive_abilities, value.hidden_on_creature = false), value.name) +
		 if(creature_object.is_construct, [],
		  if(creature_object.resistance = 0, [], [str(creature_object.resistance) + ' Armor']) +
		  if(creature_object.range = 0, [], [str(creature_object.range) + ' Range']) +
		  if(creature_object.is_building, ['Building'], [])),
		  {
			text: value,
			is_activated: false,
			cost: 0,
		}) +
		
		map(filter(creature_object.activated_abilities, if(value is class activated_ability, value.hidden_on_creature = false, true)), {
			text: value.name,
			is_activated: true,
			cost: value.cost,
		}))

		)
		 where is_enemy = creature_object.controller != ctrl.state.nteam
		 where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent), hh*dir(0)),

			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1.0)),

			c.line_to(ww*dir(hex_indent), hh*dir(1)),

			c.restore(),
		]

		 where outline_top = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.move_to(ww*dir(hex_indent), hh*dir(0)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.restore(),
		 ]

		 where outline_bot = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1)),
			c.restore(),
		 ]

		 where outline_portrait = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.3)),

			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.7)),

			c.restore(),
		 ]
		 where font_scaling = h/100.0
		 where hex_indent_inverse = 1.0 - hex_indent
		 where hex_indent = 0.25
		 where dir = if(direction_facing > 0, def(decimal a) a, def(decimal a) 1.0 - a)
		 where white_col = c.set_source_rgba(1, 1, 1, 1)
		 where black_col = c.set_source_rgba(0, 0, 0, 1)
		 where c = canvas()
		  where portrait = creature_object.calculate_portrait
		  where portrait_x_offset = creature_object.portrait_x_offset*scaling
		  where portrait_y_offset = creature_object.portrait_y_offset*scaling
		  where portrait_scale = creature_object.portrait_scale*scaling
		  where scaling = w/120.0
		  where direction_facing = if(ctrl != null and ctrl.state.nteam = 1, -1, 1) * creature_object.direction_moving
		  where ascended = ctrl.end_of_turn_state != null and doomed and find(ctrl.end_of_turn_state.endzoned_creatures, value = creature_object.summon_id) != null
		  where doomed = (_is_preview = false) and ctrl.end_of_turn_state != null and
		                (creature_object.is_construct = false and (future_me = null or future_me.controller != creature_object.controller)
		    where future_me = find(ctrl.end_of_turn_state.creatures, value.summon_id = creature_object.summon_id))
		  where ctrl = controller
	  ",

	  _tooltip_text: "string ::

		if(creature_object.is_building, 'Building', creature_object.is_construct, 'Land', 'Creature' + c.emdash + str(creature_object.attack) + ' Atk, ' + str(creature_object.net_life) + ' Life') + '\n' +


		if(creature.is_construct = false and creature_object.resistance > 0,
			'Armor' + c.emdash + str(creature_object.resistance) + '\n(The first ' + str(creature_object.resistance) + ' damage from any attack is prevented)\n', '') +

		if(creature.is_construct = false and creature.is_building = false and creature.move != 1,
			'Movement' + c.emdash + str(creature_object.move) + '\n(Moves ' + creature.move + ' tiles each turn)\n', '') +


		if(creature.is_construct = false and creature.range != 0,
			'Range' + c.emdash + str(creature_object.range) + if(creature_object.range = 1, '\n(Attacks adjacent enemies even if not engaged in melee combat)', '\n(Attacks enemies up to ' + str(creature.range) + ' tiles away)' + '\n'), ''
		) +

		if(creature.abilities, fold(map(creature.abilities,
			value + if(help_str = null, '', ' (' + str(help_str) + ')' + '\n') where help_str = help[value]
		), a+b), '') +

		if(creature.passive_abilities, fold(map(filter(creature.passive_abilities, value.hidden_on_creature = false),
		value.name + q( <font tag='circle' size='-4'>P</font> &emdash;) + value.rules
		), a+b), '') +

		if(creature.triggered_abilities, fold(map(filter(creature.triggered_abilities, value.hidden_on_creature = false),
		value.name + q( <font tag='circle' size='-4'>T</font> &emdash;) + value.rules
		), a+b), '') +

		creature.rules

		where creature = creature_object
		where help = lib.json.get_document_map('data/help-abilities.cfg')
		where c = canvas()
	  ",

	  _land_flag: { type: "null|obj creature_land_flag", set: "[
	    if(_data, _data.animate_flag_retraction()),
		set(_data, value)
		]"
	  },

	  particle_effects: { type: "[obj creature_particle_effect]", default: [] },
	  applied_particle_effects: { type: "{string ->ParticleEffectEntry}", default: {} },

	  set_particle_effects: "def([string] effects) ->commands
	  [
	  	map(applied_particle_effects, ; if(key not in effects, [remove_particle_effect(key), map(value.obj, value.fade_away_and_die()), set(applied_particle_effects, remove_from_map(applied_particle_effects, key))])),
		map(effects, ; add_particle_effect(value))
	  ]",

	  add_particle_effect: "def(string name) ->commands
	  if(_in_summoning_animation,
	     schedule(10, ; add_particle_effect(name)),
	  if((not applied_particle_effects[name]) and
		 find(level.chars, value is obj tile) != null, [
		set(applied_particle_effects[name], entry),
		switch(name,
			'dark_lane_influence', lane_influence_particles([0.40,0.50,0.35], entry),
			'light_lane_influence', lane_influence_particles([1,1,1], entry),
			'dark_adj_influence', adjacent_influence_particles([0.40,0.50,0.35], entry),
			'rampage', set(color_adjust, map(color_adjust, value*if(index = 0, 2.0, 1.0))),
			null
		)
	  ] where entry = {obj: []})
	  )
	  ",

	  remove_particle_effect: "def(string name) ->commands
	  switch(name,
		'rampage', set(color_adjust, map(color_adjust, value*if(index = 0, 0.5, 1.0))),
	  	null
	  )
	  ",

	  fireball_particles: "def() ->commands [
	  	spawn('creature_particle_effect', mid_x, mid_y, {
			_creature: me,
			zorder: me.zorder+1,
		}, [
			child.fireball()
		])
	  ]",

	  adjacent_influence_particles: "def([decimal,decimal,decimal] color, ParticleEffectEntry entry) ->commands [
	  map([{zorder: 1}, {zorder: 100}],
	  	spawn('creature_particle_effect', mid_x, mid_y, {
			_creature: me,
			zorder: me.zorder+value.zorder,
		}, [
			child.adjacent_influence_particles(color),
			add(entry.obj, [child]),
		])
	  ),
		]",

	  lane_influence_particles: "def([decimal,decimal,decimal] color, ParticleEffectEntry entry) ->commands [
	  map([{going_up: true, zorder: 1}, {going_up: false, zorder: 1}, {going_up: true, zorder: 100}, {going_up: false, zorder: 100}],
	  	spawn('creature_particle_effect', mid_x, mid_y, {
			_creature: me,
			zorder: me.zorder+value.zorder,
		}, [
			child.lane_influence_particles(value.going_up, color),
			add(entry.obj, [child]),
		])
	  ),
		]",

		blink_particles: "def() ->commands [
			set(me.particles,  lib.particles.create(me, {
				position: [0,0],
				particle_quota: 1000,
				texture: 'particles/flare-128x128.png',

					particle_width: 48,
					particle_height: 48,
					emitters: [{
						type: 'circle',
						position: [0, 0, 0],
						emission_rate: 700.0,
						circle_radius: 30,
						direction: [0, 1, 0],
						duration: 0.1,
						repeat_delay: 20,
						time_to_live: 1,
						velocity: 75,
						angle: { type: 'dyn_random', min: 0.0, max: 360.0 },
						color: [1, 1, 1, 1],
					}],
					affectors: [{
						type: 'color',
						time_colour: [{time: 0, color: [1, 1, 1, 1]}, {time: 1, color: [1, 1, 1, 0]}],
					}],
				}
				)
			),
			schedule(15, set(me.particles, null)),
		]",
	
		blink_particles_end: "def() ->commands [
			set(me.particles, {
				id: 'blinkparticles_end',
				camera: { name: 'psc_cam', type: 'orthogonal', ortho_window: [0,controller.level_width,0,controller.level_height] },
				scale_velocity: 1,
				technique: [{
					position: [mid_x,mid_y],
					ignore_global_model: true,
					visual_particle_quota: 1000,
					texture: 'particles/flare-128x128.png',
					blend: 'alpha_blend',
					depth_write: false,
					depth_check: false,
					default_particle_width: 48,
					default_particle_height: 48,
					renderer: {
						type: 'billboard',
					},
					emitter: [{
						type: 'circle',
						position: [0, 0, 0],
						emission_rate: 700.0,
						circle_radius: 50,
						direction: [0, -1, 0],
						duration: 0.1,
						repeat_delay: 20,
						time_to_live: 1,
						velocity: 75,
						angle: { type: 'dyn_random', min: 0.0, max: 180.0 },
						color: [1, 1, 1, 1],
					}],
					affector: [{
						type: 'color',
						time_colour: [{time: 0, color: [1, 1, 1, 1]}, {time: 1, color: [1, 1, 1, 0]}],
					}],
				}]
			}),
			schedule(15, set(me.particles, null)),
		]",
	
	
	  //an example of a particle effect.
	  spawn_particle_example: "def() ->commands [
	  	set(me.particles, {
			id: 'test',
			camera: { name: 'psc_cam', type: 'orthogonal', ortho_window: [0,controller.level_width,0,controller.level_height] },
			scale_velocity: 1,
			technique: [{
				position: [mid_x,mid_y],
				ignore_global_model: true,
				visual_particle_quota: 2000,
				texture: 'particles/flare-128x128.png',
				blend: ['src_alpha', 'one_minus_src_alpha'],
				depth_write: false,
				depth_check: false,
				default_particle_width: 32,
				default_particle_height: 32,
				renderer: {
					type: 'billboard',
				},
				emitter: [{
					type: 'box',
					emission_rate: 50.0,
					position: [0, 0, 0],
					box_width: 32,
					box_height: 32,
					direction: [1, 0, 0],
					duration: 10,
					repeat_delay: { type: 'dyn_random', min: 1, max: 3.5 },
					time_to_live: 5,
					velocity: { type: 'dyn_random', min: 20, max: 30 },
					angle: { type: 'dyn_random', min: 0.0, max: 360.0 },
				}],

				//make the particles fade out over time.
				affector: [{
					type: 'color',
					time_colour: [{time: 0, color: [1, 1, 1, 1]}, {time: 1, color: [1, 1, 1, 0]}],
				}],
			}]
		})
	  ]",
	},

	object_type: [

		{
			id: "missile",
			animation: [
				{
					id: "normal",
					image: "missile.png",
					rect: [0,0,71,71],
					frames: 1,
					duration: 10,
					scale: 1,
				}
			],

			on_end_normal_anim: "die()"
		},

	],

	shader: {
		name: "creature_shader",
		vertex: "
        uniform mat4 u_anura_mvp_matrix;
		uniform float u_scale_x;
		uniform float u_scale_y;
		uniform vec4 u_anura_sprite_area;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
        varying vec2 v_texcoord;

		void main()
		{
            v_texcoord = a_anura_texcoord;

			if(u_scale_x != 1.0 || u_scale_y != 1.0) {
				vec4 vertex = a_anura_vertex;
				float x_center_delta = vertex[0] - (u_anura_sprite_area[0] + u_anura_sprite_area[2])/2.0;
				float y_center_delta = vertex[1] - (u_anura_sprite_area[1] + u_anura_sprite_area[3])/2.0;

				vertex[0] = (u_anura_sprite_area[0] + u_anura_sprite_area[2])/2.0 + x_center_delta*u_scale_x;
				vertex[1] = (u_anura_sprite_area[1] + u_anura_sprite_area[3])/2.0 + y_center_delta*u_scale_y;

            	gl_Position = u_anura_mvp_matrix * vertex;
			} else {
            	gl_Position = u_anura_mvp_matrix * a_anura_vertex;
			}
		}
		",

		fragment: "
		#version 120
		uniform sampler2D u_anura_tex_map;
		uniform sampler2D u_hud;
		uniform vec4 u_anura_sprite_area;
		uniform vec4 u_color_adjust;
		uniform bool is_flashing;
		uniform float u_alpha;
		uniform float u_focus;
		uniform float u_hud_alpha;
		uniform float u_edge_fade;
		varying vec2 v_texcoord;
		void main()
		{
			vec2 center_sprite;
			center_sprite[0] = (u_anura_sprite_area[0] + u_anura_sprite_area[2]) * 0.5;
			center_sprite[1] = (u_anura_sprite_area[1] + u_anura_sprite_area[3]) * 0.5;
			gl_FragColor = texture2D(u_anura_tex_map, mix(v_texcoord, center_sprite, u_focus*0.2));
			gl_FragColor[3] = texture2D(u_anura_tex_map, v_texcoord)[3];
			float grayscale = (gl_FragColor[0] + gl_FragColor[1] + gl_FragColor[2])/3.0;
			gl_FragColor[0] = mix(grayscale, gl_FragColor[0], 0.8 + u_focus*0.2);
			gl_FragColor[1] = mix(grayscale, gl_FragColor[1], 0.8 + u_focus*0.2);
			gl_FragColor[2] = mix(grayscale, gl_FragColor[2], 0.8 + u_focus*0.2);
			gl_FragColor[3] *= u_alpha;

			gl_FragColor[0] = 1.0 - (1.0 - gl_FragColor[0])/u_color_adjust[0];
			gl_FragColor[1] = 1.0 - (1.0 - gl_FragColor[1])/u_color_adjust[1];
			gl_FragColor[2] = 1.0 - (1.0 - gl_FragColor[2])/u_color_adjust[2];
			gl_FragColor[3] = 1.0 - (1.0 - gl_FragColor[3])/u_color_adjust[3];

			vec4 col = texture2D(u_hud, v_texcoord);
			col[3] *= u_hud_alpha;
			gl_FragColor[0] = gl_FragColor[0]*(1.0-col[3]) + col[0]*col[3];
			gl_FragColor[1] = gl_FragColor[1]*(1.0-col[3]) + col[1]*col[3];
			gl_FragColor[2] = gl_FragColor[2]*(1.0-col[3]) + col[2]*col[3];

			if(is_flashing) {
				gl_FragColor[0] = gl_FragColor[1] = gl_FragColor[2] = 1.0;
			}

			if(u_edge_fade > 0.0) {
				float h_dist = abs(v_texcoord[0] - center_sprite[0])/(u_anura_sprite_area[2] - u_anura_sprite_area[0]);
				float v_dist = abs(v_texcoord[1] - center_sprite[1])/(u_anura_sprite_area[3] - u_anura_sprite_area[1]);

				float fade = 0.0;

				if(h_dist > 0.3) {
					fade += (h_dist - 0.3)*5.0;
				}

				if(v_dist > 0.3) {
					fade += (v_dist - 0.3)*5.0;
				}

				fade *= u_edge_fade;

				gl_FragColor[3] *= (1.0 - clamp(fade, 0, 1));
			}
		}
		",


		create: "[
			set(uniform_commands.u_color_adjust, [1.0,1.0,1.0,1.0]),
			set(uniform_commands.u_hud, 1),
			set(uniform_commands.is_flashing, false),
		]",

		draw: "[
		  set(uniform_commands.u_scale_x, parent.scale_x),
		  set(uniform_commands.u_scale_y, parent.scale_y),
		  set(uniform_commands.u_hud_alpha, parent.hud_alpha),
		  set(uniform_commands.u_edge_fade, if(parent.size_override < 2.0, 0.0, parent.size_override - 2.0)),
		  if(tex, [
			set(uniform_commands.u_alpha, parent.alpha/255.0),
			set(textures, [tex]),
			set(tex.binding_point, 1),

			set(uniform_commands.u_focus, parent.mouseover_focus),

		]) where tex = parent.hud_texture
		]",
	},

	on_show_tooltip: "
		if(_is_preview = false and creature_object.base_card != null,
		[
			spawn('card', mid_x, mid_y, {
				zorder: lib.citadel.zorder('card_tips'),
				in_hand: false,
				card_size: 0.75,
				alpha: 0,
				ignore_clicks: true,
				card_type: construct('card', creature_object.base_card),
				controller: ctrl,
			}, [
				ctrl.set_tooltip(child, me),
				animate(child, {
					alpha: 255,
					card_size: 2.0,
					mid_x_decimal: decimal(mid_x - lib.citadel.px(220)),
				}, {
					duration: 20,
				}),
			]),

		map(creature_object.rules_tips[:size(positions)],
			spawn('tip_dialog', {
				mid_x: positions[index][0],
				mid_y: positions[index][1],
				zorder: zorder+10000,
				_tip: {
					key: 'tip',
					text: value.text,
					targets: [me],
				},

				_title: value.title,
				_has_close: false,
				_width: lib.citadel.py(220),
				_height: lib.citadel.py(120),
			}, [
				ctrl.append_tooltip(child)
			])
		)

		where positions = [
			[x2 + lib.citadel.py(180), mid_y],
			[x2 + lib.citadel.py(180), mid_y - lib.citadel.py(140)],
			[x2 + lib.citadel.py(180), mid_y + lib.citadel.py(140)],
		]

		]
		) where ctrl = obj citadel_controller <- arg.controller
	",

	effects: [{
		name: "particle1",
		zorder: 1,
		create: "[
			set(parent.texture, load_texture('images/red-cross.png')),
			set(uniforms.u_tex_map, 1),
			set(uniforms.u_color, [255,255,255,255]),
			set(draw_mode, 'points'),
			
			set(parent.regen_start_position, float_array(flatten(map(range(5), [1d70 - 35, 40 - 1d20])), 2)),
			set(parent.regen_attrib_cycle, float_array(flatten(map(range(5), 1d50)), 1)),
		]",
		
		draw: "[
			bind_texture(parent.texture, 1),
			
			set(uniforms.u_cycle, parent.cycle),
			set(uniforms.u_start_cycle, parent.regen_start_cycle),
			set(uniforms.u_end_cycle, parent.regen_end_cycle),
			set(uniforms.u_centre_position, [parent.mid_x, parent.mid_y]),
			set(attributes.a_position, parent.regen_start_position),
			set(attributes.a_start_cycle, parent.regen_attrib_cycle),
		]",
	}],
}
