{
	id: "story_presentation_controller",
	is_strict: true,
	use_absolute_screen_coordinates: true,
	zorder: 10000,

	properties: {
		screen_width: "int :: level.dimensions[2] - level.dimensions[0]",
		screen_height: "int :: level.dimensions[3] - level.dimensions[1]",

		_prev_ctrl_keys: { type: "null|[string]" },

		_sequence: { type: "[class story_sequence]" },
		_index: { default: 0 },
		_current: "class story_sequence :: _sequence[_index]",

		_image: { type: "null|obj image_widget" },

		next_sequence: "def() ->commands
		if(not _shown_text, [
			set(_shown_text, true),
		], [
			set(_shown_text, false) ;
			if(_index+1 >= size(_sequence),
			   remove_object(me),
			[
				show_sequence(_sequence[_index+1]),
				add(_index, 1),
			])
		])",

		_transition: "def(null|obj image_widget old, obj image_widget new, class story_sequence seq) ->commands execute(me,

		switch(seq.transition,
		  'fade', [

		  	set(new.alpha, 0),
			animate(new, {
				alpha: 255,
			}, {
				name: 'transition',
				duration: 50,
				on_complete: remove_object(old),
				replace_existing: false,
			}),


			if(old != null,
			[
				schedule(50, remove_object(old)),
				add(old.zorder, -1),
			]
			)
		  ], // end fade.

		  'wave', [

		  	set(new.alpha, 0),
			set(new.wave, { intensity: 0.3, period: 10.0, offset: 0.0 }),
			animate(new, {
				alpha: 255,
				wave: { intensity: 0.0, period: 10.0, offset: 5.0 }
			}, {
				name: 'transition',
				duration: 50,
				on_complete: remove_object(old),
				replace_existing: false,
			}),

			if(old != null,
			[
				schedule(50, remove_object(old)),
				add(old.zorder, -1),
				set(old.wave, { intensity: 0.0, period: 10.0, offset: 0.0 }),
				animate(old, {
					wave: { intensity: 0.3, period: 10.0, offset: 5.0 }
				}, {
					duration: 50,
				}),
			]
			)
		  ],

		  //default case, just remove the old one.
		  remove_object(old)
		)
		)",

		_image_widget: { type: "null|obj image_widget" },

		show_sequence: "def(class story_sequence seq) ->commands execute(me, [
			[remove_object(c) | c <- spawned_children, c != _image_widget],

			show_text(seq.text),
			spawn('image_widget', 0, 0, {
				x: 0, y: 0,
				image: seq.image,
				image_area: if(seq.image_area != null,
				               seq.image_area,
							   [0,0,dim[0],dim[1]]
							   where dim = c.image_dim('images/' + seq.image)
							   where c = canvas()
							),
				draw_width: screen_width,
				draw_height: int(screen_height*0.82),
				zorder: zorder-1000,
				use_absolute_screen_coordinates: true,
			}, [
				set(me._image_widget, child),

				_transition(_image_widget, child, seq),

				if(seq.image_area_animate_to != null,
				[
					animate(child, {
						image_area_animated: seq.image_area_animate_to,
					}, {
						duration: seq.animate_duration,
						easing: seq.animate_easing,
						name: 'move',
						replace_existing: false,
					})
				]
				)
			]),

			spawn('button_controller', 0, 0, {
				x: screen_width - lib.citadel.px(200),
				y: screen_height - lib.citadel.px(120),
				zorder: zorder+10,
				text: 'Continue >>',
				on_click: me.next_sequence,
				button_width: lib.citadel.px(140),
				button_height: lib.citadel.px(60),
				_font_size: lib.citadel.px(22),
				use_absolute_screen_coordinates: true,
			}, [
			])
		])",

		_shown_text: { type: "bool", default: false },

		show_text: "def(string text, int progress=0) ->commands execute(me, [
			set(animation, lib.citadel.render_frame(c, screen_width, int(screen_height*0.2), [
				c.rectangle(0, 0, screen_width, int(screen_height*0.2)),
				c.set_source_rgba(0, 0, 0, 1),
				c.fill(),
				c.set_source_rgba(1, 1, 1, 1),
				c.translate(int(screen_width*0.2), int(screen_height*0.02)),
				map(fragments, if(percent_shown > begin_percent, [
					c.save(),

					if(percent_shown < end_percent,
					[
						c.rectangle(value.x, value.y, value.width*ratio, value.height),
						c.clip(),
					] where ratio = (percent_shown - begin_percent)/(end_percent - begin_percent)),
					value.path,
					c.fill(),
					c.restore(),
				])
				where end_percent = min(1.0, begin_percent + value.width/total_width)
				where begin_percent = sum(map(fragments[:index], value.width))/total_width
				
				
				)
			])),

			set(x, 0),
			set(y, screen_height - int(screen_height*0.2)),

			if(percent_shown < 1.0,
				schedule(1, bind_command(show_text, text, if(_shown_text, int(total_width)+1, progress + lib.citadel.px(6)))),
				set(_shown_text, true))
		])
		  where percent_shown = decimal(progress)/decimal(total_width)
		  where total_width = sum(map(fragments, value.width))
		  where fragments = c.markup_text(q(<font size=') + str(_font_size) + q('>) + text + q(</font>), int(screen_width*0.6))
		  where c = canvas()",

		_font_size: "int :: lib.citadel.px(22)",
	},

	on_create: "[
		[set(c.paused, true) | c <- level.chars, c != me],
		show_sequence(_sequence[_index]),
	]",
	on_being_removed: "[
		map(spawned_children, remove_object(value)),
		[set(c.paused, false) | c <- level.chars, c != me],
	]",

	on_process: "[
		if(_prev_ctrl_keys != null and size(_prev_ctrl_keys) < size(level.player.ctrl_keys),
			next_sequence()
		),
		set(me._prev_ctrl_keys, level.player.ctrl_keys),
	]",
}
