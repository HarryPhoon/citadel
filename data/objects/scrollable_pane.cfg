{
	id: "scrollable_pane",
	is_strict: true,
	hidden_in_game: true,
	zorder: 500,
	always_active: true,

	types: {
		Child: "{ obj: custom_obj, ypos: int, xpos: int|null }",
	},

	properties: {
		area_width: { type: "int" },
		area_height: { type: "int" },

		always_keep_children_in_level: { default: false },
		left_align: { type: "bool", default: true },

		elements: { type: "[Child]" },

		_scrollbar: "null|scroll_bar_widget<- widgets.scrollbar",
		current_position: "int :: if(_scrollbar != null, _scrollbar.position, 0)",

		recalculate: "def() ->commands execute(me, [
			if(bottom < area_height,
			   set_widgets([]),
			   set_widgets([{
				type: 'scrollbar',
				id: 'scrollbar',
				x: area_width - 18,
				y: 0,
				height: area_height,
				range: [bottom, area_height],
				position: current_position,
				on_scroll: def(obj scrollable_pane obj, int yscroll)->commands [
					obj.recalculate_elements(),
				],
			   }])
			);

			recalculate_elements(),
		]
			where bottom = int<- max(map(elements, value.ypos + value.obj.img_h)) or 0
		)
		",

		recalculate_elements: "def() ->commands execute(me, [
			map(elements,
			  if(in_window, [
				   debug(['WIDTH: ', value.obj.type, value.obj.x, value.obj.x2, value.obj.w, value.obj.img_w, if(_scrollbar = null, x + area_width, _scrollbar.x)]),
			       if(value.obj not in level.chars, add_object(value.obj)),
				   if(left_align,
					  set(value.obj.x, x),
					  set(value.obj.x2, x + if(_scrollbar = null, area_width, _scrollbar.x)),
				   ),

				   set(value.obj.y, y + value.ypos - current_position),

				   set(value.obj.zorder, zorder-1),

				   set(value.obj.clip_area, [x, y, area_width, area_height]),

			//	   if(clip_top = 0 and clip_bot = 0,
			//		  set(value.obj.cliparea, null),
			//		  set(value.obj.cliparea, ))
				 ] where clip_top = max(0, current_position - value.obj.y)
				   where clip_bot = max(0, value.ypos + value.obj.img_h - (current_position + area_height)), 
			     remove_object(value.obj)
				)
				where in_window = always_keep_children_in_level or
				                  (value.ypos < current_position + area_height and
				                   value.ypos + value.obj.img_h > current_position)
			)
		])
			where bottom = int<- max(map(elements, value.ypos + value.obj.img_h)) or 0
		",

		animate_element_movement_from_previous_position: "def([Child] old_elements, int duration) ->commands [
			map(elements, if(old_el != null and (value.obj in level.chars),
				set(value.obj.y, y + old_el.ypos - current_position);
				animate(value.obj, {
					y: y + value.ypos - current_position
				}, {
					duration: duration,
				})
			) where old_el = find(old_elements, value.obj = context.value.obj))
		]",
	},

	on_create: "recalculate()",

	on_being_removed: "map(elements, remove_object(value.obj))",
}
