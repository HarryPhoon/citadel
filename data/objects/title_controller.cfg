{
	id: "title_controller",
	prototype: ["matchmaking_base"],
	is_human: true,
	hitpoints: 20,
	editor_info: { category: "player" },
    hidden_in_game: true,

	is_strict: true,

	types: {

	},

	consts: {
		BUTTON_WIDTH: 220,
		BUTTON_HEIGHT: 35,
	},
	
    properties: {

	_debug_label_mouse_loc: { type: "bool", default: true },
	_debug_mouse_loc: { type: "null|obj label" },
	_debug_show_mouse_loc: "def() ->commands [
		remove_object(_debug_mouse_loc),
		spawn('label', 0, 0, {
			x: 10,
			y: 10,
			zorder: 20000,
			_font_size: 16,
			_text: ['(' + str(mouse_x) + ',' + str(mouse_y) + ')']
		}, [
			set(_debug_mouse_loc, child)
		]),
	]",

	mouse_x: "int<- ctrl_mice[0][0]",
	mouse_y: "int<- ctrl_mice[0][1]",

		adjustcards: "[
			map(level.chars, remove_object(value)),
			add_object(object_playable('card_adjustment_controller', 0, 0, 1, {_mm_client_state: _mm_client_state}))
		]",

		selected_deck_category: "string <- if(decks, lib.citadel.preferences.deck_category or 'starter', 'starter')",
		selected_deck: "string <-
		if(res in table, res, keys(table)[0])
		  where table = if(selected_deck_category = 'custom', decks, lib.json.get_document_map('data/starting-decks.cfg'))
		  where res = if(selected_deck_category = 'custom', lib.citadel.preferences.selected_custom_deck, lib.citadel.preferences.selected_starter_deck)",

        _internal_client: { type: "object|null", default: null },
		_concede_client: { type: "object|null" },
		_session_id: { type: "int", default: -1 },

		level_width: "int<- level.dimensions[2]",
		level_height: "int<- level.dimensions[3]",

		client_state: "class mm_client_state :: _mm_client_state",
		decks: "DeckMap :: account_info.decks",

		game_logo: { type: "null|obj game_icon" },
		game_title: { type: "null|obj label" },


		game_port: { type: "int|null" },
		game_session: { type: "int|null" },
		game_id: { type: "int|null" },
		num_users: { type: "int|null" },
		num_queued: { type: "int|null" },
		num_games: { type: "int|null" },

		//show a toast about a multiplayer game being available unless
		//we are already in the multiplayer lobby.
		should_notify_multiplayer_queue: "def() ->bool
			if(_screen_controller is obj title_multiplayer_controller, false, true)
		",

		users_online: { type: "[OnlineUser]", default: [] },
		game_servers: { type: "[GameServer]", default: [] },

		_default_section: { type: "int", default: 0 },

		_menu_item_selected: "def(int nitem) ->commands
		[
		switch(nitem,
			0, spawn('title_lobby_controller', 0, 0, {
				_mm_client_state: _mm_client_state,
			}, [
				set(me._screen_controller, child)
			]),
			1, set_campaign_controller(),

			2, spawn('title_multiplayer_controller', 0, 0, {
				_mm_client_state: _mm_client_state,
			}, [
				set(me._screen_controller, child)
			]),
			3, [
			[ remove_object(c) | c <- level.chars, c != me],
			set(me.draw_primitives, []),
			set(me.widgets, []),
			execute_instrumented(me, 'libctrl',
			spawn('library_controller', 0, 0, {
				_mm_client_state: _mm_client_state,
				deck_rules: construct('deck_rules'),
				title_controller: me,
				return_controller: custom_obj<- _screen_controller,
			}, [
				//remove_object(me),
				set(me._screen_controller, child)
			]))
			]
		)
		]",

		enter_single: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('single_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		enter_multi: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('multi_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		return_from_game: "def(bool result, null|class game state)->commands
		execute(me, [
			add_object(me),
			if(_screen_controller != null, add_object(_screen_controller)),
		])",

		enter_library: "def(custom_obj old_controller, null|string deck=null) ->commands
		execute(me,
			spawn('library_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
				_mm_client_state: _mm_client_state,
				deck_rules: construct('deck_rules'),
				_force_edit_deck: deck,
			}, [
				set(me._screen_controller, child),
				child.suspend_preloads(20),
			])
		)
		",

		enter_settings: "def(custom_obj old_controller) ->commands
		execute(me,
		[
			spawn('settings_screen', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child),
			])
		])
		",

		close_settings: "def() ->commands
		[
		]
		",

		force_campaign_world_map: { type: "bool", default: false },

		set_campaign_controller: "def(bool force_clear=false) ->commands
		if(force_campaign_world_map, [
			spawn('map_campaign_controller', 0, 0, {
				_mm_client_state: _mm_client_state
			}, [
				set(_screen_controller, child),
			]),

			set(force_campaign_world_map, false),
		],

		if((campaign_doc is map) and campaign_doc['campaign_type'],
		[
		   add_object(object_playable((string<- campaign_doc['campaign_type']) + '_campaign_controller', 0, 0, 1, {
			 _mm_client_state: _mm_client_state,
			 _title_controller: me,
		   }))
		],

		[
			set(_campaign_controller, ctrl),
			add_object(ctrl),
			if(ctrl != _screen_controller, [
				set(_screen_controller, ctrl),
			]),

			set(_screen_controller, ctrl),
		] where ctrl = if(_campaign_controller and force_clear = false,
		                  _campaign_controller,
						  object('campaign_controller', 0, 0, {
								 _mm_client_state: _mm_client_state,
						  }))
		 )
		  where campaign_doc = if(_mm_client_state.account_info.campaign_location is string, lib.json.get_document_map('data/' + _mm_client_state.account_info.campaign_location))
		)",

		_campaign_controller: { type: "null|obj campaign_controller" },

		_screen_controller: { type: "custom_obj|null" },
		set_screen_controller: "def(custom_obj obj) ->commands set(_screen_controller, obj)",

		_welcome_label: { type: "custom_obj|null" },
		_logout_label: { type: "custom_obj|null" },

		show_update_status: "def() ->commands [
			set(me.widgets, [
				{ x: 4, y: level_height - lib.citadel.px(124), type: 'label', id: 'module_update_status', size: lib.citadel.px(12), text: 'Argentum Age version ' + str(MODULE_VERSION), color: 'white' },
				{ x: 4, y: level_height - lib.citadel.px(110), type: 'label', id: 'module_update_status', size: lib.citadel.px(12), text: if(auto_update_status().attempt_module, if(auto_update_status().complete_module, 'Citadel up-to-date', if(err is string, 'Error updating Citadel: ' + err, 'Citadel update timed out') where err = auto_update_status().module_error), 'Not auto-updating Citadel'), color: 'white' },
				{ x: 4, y: level_height - lib.citadel.px(96), type: 'label', id: 'anura_update_status', size: lib.citadel.px(12), text: if(auto_update_status().attempt_anura, if(auto_update_status().complete_anura, 'Anura up-to-date', if(err is string, 'Error updating Anura: ' + err, 'Anura update timed out') where err = auto_update_status().anura_error), 'Not auto-updating Anura'), color: 'white' },
			]),
		]",

		_handle_logout: "def(obj combo_label label) ->commands [
			lib.citadel.write_cookie(null),
			teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0)),
		]",

		spawn_deck_summaries: "def() ->commands [
			[remove_object(c) | c <- level.chars, c is obj library_deck_summary],

			map(decks, spawn('library_deck_summary', 0, 0, {selected: index = if(selected_index >= 0, selected_index, 0), zorder: 500, deck_name: key, x2: level_width, y: lib.citadel.py(28 + 72 + 72*index), _mm: me}))
			    where selected_index = index(keys(decks), find(keys(decks), value = lib.citadel.preferences.selected_deck)),
		]",

		grant_cards: "def(string|null user_id=null) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', msg: { user: user_id or username, type: 'grant', sets: ['*'] } }))
		]",

		update_server: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', script: 'update' }))
		]",

		restart_server: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', script: 'restart', replace_process: true }))
		]",

		query_server_admin_progress: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', get_command_output: true }))
		]",

		delete_account: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'delete_account' }))
		]",

		reset_passwd: "def(string new_pass) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'reset_passwd', passwd: md5(new_pass) }))
		]",

		send_global_chat: "def(string msg) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'global_chat', message: msg }))
		]",

		send_cancel_matchmaking_request: "def() ->commands [
			tbs_send(object<- mm_client, { type: 'cancel_matchmake', user: _mm_client_state.username, }),
		]",

		send_matchmaking_request: "def(map game_type) ->commands [
			tbs_send(object<- mm_client, { type: 'matchmake', game_info: game_type, user: _mm_client_state.username, }),

		]",

		set_avatar: "def(string avatar) ->commands [
			tbs_send(object<- mm_client, { type: 'set_avatar', avatar: avatar, user: _mm_client_state.username }),
			set(account_info.avatar, avatar),
		]",

		set_campaign_location: "def(string campaign_location) ->commands [
			tbs_send(object<- mm_client, { type: 'set_campaign_location', campaign_location: campaign_location, user: _mm_client_state.username }),
		]",

		concede_game: "def(string host, int port, int session_id) ->commands
		execute(me, [
			tbs_send(client, { type: 'concede' }),
			set(_concede_client, client),
			debug(['send concede',host,port,session_id]),
		] where client = tbs_client(host, port, session_id))",

		join_game: "def(string host, int port, int|null session_id_override=null) ->commands execute(me, [
    		teleport('level1.cfg', '', 'fade',
  				object_playable('citadel_controller', 336, 372, 0, {
				game_server_address: host,
				game_server_port: port,
				session_id: if(session_id_override != null, session_id_override, _mm_client_state.session_id),
				selected_deck: me.selected_deck,
				selected_deck_category: me.selected_deck_category,
				game_created: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
			}))
		])",

		observe_game: "def(GameServer server) -> commands [
			teleport('level1.cfg', '', 'fade',
  				object_playable('citadel_controller', 336, 372, 0, {
				game_server_address: TBS_SERVER_ADDRESS,
				game_server_port: server.port,
				session_id: 1d1000000, //_mm_client_state.session_id,
				game_created: true,
				observer: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
			}))
		]",

		return_to_main: "def() ->commands [
			if(_logout_label and (_logout_label not in level.chars), add_object(_logout_label)),
			if(_welcome_label and (_welcome_label not in level.chars), add_object(_welcome_label)),
		]
		",

		transition_screen: "def(commands cmd, bool zoom_in=true) ->commands
		execute(me,
		[
			sound(s, lib.citadel.sound_volume(s)) where s = 'interface/whoosh.wav',
			spawn('zoom_effect_controller', 0, 0, {
				begin_zorder: -10,
				source_area: [0.0,0.0,1.0,1.0],
				dest_area: [0.0,0.0,1.0,1.0],
				flat_color_override: true,
				flat_color: [0.09,0.14,0.18,1.0],
			}, [
				animate(child, {
					dest_area: if(zoom_in, [-0.25,-0.25,1.25,1.25], [0.1,0.1,0.9,0.9]),
					effect_alpha: 0.0,
				}, {
					duration: 20,
					on_complete: ; [
						[ remove_object(c) | c <- level.chars, c not in [me] ],
						cmd,

						spawn('zoom_effect_controller', 0, 0, {
							begin_zorder: -10,
							source_area: [0.0,0.0,1.0,1.0],
							dest_area: if(zoom_in, [0.1,0.1,0.9,0.9], [-0.25,-0.25,1.25,1.25]),
							effect_alpha: 0.0,
							flat_color_override: true,
							flat_color: [0.09,0.14,0.18,1.0],
						}, [
							animate(child, {
								dest_area: [0.0,0.0,1.0,1.0],
								effect_alpha: 1.0,
							}, {
								duration: 20,
								on_complete: remove_object(child)
							})
						]),
					]
				})
			]),
		]
		)
		",
    },
      
    on_create: "[
		set_user_info('user', _mm_client_state.username),

		set(x, 0),
		set(y, 0),

		spawn('combo_label', 0, 0, {
			x2: level_width - lib.citadel.py(2),
			y: lib.citadel.py(32),
			_text: 'LOGOUT',
			_font_size: lib.citadel.py(14),
			_halign: 'right',
			grouping: 'logout',
			selected: false,
			index: 0,
			click_handler: me._handle_logout,
			zorder: 20000,
		}, [
			set(_logout_label, child),
		]),

		spawn('label', 0, 0, {
			x2: level_width - lib.citadel.py(12),
			y: lib.citadel.py(0),
			_halign: 'right',
			_text: ['Welcome, ' + str(_mm_client_state.username)],
			_font_size: lib.citadel.py(14),
		}, [
			set(_welcome_label, child),
		]),

		fire_event('window_resize_custom', {width: level.camera_position[2], height: level.camera_position[3]}),

		if(MODULE_OPTIONS.campaign = null,
		   spawn('title_screen_controller', 0, 0, {
				title_controller: me,
		   }, [
		  		set(me._screen_controller, child),
		   ]), //FIXME: spawn object here.
		   bind_command(me.set_campaign_controller)
		),


	] where user_decks = account_info.decks",

	on_being_added: "return_to_main()",

	on_spawn_objects: "[
//		spawn_deck_summaries(),
	]",
	
	on_window_resize_custom: "[
		lib.citadel.set_screen_dim(width, height),

		set(level.dimensions, [0,0,width,height]),
		fire_event('spawn_objects'),
		if(_screen_controller, fire_event(_screen_controller, 'window_resize_custom', {height: height, width: width})),
	]
	  where width = int <- arg.width, height = int <- arg.height",
	
	on_type_updated: "fire_event('spawn_objects')",
	
	on_process: "[
		if(_debug_label_mouse_loc, _debug_show_mouse_loc()),

		if(me._internal_client, tbs_process(me._internal_client)),
		if(_concede_client, [tbs_process(_concede_client), if(_concede_client.in_flight = 0, set(_concede_client, null))])
	]",

    on_connection_error: "teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0))",
    
	on_connection_success: "null",

	on_matchmake_message_received: "[
	//debug(['MATCHMAKE:', message.type, message]),
	matchmaking_handle_message(message),
	switch(message.type,
		'matchmaking_queued', [
			debug('queued matchmaking'),
		],

		'match_made', join_game(if(message.host, string<- message.host, TBS_SERVER_ADDRESS), if(message.port, int<- message.port, TBS_SERVER_PORT)),

		'heartbeat', [
			set(game_port, int|null<- message.game_port),
			set(game_session, int|null<- message.game_session),
			set(game_id, int|null<- message.game_id),
			set(num_users, int<- message.users),
			set(num_queued, int<- message.users_queued),
			set(num_games, int<- message.games),
			set(users_online, [OnlineUser]<- message.user_list),
			set(game_servers, [GameServer]<- message.servers),

			if(message.chat_messages != null,
			  if(mp_controller,
				[
					mp_controller.receive_chat_messages([{message: string, nick: string}]<- message.chat_messages)
				]
			  ) where mp_controller = find(level.chars, value is obj multi_lobby_controller)
			)
		],

		'admin_busy', [
			if(_screen_controller is obj title_lobby_controller,
			   _screen_controller.set_server_text(['Server busy'])),
		],
		'admin_message', [
			if(_screen_controller is obj title_lobby_controller,
			   _screen_controller.admin_message(string<- message.message, null|bool<- message.complete))
		],
	)
	] where message = map<- arg.message",
	
	on_message_received: "[
	 debug('message: ' + str(message.type)),
	switch(message.type,
		'game_created', 
		[
		teleport('level1.cfg', '', 'fade', playable)
		]
		   where playable = object_playable('citadel_controller', 336, 372, 0,
		   {
			_mm_client_state: _mm_client_state,
			game_server_address: '',
			game_server_port: 23456,
			session_id: me._session_id,
			game_created: true,
			selected_deck: me.selected_deck,
			selected_deck_category: me.selected_deck_category,
			return_callback: me.return_from_game,
			}
		   ),
		'server_info',
		[],
		'heartbeat', [
		],

		debug('UNKNOWN MESSAGE RECIEVED: ' + str(message.type))
	) asserting message.type != 'error']
	  where message = map<- arg.message",
	
	on_do_deckbuilder: "teleport('deck-builder.cfg', '', 'fade', playable) 
		where playable = object_playable('library_controller', 0, 0, 0,{
			_mm_client_state: _mm_client_state,
			deck_rules: construct('deck_rules'),
			title_controller: me,
			return_controller: custom_obj<- _screen_controller,
		})
	",

	on_do_observe: "teleport('observation_lobby.cfg', '', 'fade', playable)
	    where playable = object_playable('observation_lobby_controller', 0, 0, 0, { client: tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT) })",
	
	on_do_mp_lobby: "teleport('matchmaking_lobby.cfg', '', 'fade', playable)
		where playable = object_playable('matchmaking_lobby_controller', 0, 0, 0, { _mm_client_state: _mm_client_state, selected_deck: selected_deck })
	",
	
	on_enter_level: "[
		fire_event('window_resize_custom', {width: level.camera_position[2], height: level.camera_position[3]}),
	] where user_decks = account_info.decks",

}
