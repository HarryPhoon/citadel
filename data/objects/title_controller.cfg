{
	id: "title_controller",
	prototype: ["matchmaking_base"],
	is_human: true,
	hitpoints: 20,
	editor_info: { category: "player" },
    hidden_in_game: true,

	is_strict: true,

	types: {

	},

	consts: {
		BUTTON_WIDTH: 220,
		BUTTON_HEIGHT: 35,
	},
	
    properties: {

	_request_server_info: "bool :: true",

	blankscreen: "def() ->commands
		[remove_object(c) | c <- level.chars, c != me]
	",

	show_reconnection_dialog: "def(int game_port, int game_id, int game_session) ->commands
	execute(me,
	[
		object('modal_message_dialog', {
			message: 'You disconnected from a game. Do you want to reconnect?',
			buttons: [{
				text: 'Reconnect',
				callback: (def() ->commands join_game(string<- TBS_SERVER_ADDRESS, game_port, game_session)),
			}, {
				text: 'Abandon',
				callback: (def() ->commands concede_game(string<- TBS_SERVER_ADDRESS, game_port, game_session)),
			}
			]
		}).show_dialog()
	])",

	recent_games: { type: "list", default: [] },

	show_recent_games: "def() ->commands
	execute(me,
		tbs_send(object<- mm_client, { type: 'get_recent_games', user: username });
		spawn('recent_games_dialog', {
			mid_x: level_width/2,
			mid_y: level_height/2,
			controller: me,
		}, [
		])
	)
	",

	_debug_label_mouse_loc: { type: "bool", default: false },
	_debug_mouse_loc: { type: "null|obj label" },
	_debug_show_mouse_loc: "def() ->commands [
		remove_object(_debug_mouse_loc),
		spawn('label', 0, 0, {
			x: lib.citadel.px(1370),
			y: 0,
			zorder: 20000,
			_font_size: 16,
			_text: ['(' + str(mouse_x) + ',' + str(mouse_y) + ')']
		}, [
			set(_debug_mouse_loc, child)
		]),
	]",

	mouse_x: "int<- ctrl_mice[0][0]",
	mouse_y: "int<- ctrl_mice[0][1]",

		adjustcards: "[
			map(level.chars, remove_object(value)),
			add_object(object_playable('card_adjustment_controller', 0, 0, 1, {_mm_client_state: _mm_client_state}))
		]",

		selected_deck_category: "string <- if(decks, lib.citadel.preferences.deck_category or 'starter', 'starter')",
		selected_deck: "string <-
		if(res in table, res, keys(table)[0])
		  where table = if(selected_deck_category = 'custom', decks, lib.json.get_document_map('data/starting-decks.cfg'))
		  where res = if(selected_deck_category = 'custom', lib.citadel.preferences.selected_custom_deck, lib.citadel.preferences.selected_starter_deck)",

        _internal_client: { type: "object|null", default: null },
		_concede_client: { type: "object|null" },
		_session_id: { type: "int", default: -1 },

		level_width: "int<- level.dimensions[2]",
		level_height: "int<- level.dimensions[3]",

		client_state: "class mm_client_state :: _mm_client_state",
		decks: "DeckMap :: account_info.decks",

		game_logo: { type: "null|obj game_icon" },
		game_title: { type: "null|obj label" },
		server_status_label: { type: "null|obj label" },

		update_server_status_label: "def() ->commands
		if(server_status_label != null,
			if(txt != server_status_label.get_text(), server_status_label.set_text(txt))
		where txt = if(num_users is int, [str(num_users) + 'players online | ' + str(num_games) + ' games being played'], ['Getting server status...'])
		)
		",

		game_port: { type: "int|null" },
		game_session: { type: "int|null" },
		game_id: { type: "int|null" },

		num_users: "int|null :: _mm_client_state.num_users",
		num_queued: "int|null :: _mm_client_state.num_queued",
		num_games: "int|null :: _mm_client_state.num_games",

		//show a toast about a multiplayer game being available unless
		//we are already in the multiplayer lobby.
		should_notify_multiplayer_queue: "def() ->bool
			if(_screen_controller is obj title_multiplayer_controller, false, true)
		",

		users_online_update: "int :: _mm_client_state.users_online_update",
		users_online: "[OnlineUser] :: _mm_client_state.users_online",
		game_servers: "[GameServer] :: _mm_client_state.game_servers",

		_default_section: { type: "int", default: 0 },

		_menu_item_selected: "def(int nitem) ->commands
		[
		switch(nitem,
			0, spawn('title_lobby_controller', 0, 0, {
				_mm_client_state: _mm_client_state,
			}, [
				set(me._screen_controller, child)
			]),
			1, set_campaign_controller(),

			2, spawn('title_multiplayer_controller', 0, 0, {
				_mm_client_state: _mm_client_state,
			}, [
				set(me._screen_controller, child)
			]),
			3, [
			[ remove_object(c) | c <- level.chars],
			execute_instrumented(me, 'libctrl',
			add_object(
			object_playable('library_controller', 0, 0, 1, {
				_mm_client_state: _mm_client_state,
				deck_rules: construct('deck_rules'),
				title_controller: me,
				return_controller: custom_obj<- _screen_controller,
			}
			))
			)
			]
		)
		]",


		enter_tutorial: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('tutorial_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		enter_puzzles: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('puzzle_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		enter_single: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('single_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		in_multi_lobby: "bool :: _screen_controller is obj multi_lobby_controller",

		enter_multi: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('multi_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		watch_replay: "def(string game_id) ->commands
		execute(me,	
			tbs_send(object<- mm_client, { type: 'get_replay', id: game_id })
		)
		",

		start_replay: "def(map replay) ->commands
			enter_game(
  				object_playable('citadel_controller', 336, 372, 0, {
				observer: true,
				game_created: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
				_replay: replay,
				respond_to_challenge: me.return_from_game_to_challenge,
			}))
		",

		return_from_game: "def(bool result, null|class game state)->commands
		execute(me, [
			add_object(me),
			(set(level.frame_buffer_shaders, []); lib.citadel.add_main_background_shader(level)),
			if(_screen_controller != null, add_object(_screen_controller)),
		];
		show_ui())",

		return_from_game_to_challenge: "def() ->commands
			return_from_game(false, null)
		",

		enter_library: "def(custom_obj old_controller, null|string deck=null) ->commands
		execute(me, [
			remove_object(me),
			add_object(library),
			library.suspend_preloads(20),
		  ]
		  where library = object_playable('library_controller', 0, 0, 1, {
				title_controller: me,
				return_controller: old_controller,
				_mm_client_state: _mm_client_state,
				deck_rules: construct('deck_rules'),
				_force_edit_deck: deck,
			}
			)
		)
		",

		enter_settings: "def() ->commands
		execute(me,
		[
			spawn('settings_screen', 0, 0, {
				title_controller: me,
			}, [
				set(me._screen_controller, child),
			])
		])
		",

		close_settings: "def() ->commands
		[
		]
		",

		force_campaign_world_map: { type: "bool", default: false },

		set_campaign_controller: "def(bool force_clear=false) ->commands
		if(force_campaign_world_map, [
			spawn('map_campaign_controller', 0, 0, {
				_mm_client_state: _mm_client_state
			}, [
				set(_screen_controller, child),
			]),

			set(force_campaign_world_map, false),
		],

		if((campaign_doc is map) and campaign_doc['campaign_type'],
		[
		   add_object(object_playable((string<- campaign_doc['campaign_type']) + '_campaign_controller', 0, 0, 1, {
			 _mm_client_state: _mm_client_state,
			 _title_controller: me,
		   }))
		],

		[
			set(_campaign_controller, ctrl),
			add_object(ctrl),
			if(ctrl != _screen_controller, [
				set(_screen_controller, ctrl),
			]),

			set(_screen_controller, ctrl),
		] where ctrl = if(_campaign_controller and force_clear = false,
		                  _campaign_controller,
						  object('campaign_controller', 0, 0, {
								 _mm_client_state: _mm_client_state,
						  }))
		 )
		  where campaign_doc = if(_mm_client_state.account_info.campaign_location is string, lib.json.get_document_map('data/' + _mm_client_state.account_info.campaign_location))
		)",

		_campaign_controller: { type: "null|obj campaign_controller" },

		_screen_controller: { type: "custom_obj|null" },
		set_screen_controller: "def(custom_obj obj) ->commands set(_screen_controller, obj)",
		get_screen_controller: "custom_obj|null :: _screen_controller",

		_welcome_label: { type: "custom_obj|null" },
		_logout_label: { type: "custom_obj|null" },

		show_update_status: "def() ->commands [
			set(me.widgets, [
				{ x: 4, y: level_height - lib.citadel.px(124), type: 'label', id: 'module_update_status', size: lib.citadel.px(12), text: 'Argentum Age version ' + str(MODULE_VERSION), color: 'white' },
				{ x: 4, y: level_height - lib.citadel.px(110), type: 'label', id: 'module_update_status', size: lib.citadel.px(12), text: if(auto_update_status().attempt_module, if(auto_update_status().complete_module, 'Citadel up-to-date', if(err = 'no_newer_module', 'Argentum Age up to date', err is string, 'Error updating Citadel: ' + err, 'Citadel update timed out') where err = auto_update_status().module_error), 'Not auto-updating Citadel'), color: 'white' },
				{ x: 4, y: level_height - lib.citadel.px(96), type: 'label', id: 'anura_update_status', size: lib.citadel.px(12), text: if(auto_update_status().attempt_anura, if(auto_update_status().complete_anura, 'Anura up-to-date', if(err = 'no_newer_module', 'Anura up to date', err is string, 'Error updating Anura: ' + err, 'Anura update timed out') where err = auto_update_status().anura_error), 'Not auto-updating Anura'), color: 'white' },
			]),
		]",

		_logging_out: { type: "bool", default: false },

		_handle_logout: "def() ->commands execute(me, [
			tbs_send(object<- mm_client, { type: 'quit_game' }),
			set(_logging_out, true),
			lib.citadel.write_cookie(null),
			schedule(180, teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0))),
		])",

		spawn_deck_summaries: "def() ->commands [
			[remove_object(c) | c <- level.chars, c is obj library_deck_summary],

			map(decks, spawn('library_deck_summary', 0, 0, {selected: index = if(selected_index >= 0, selected_index, 0), zorder: 500, deck_name: key, x2: level_width, y: lib.citadel.py(28 + 72 + 72*index), _mm: me}))
			    where selected_index = index(keys(decks), find(keys(decks), value = lib.citadel.preferences.selected_deck)),
		]",

		grant_cards: "def(string|null user_id=null) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', msg: { user: user_id or username, type: 'grant', sets: ['*'] } }))
		]",

		update_server: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', script: 'update' })),
			set(_server_output_pending, true),
			query_server_admin_progress(),
		]",

		restart_server: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', script: 'restart', replace_process: true }))
		]",

		_server_output_pending: { type: "bool", default: false },

		query_server_admin_progress: "def() ->commands ; if(_server_output_pending,[
			execute(me, tbs_send(object<- mm_client, { type: 'admin_operation', get_command_output: true })),
			schedule(60, query_server_admin_progress())
		])",

		delete_account: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'delete_account' }))
		]",

		reset_passwd: "def(string new_pass) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'reset_passwd', passwd: md5(new_pass) }))
		]",

		send_global_chat: "def(string msg) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'global_chat', message: msg }))
		]",

		send_cancel_matchmaking_request: "def() ->commands [
			tbs_send(object<- mm_client, { type: 'cancel_matchmake', user: _mm_client_state.username, }),
		]",

		send_matchmaking_request: "def(map game_type) ->commands [
			tbs_send(object<- mm_client, { type: 'matchmake', game_info: game_type, user: _mm_client_state.username, }),

		]",

		set_avatar: "def(string avatar) ->commands [
			tbs_send(object<- mm_client, { type: 'set_avatar', avatar: avatar, user: _mm_client_state.username }),
			set(account_info.avatar, avatar),
		]",

		set_campaign_location: "def(string campaign_location) ->commands [
			tbs_send(object<- mm_client, { type: 'set_campaign_location', campaign_location: campaign_location, user: _mm_client_state.username }),
		]",

		issue_challenge: "def(string user) ->commands [
			tbs_send(object<- mm_client, { type: 'challenge', user: user }),
		]",

		concede_game: "def(string host, int port, int session_id) ->commands
		execute(me, [
			tbs_send(client, { type: 'concede' }),
			set(_concede_client, client),
			debug(['send concede',host,port,session_id]),
		] where client = tbs_client(host, port, session_id))",

		enter_game: "def(obj citadel_controller playable) ->commands
		execute(me,
			transition_screen(
			[
				set(me._queued_for_battle, false),
				map(level.chars, remove_object(value)),
				add_object(playable),
			], true, false)
		)
		",

		join_game: "def(string host, int port, int|null session_id_override=null) ->commands execute(me, [
			enter_game(playable)
  			where playable = object_playable('citadel_controller', 336, 372, 0, {
				game_server_address: host,
				game_server_port: port,
				session_id: if(session_id_override != null, session_id_override, _mm_client_state.session_id),
				selected_deck: me.selected_deck,
				selected_deck_category: me.selected_deck_category,
				game_created: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
				respond_to_challenge: me.return_from_game_to_challenge,
			})
		])",

		request_observe_game: "def(string username) ->commands
			execute(me, tbs_send(object<- mm_client, { type: 'request_observe', target_user: username }))
		",

		observe_game: "def(GameServer server, string|null username=null, int|null session_override=null) -> commands [
			enter_game(
  				object_playable('citadel_controller', 336, 372, 0, {
				game_server_address: TBS_SERVER_ADDRESS,
				game_server_port: server.port,
				session_id: (session_override or 1d1000000), //_mm_client_state.session_id,
				game_created: true,
				observer: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
				_observer_perspective: perspective,
				respond_to_challenge: me.return_from_game_to_challenge,
			}))
		] where perspective = if(username and username in server.users, index(server.users, username))",

		return_to_main: "def() ->commands [
			if(_logout_label and (_logout_label not in level.chars), add_object(_logout_label)),
			if(_welcome_label and (_welcome_label not in level.chars), add_object(_welcome_label)),
		]
		",

		transition_screen: "def(commands cmd, bool zoom_in=true, bool after_zoom=true) ->commands
		execute(me,
		[
			sound(s, lib.citadel.sound_volume(s)) where s = 'interface/whoosh.wav',
			spawn('zoom_effect_controller', 0, 0, {
				begin_zorder: -10,
				source_area: [0.0,0.0,1.0,1.0],
				dest_area: [0.0,0.0,1.0,1.0],
				flat_color: [0.09,0.14,0.18,1.0],
			}, [
				animate(child, {
					dest_area: if(zoom_in, [-0.25,-0.25,1.25,1.25], [0.1,0.1,0.9,0.9]),
					effect_alpha: 0.0,
					flat_color_mix: if(after_zoom, 0.0, 1.0),
				}, {
					duration: if(MODULE_OPTIONS.startgame, 1, 20),
					on_complete: ; [
						[ remove_object(c) | c <- level.chars, c not in [me] ],
						cmd,

						if(after_zoom,

						spawn('zoom_effect_controller', 0, 0, {
							begin_zorder: -10,
							source_area: [0.0,0.0,1.0,1.0],
							dest_area: if(zoom_in, [0.1,0.1,0.9,0.9], [-0.25,-0.25,1.25,1.25]),
							effect_alpha: 0.0,
							flat_color: [0.09,0.14,0.18,1.0],
						}, [
							animate(child, {
								dest_area: [0.0,0.0,1.0,1.0],
								effect_alpha: 1.0,
							}, {
								duration: 20,
								on_complete: remove_object(child)
							})
						])
						),
					]
				})
			]),
		]
		)
		",

		quit_game: "def() ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'quit_game' })),
			schedule(120, quit_to_desktop()),
		]
		",

		_specified_deck: { type: "null|[string]" },

		play_game: "def() ->commands
		execute(me,
		[
			set(_specified_deck, scenario.player_deck),
			if(scenario.scenario_type = 'multiplayer', [
				send_matchmaking_request({ type: 'pvp' }),

				set(_queued_for_battle, true); _spawn_battle_buttons()


			], [
				play_single_player_game(scenario)
			])
		]
		where scenario = rival_pane.get_scenario()
		where rival_pane = find_or_die(level.chars, value is obj rival_pane)
		)",
		
		cancel_play_game: "def() ->commands
		execute(me, [
			send_cancel_matchmaking_request(),
			set(_queued_for_battle, false); _spawn_battle_buttons()
		])
		",

		_game_setup_message: { type: "null|map" },

		_scenario_playing: { type: "null|Scenario" },

		play_single_player_game: "def(Scenario scenario) ->commands
		execute(me,
		if(not _internal_client,
		set(_internal_client, tbs_internal_client());		
		set(_session_id, 1);
		[
			[
				set(_scenario_playing, scenario),
				set(_game_setup_message, msg),
				tbs_send(object<- _internal_client, msg),
			]
			where msg = {
				type: 'create_game',
				game_type: 'citadel',
				starting_units: scenario.starting_units,
				map_dimensions: scenario.map_dimensions,
				map_lanes: scenario.map_lanes,
				player_resources: scenario.player_resources,
				trophies: scenario.trophies,
				skip_mulligan: scenario.skip_mulligan,
				users: [{user: username, avatar: account_info.avatar, session_id: _session_id, quests: account_info.quests}, {user: scenario.enemy_name, bot_type: scenario.bot_type or 'eval', args: { name: scenario.enemy_name, avatar: scenario.avatar }, bot_args: scenario.bot_args or {}, bot: true, session_id: _session_id+1, avatar: scenario.avatar}],
				tutorial: scenario.tutorial,
				setup_commands: scenario.setup_commands,
			}
		])
		)
		",

		_quest_heading: { type: "null|obj label" },

		update_quests: "def() ->commands [
			set(_adjust_gold_display, 0),

			[ remove_object(c) | c <- level.chars, c is obj quest_display ],

			remove_object(_quest_heading),
			set(_quest_heading, null),

			map(ordered_quests, spawn('quest_display', {
				x: lib.citadel.py(692),
				y: lib.citadel.py(244) + index*lib.citadel.py(46),
				quest: lib.quest.create(value),
			}, [
				if(index = 0,
					spawn('label', {
						x: lib.citadel.py(692),
						y: lib.citadel.py(244) - lib.citadel.py(46),
						_force_width: round_to_even(lib.citadel.py(206)),
						_force_height: round_to_even(lib.citadel.py(46)),
						_text: ['Daily Quests'],
						_font_size: lib.citadel.py(24),
						_bg_color: [0.13,0.65,0.43,1.0],
						_halign: 'none',
						_valign: 'none',
					}, [
					])
				),

				if(prev_quest != null, child.animate_value(prev_quest.current_value, value.current_value)),
				if(value in just_complete_quests,
				[
					add(_adjust_gold_display, quest_info.reward),
					animate(child, {
						brightness: 512,
						scale: 1.5,
					}, {
						name: 'finish_quest',
						replace_existing: false,
						duration: 20,
					});

					animate(child, {
						alpha: 0
					}, {
						name: 'finish_quest',
						replace_existing: false,
						duration: 20,
						on_complete: remove_object(child)
					})
				]
				),
				if(value in account_info.quests and index(ordered_remaining_quests, value) != index, schedule(50, animate(child, { y: lib.citadel.py(244) + index(ordered_remaining_quests, value)*lib.citadel.py(46)}, { duration: 10 })))
			])
			where quest_info = lib.quest.create(value)
			
			where prev_quest = find(previous_quests, value.type = context.value.type)),

			write_document(username + '/known-quests.cfg', { quests: account_info.quests, complete_quests: account_info.complete_quests }),
			; if(_adjust_gold_display != 0,
				schedule(30, animate(me, { _adjust_gold_display: 0 }, { duration: _adjust_gold_display*2 }))
			)

		] where ordered_quests = sort(account_info.quests + just_complete_quests, a.assigned_date < b.assigned_date)
		  where ordered_remaining_quests = sort(account_info.quests, a.assigned_date < b.assigned_date)
		  where just_complete_quests = filter(account_info.complete_quests, find(previous_complete_quests, value.type = context.value.type) = null)
		  where previous_complete_quests = if(previous_quests_doc is { quests: [Quest], complete_quests: [Quest] }, previous_quests_doc.complete_quests, [])
		  where previous_quests = if(previous_quests_doc is { quests: [Quest], complete_quests: [Quest] }, previous_quests_doc.quests, [])
		  where previous_quests_doc = get_document(username + '/known-quests.cfg', ['user_preferences_dir', 'null_on_failure', 'json']) or []",

		_adjust_gold_display: { type: "int", default: 0, set: "if(value != _data, [set(_data, value), set(_player_profile_dirty, true)])" },
		_adjust_level_display: { type: "decimal", default: 0.0, set: "if(value != _data, [set(_data, value), set(_player_profile_dirty, true)])" },

		_player_profile_pane: { type: "null|obj player_profile_pane" },

		_player_profile_dirty: { type: "bool", default: false },

		_prev_level: { type: "decimal|null" },

		update_player_profile: "def() ->commands [
			set(_player_profile_dirty, true),

			if(_prev_level != null and _prev_level != account_info.level, [
				add(_adjust_level_display, (account_info.level - _prev_level));
				schedule(30, animate(me, { _adjust_level_display: 0 }, { duration: 30 })),
			]),

			set(_prev_level, account_info.level),
		]",

		draw_player_profile: "def() ->commands ; execute(me, [
			set(_player_profile_dirty, false),

			remove_object(_player_profile_pane),

			spawn('player_profile_pane', {
				x: lib.citadel.py(14),
				y: lib.citadel.py(124),
				title_controller: me,
				_adjust_gold_display: _adjust_gold_display,
				_adjust_level_display: _adjust_level_display,
			}, [
				set(me._player_profile_pane, child),
			]),
		])",

		show_ui: "def() ->commands [
			[ remove_object(c) | c <- level.chars, c != me ],

			update_quests(),
			[update_player_profile(); draw_player_profile()],

			set(_screen_controller, null),

			set(_internal_client, null),
			set(_session_id, -1),

			spawn('users_online_pane', {
				title_controller: me,
				x: lib.citadel.py(1370),
				y: lib.citadel.py(44),
				_width: lib.citadel.py(212),
				_height: lib.citadel.py(840),
			}),

			if(game_title != null, [
				add_object(game_title),
				animate(game_title, {
					_font_size: lib.citadel.py(30),
				}, {
					duration: 10,
					on_process: fire_event(game_title, 'create'),
					on_complete: fire_event(game_title, 'create'),
				}),

				animate(game_title, {
					x: lib.citadel.py(102),
					mid_y: lib.citadel.py(24),
				}, {
					duration: 20,
				}),
			]),

			if(game_logo != null, [
				add_object(game_logo),
				animate(game_logo, {
					size: lib.citadel.py(80),
					mid_x: lib.citadel.py(56),
					mid_y: lib.citadel.py(50),
				}, {
					duration: 20,
				})
			]),

			spawn('label', {
				x: lib.citadel.py(104),
				mid_y: lib.citadel.py(50),
				_font_size: lib.citadel.py(14),
				_text: ['Status'],
				_halign: 'left',
			}, [
				set(server_status_label, child)
			]),

			spawn('news_updates_pane', {
				x: lib.citadel.py(14),
				y: lib.citadel.py(320),
				title_controller: me,
			}),

			spawn('chat_widget', {
				x: lib.citadel.py(16),
				y: lib.citadel.py(1080 - 446),
				_width: lib.citadel.py(374),
				_height: lib.citadel.py(250),
			}, [
			]),

			spawn('choose_deck_controller', {
				title_controller: me,
				current_controller: me,
				_preview_x: lib.citadel.px(0),
				_preview_y: lib.citadel.py(0),
			}),

			spawn('rival_pane', {
				x: lib.citadel.py(404),
				y2: lib.citadel.py(884),
				title_controller: me,
			}),

			_spawn_battle_buttons()

		]",

		_spawn_battle_buttons: "def() ->commands
			map(_battle_widgets, remove_object(value));
			set(_battle_widgets, []);
			set(_battle_pending_label, null);

			if(_queued_for_battle, [
				spawn('label', {
					x: lib.citadel.py(694),
					y: lib.citadel.py(840),
					_text: ['Queued'],
					_halign: 'left',
					_font_size: lib.citadel.py(26),
					zorder: me.zorder+10,
				}, [
					add(me._battle_widgets, [child]),
					set(me._battle_pending_label, child),
				]),

				spawn('button_controller', {
					x: lib.citadel.py(820),
					y: lib.citadel.py(850),
					button_width: lib.citadel.py(80),
					button_height: lib.citadel.py(34),
					text: 'Cancel',
					on_click: me.cancel_play_game,
				}, [
					add(me._battle_widgets, [child]),
				])
			],

				spawn('button_controller', {
					x: lib.citadel.py(694),
					y: lib.citadel.py(850),
					button_width: lib.citadel.py(204),
					button_height: lib.citadel.py(34),
					text: 'Battle!',
					on_click: me.play_game,
				}, [
					add(me._battle_widgets, [child]),
				])
			)
		",

		_queued_for_battle: { type: "bool", default: false },

		_battle_widgets: { type: "[custom_obj]", default: [] },
		_battle_pending_label: { type: "null|obj label" },

		setup_screen_dim: "def() ->commands [
			debug(['ZZZ SCREEN_DIM', level.dimensions]),
			if(decimal(level.dimensions[2])/decimal(level.dimensions[3]) < 1.77,
			[
				set(level.dimensions, [0,0,level.dimensions[2],new_height]),
				set(level.absolute_object_adjust_y, (level.dimensions[3] - new_height)/2), 
			] where new_height = int(level.dimensions[2]/1.777777)
			);

			set(lib.citadel.screen_width, level.dimensions[2]);
			set(lib.citadel.screen_height, level.dimensions[3])
		]",
    },
      
    on_create: "setup_screen_dim(); [
		set(level.fb_render_target, {blend_enable: true}),

		set_user_info('user', _mm_client_state.username),

		set(x, 0),
		set(y, 0),

		show_ui(),


	] where user_decks = account_info.decks",

	on_being_added: "return_to_main()",

	on_spawn_objects: "[
//		spawn_deck_summaries(),
	]",
	
	on_type_updated: "show_ui()",
	
	on_process: "[
		if(_player_profile_dirty, draw_player_profile()),
		if(_debug_label_mouse_loc, _debug_show_mouse_loc()),

		if(me._internal_client, tbs_process(me._internal_client)),
		if(_concede_client, [tbs_process(_concede_client), if(_concede_client.in_flight = 0, set(_concede_client, null))]),

		if(_battle_pending_label != null and cycle%10 = 0,
		   _battle_pending_label.set_text(['Queued' + fold(map(range((cycle/10)%4), '.'), a+b, '')])
		),

		update_server_status_label(),

	]",

    on_connection_error: "teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0))",
    
	on_connection_success: "null",

	on_matchmake_message_received: "[
	//debug(['MATCHMAKE:', message.type, message]),
	matchmaking_handle_message(message),
	switch(message.type,
		'quit_ack', [
			if(_logging_out,
				teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0)),
				quit_to_desktop()
			)
		],

		'message', [
			spawn_notification(string<- message.message)
		],

		'error', [
			spawn_notification(string<- message.message)
		],

		'recent_games', [
			set(recent_games, games);
			if(dialog != null, dialog.update_games())
		] where dialog = find(level.chars, value is obj recent_games_dialog)
		  where games = list<- message.game_info,

		'matchmaking_queued', [
			debug('queued matchmaking'),
		],

		'replay', start_replay(message),

		'match_made', join_game(if(message.host, string<- message.host, TBS_SERVER_ADDRESS), if(message.port, int<- message.port, TBS_SERVER_PORT)),

		'heartbeat', [

			if(server_info, [
				set(me.game_port, int|null<- message.game_port),
				set(me.game_session, int|null<- message.game_session),
				set(me.game_id, int|null<- message.game_id),
			])

		] where server_info = map|null<- message.server_info,

		'admin_busy', [
			//spawn_notification('The server is busy executing a command already')
		],
		'admin_message', [
			spawn_notification(string<- message.message),
			if(message.complete, set(_server_output_pending, false))
		],
	)
	] where message = map<- arg.message",
	
	on_message_received: "[
	 debug('message: ' + str(message.type)),
	switch(message.type,
		'game_created', 
		[
		set(_queued_for_battle, false),
		transition_screen(
		[
			map(level.chars, remove_object(value)),
			add_object(playable),
		], true, false),

		set(_game_setup_message, null),
		set(_scenario_playing, null),
		]
		   where playable = object_playable('citadel_controller', 336, 372, 0,
		   {
		    game_setup_message: _game_setup_message,
			_mm_client_state: _mm_client_state,
			game_server_address: '',
			game_server_port: 23456,
			session_id: me._session_id,
			game_created: true,
			selected_deck: me.selected_deck,
			selected_deck_category: me.selected_deck_category,
			return_callback: me.return_from_game,
			specified_deck: _specified_deck,
			respond_to_challenge: me.return_from_game_to_challenge,
			client_tutorial_args: if(_scenario_playing, _scenario_playing.client_tutorial_args) or {},
			}
		   ),
		'server_info',
		[],
		'heartbeat', [
		],

		debug('UNKNOWN MESSAGE RECIEVED: ' + str(message.type))
	) asserting message.type != 'error']
	  where message = map<- arg.message",

	on_do_observe: "teleport('observation_lobby.cfg', '', 'fade', playable)
	    where playable = object_playable('observation_lobby_controller', 0, 0, 0, { client: tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT) })",
	
	on_do_mp_lobby: "teleport('matchmaking_lobby.cfg', '', 'fade', playable)
		where playable = object_playable('matchmaking_lobby_controller', 0, 0, 0, { _mm_client_state: _mm_client_state, selected_deck: selected_deck })
	",
	
	on_settings_menu: "
	[
		set(level.show_builtin_settings_dialog, false),
		if(menu, remove_object(menu),

		_screen_controller is obj settings_screen,

		_screen_controller.close_settings(),

		spawn('game_menu_controller', {
			_exclude_from_pause: [me],
			buttons: [
			{
				text: 'Settings',
				callback: (def()->commands transition_screen(; execute(me, enter_settings()), false)),
			},
			{
				text: 'Resume',
				callback: (def()->commands null),
			},
			{
				text: 'Change User',
				callback: me._handle_logout,
			},
			{
				text: 'Quit',
				callback: me.quit_game,
			},
			]
		})
		)
	]
	where menu = find(level.chars, value is obj game_menu_controller)
	",

}
