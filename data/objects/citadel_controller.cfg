{
id: "citadel_controller",
next_animation: "'normal'",
is_human: true,
always_active: true,
hidden_in_game: true,
vars: {
	last_triggered: -400,
	client: null,
	state: null,
	state_id: -1,
	card_preview: null,
	card_preview_for: null,
},

tmp: {
	playing_card: -1,
	targets_chosen: [],
	active_targets: [],
},

properties: {
	myplayer: "vars.state.players[vars.state.nplayer]",

	hand_index_after_discarding: "def(nhand) nhand - count(level.chars, value.type = 'card' and value.vars.discarded and value.vars.hand_index < nhand)",

	mark_sent_discards: "
	[set(card.vars.sent_discard_msg, true) |
	  card <- level.chars, card.type = 'card', card.vars.discarded = true]
	",

	discard_command: "
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = [card.vars.hand_index |
	    card <- level.chars, card.type = 'card', card.vars.discarded = true,
		                     card.vars.sent_discard_msg = false]
	",

	remove_preview_card: "def(card) if(vars.card_preview and (vars.card_preview_for = card or card = null), [if(vars.card_preview.vars.creature, vars.card_preview.vars.creature.destroy()), remove_object(vars.card_preview), set(vars.card_preview, null)])",

	/*mouse_enter_card: "def(card) execute(me, [
	  remove_preview_card(null),
	  set(vars.card_preview_for, card),

	  spawn('card', 760, 120, 1, [
	     set(vars.card_preview, child),
		 set(child.vars.in_hand, true),
		 set(child.scale, 2.0),
		 set(child.vars.player, myplayer),
		 set(child.card_type, card.card_type)
	  ])
	])",*/

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(tile) if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
		 set(vars.card_preview_for, tile.vars.loc)
	   ]) where card = get_document('data/cards.cfg')[creature.name])
	      where creature = vars.state.creature_at_loc(tile.vars.loc)",
	mouse_leave_tile: "def(tile) remove_preview_card(tile.vars.loc)",

	mouse_enter_log: "def(index)
	   if(items = null, if(is_string(vars.card_preview_for),
			           remove_preview_card(vars.card_preview_for)),
		[
//			 mouse_enter_card({card_type: construct('card',
//			    get_document('data/cards.cfg')[items[1]])}),
			 set(vars.card_preview_for, items[1])
	    ])
	    where items = if(index = -1, null,
		   regex_match(vars.state.log[index], '(.*) plays (.*)'))",

	card_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	  if(card.vars.discarded,
	  [card.set_discarded(false), add(myplayer.resources, -1)],
	  [tile_clicked(null), choose_targets_for_card(card, [])]))",
	card_right_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	 if(not card.vars.discarded, [
	   tile_clicked(null),
	   add(myplayer.resources, 1),
	   card.set_discarded(true)
	]))",
	      
	tile_clicked: "def(tile) [
	   execute(me, 	map(level.chars, if(value.type = 'tile', set(value.selectable, false)))),
	   if(tile and tmp.playing_card != -1, choose_targets_for_card(find(level.chars, value.vars.hand_index = tmp.playing_card), tmp.targets_chosen + [tile.vars.loc]))
	 ]",
	
	choose_targets_for_card: "def(card, current_targets) execute(me, [
	  debug('choose targets ' + current_targets),
	   if(vars.state.nplayer = vars.state.current_player and (vars.state.response_phase = 0 or card.card_type.is_response),
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [],
		      if(possible_targets = null,
				[
				 tbs_send(vars.client, {
				   type: 'moves',
				   moves: discard_command + [{type: 'play_card', index: hand_index_after_discarding(card.vars.hand_index), targets: current_targets}]
				  }),
				 mark_sent_discards,
				 set(tmp.playing_card, -1)
				],
			    [
				 map(level.chars, if(value.type = 'tile', set(value.selectable, value.vars.loc in possible_targets))),
				 set(tmp.playing_card, card.vars.hand_index),
				 set(tmp.active_targets, []),
				 set(tmp.targets_chosen, current_targets)
				]
					 ),
			  [
			  	debug('no valid targets')
			  ])]
		where can_afford = myplayer.can_afford(card.card_type.school, card.card_type.cost, card.card_type.loyalty_cost)
		where possible_targets = card.card_type.possible_targets(vars.state, vars.state.nplayer, current_targets))
	 ])",
	
	
	creature_clicked: "def(creature) execute(me, [
	    if(creature.vars.creature_object.loc != null,
		  [map(filter(level.chars, value.type = 'creature_status'), value.destroy()),
		   spawn('creature_status', 600, 0, 1, [set(child.creature_object, creature.vars.creature_object)])]
		  )
	  ])",
	
	can_use_ability: "def(creature, ability_name)
	 vars.state.nplayer = vars.state.current_player and
	 (vars.state.response_phase = 0 or ability.is_response) and
	 myplayer.can_afford(ability.school, ability.cost, ability.loyalty_cost) and creature.summoned and
	 ability.is_usable(vars.state, creature)
	  asserting ability
	  where ability = find(creature.abilities, (not is_string(value)) and value.name = ability_name)",
	 
	
	ability_clicked: "def(creature, ability_name)
	execute(me, [
	if(can_use_ability(creature, ability_name),
	    [
		  tbs_send(vars.client, 
		  {
			type: 'moves',
		    moves: discard_command + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name}],
		  }),
		  mark_sent_discards
		  ]
	) asserting ability
	  where ability = find(creature.abilities, (not is_string(value)) and value.name = ability_name)
	  ])"
},

on_create: "
	set_widgets(
	[{
		type: 'grid',
		columns: 1,
		children: [

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Join Game', font: 'default', size: 1},
				on_click: q([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'request_updates', state_id: vars.state_id})]
				         where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 2))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Create Game', font: 'default', size: 1},
				on_click: q([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Play vs Bot', font: 'default', size: 1},
				on_click: q([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', bot: true, session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

		]
	},
	])
",

on_message_received: "[debug('msg: ' + message.type, message),
  switch(message.type,
		 'game_created',
         [set(vars.client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 1),

         'game',
		 if(message.state.players[message.state.nplayer].deck = null,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
		  	map(get_document('data/player-deck.cfg'), null asserting get_document('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
			tbs_send(vars.client, {type: 'submit_deck', deck: get_document('data/player-deck.cfg')}),
		  ],

		 [
		    debug('got state_id: ' + message.state_id + '/' + vars.state_id + ' response phase: ' + vars.state.response_phase),
		    set(vars.state_id, message.state_id),
		    [remove_object(heart) | heart <- level.chars, heart.type = 'citadel_controller.heart'],
			map(message.state.players, map(range(max(value.life, 0)), spawn('citadel_controller.heart', -50 + if(context.index = 1, 910), 210 + index*40, 1))),
		    if(creature_status,
				if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
				   where creature = find(message.state.creatures + message.state.summonings, value.summon_id = creature_status.creature_object.summon_id)
					
					) where creature_status = find(level.chars, value.type = 'creature_status'),
		    [map(filter(level.chars, value.type in ['tile', 'card', 'tile.level_label']), remove_object(value)),
			 map(range(message.state.rows), map(range(message.state.columns), spawn('tile', 20 + col*90 + if(row%2 = 1, 45, 0), 170 + row*52, 1, [set(child.vars.loc, [row,col]), set(child.vars.game, message.state)]) where col = value) where row = value)],
		  set(vars.state, message.state),
		  if(message.state.nplayer = message.state.current_player, 
		    set_widgets(
			
			if((not message.state.done_movement) and find(message.state.creatures, value.controller = message.state.nplayer) != null,
			[ 
			{
				type: 'button',
				id: 'movement_button',
				x: 500,
				y: 100,
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Movement', font: 'default', size: 1},
				on_click: q([set_widgets([]),
				             set(vars.playing_card, -1),
				             set(vars.active_targets, []),
							 tbs_send(vars.client,
							   {
							     type: 'moves',
							     moves: discard_command + [{type: 'movement'}]
							   }
							  ),
							  mark_sent_discards
							 ]),
			}
			], []) +
		
			[
			{
				type: 'button',
				id: 'end_turn_button',
				x: 500,
				y: 150,
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: if(message.state.response_phase = 0, 'End Turn', 'End Response'), font: 'default', size: 1},
				on_click: q([set_widgets([]),
				             set(vars.playing_card, -1),
				             set(vars.active_targets, []),
							 tbs_send(vars.client, {
							  type: 'moves',
							  moves: discard_command + [{type: 'end_turn'}]
							 }),
							 mark_sent_discards
							 ]),
			},
			
			]),
		    set_widgets([{
				type: 'graphical_font_label',
				text: if(message.state.response_phase = 0, 'Main Phase', 'Response Phase'),
				id: 'status_label',
				x: 500,
				y: 150,
				size: 1,
				font: 'default'
		   }])),
		  map(filter(level.chars, value.type = 'creature' and
		                          find(message.state.creatures + message.state.summonings, context.value.vars.creature_object.summon_id = value.summon_id) = null),
			 if(dead_object != null,
				set(value.creature_object, dead_object),
				value.destroy())
			  where dead_object = message.state.graveyard[value.creature_object.summon_id]), 
		  map(message.state.players[message.state.nplayer].hand,
		     spawn('card', 5 + index*135, 590, 1,
			   [set(child.vars.in_hand, true),
			    set(child.vars.hand_index, index),
		        set(child.vars.player, message.state.players[message.state.nplayer]),
			    set(child.card_type, value)])),
		  
		  map(message.state.creatures + message.state.summonings,
		      if(obj != null,
			     //if the object with this summon_id already exists, tell it
				 //about its new internal object.
			     set(obj.creature_object, value),
		      
			  //create a new object to represent this creature.
		      spawn('creature', 0, 0, 1,
					[set(child.creature_object, value)]))
			  
			  //obj represents the existing object representing this creature.
			  where obj = find(level.chars, value.type = 'creature' and
			                                value.vars.creature_object.summon_id = context.value.summon_id)),

	find(level.chars, value.type = 'log_controller').set_log(message.state.log)

	]), // end 'game' case.

         //default case.
         [debug('got message: ', message)]),
		 fire_event('request_updates')]",

on_request_updates: "if(vars.client.in_flight = 0,
					      [debug('request_updates: ' + vars.state_id), tbs_send(vars.client, { type: 'request_updates', state_id: vars.state_id })])",
on_connection_error: "[debug('message error', error), fire_event('request_updates')]",

on_process: "if(vars.client, tbs_process(vars.client))",

on_end_anim: "animation('normal')",
zorder: 50,
timer_frequency: 10,
on_timer: "if(level.player.midpoint_x > vars.x_bound and level.player.midpoint_x < vars.x2_bound  and level.player.midpoint_y > vars.y_bound and level.player.midpoint_y < vars.y2_bound and cycle - vars.last_triggered > 250, [fire_event('triggered'),set(vars.last_triggered,cycle)])",
on_triggered: "",
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},
animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [
	{
		id: "heart",
		animation: [
			{
				id: "normal",
				image: "tiles.png",
				rect: [5,67,19,79],
				frames: 1,
			}
		],
	}
],
}
