{
id: "citadel_controller",
prototype: ["citadel_controller_base"],
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,

properties: {

	_bdk_controller: { type: "null|obj bdk_controller" },

	_response_pause_counter: { type: "int", default: -1 },

	_last_state_message: { type: "map", default: {} },

	_status_label: { type: "null|obj citadel_controller.status_label" },

	state: "class game<- _state asserting _state",
	_state: { type: "class game|null" },
	end_of_turn_state: { type: "class game|null" },
	_state_id: { type: "int", default: -1 },
	_processed_state_id: { type: "int", default: -1 },
	_client: { type: "object|null" },

	client: "object<- _client asserting _client",

	_card_preview_for: { type: "any", default: null },
	_card_preview: { type: "obj card|null" },
	card_mouseover: { type: "obj card|null",
	   set: "if(value != _data, [
	     if(_data != null, [set(_data.allow_drag, false), _end_mouseover(_data)]),
		 if(value != null, set(value.allow_drag, true)),
		 set(_data, value)
	   ])"
	 },

	 _chat_area: { type: "obj chat_area|null" },

	_card_regions: { type: "[{left: int, right: int, top: int, card_num: int}]", default: [] },
	_card_regions_left_to_right: "[{left: int, right: int, top: int, card_num: int}] :: sort(_card_regions, a.left < b.left)",
	_hand_card_moused_over: "int ::
	 (if(region = null, -1, region.card_num)
	      where region =
		     if(card_mouseover, find(card_regions_ordered,
			   (index >= mouseover_index and xpos >= value.right - reserved_region and xpos <= value.right and ypos >= value.top) or
			   (index <= mouseover_index and xpos >= value.left and xpos <= value.left + reserved_region and ypos >= value.top))) or
		  	 
		     //prefer the already selected card
		     if(card_mouseover, find(card_regions_ordered, card_mouseover.hand_index = value.card_num and (card_mouseover.being_dragged or xpos >= value.left and xpos <= value.right + 0.2*(value.right - value.left) and ypos >= value.top))) or

			 //not over an already selected card, find the first match.
		     find(card_regions_ordered, xpos >= value.left and xpos <= value.right and ypos >= value.top)
	      where xpos = ctrl_mice[0][0]
	      where ypos = ctrl_mice[0][1])
		  asserting size(ctrl_mice) = 1
		  where reserved_region = min(10, 200 / (size(card_regions_ordered)+1))

		  //Since card regions overlap, we want to order the card regions by
		  //their order of priority if a match is found. We prefer to match
		  //to a region closest to the already selected card, so reverse cards
		  //to the left in order while keeping cards to the right in order.
		  where card_regions_ordered = if(mouseover_index < 0, _card_regions_left_to_right, reverse(_card_regions_left_to_right[:mouseover_index]) + _card_regions_left_to_right[mouseover_index:])
		  where mouseover_index = index(_card_regions_left_to_right, find(_card_regions_left_to_right, card_mouseover != null and card_mouseover.hand_index = value.card_num))",

	//location of the tops of our cards
	_card_hand_top: { type: "decimal", default: 0.0 },

	_prev_ctrl_keys: { type: "[string]", default: [] },

	_playing_card: { type: "int", default: -1 },
	_playing_ability: { type: "class util.playing_activated_ability|null" },

	_targets_chosen: { type: "[Loc]", default: [] },

	animation_move_time: { type: "int", default: 0 },
	_animation_end_time: { type: "int", default: -1 },

	_game_state_queue: { type: "[map]", default: [] },
	_furthest_animation_hint: { type: "int", default: 0 },

	_animation_hints_id: { type: "int", default: 0 },

	_animated_spell_card: { type: "null|obj card", default: null },
	_spells_on_stack: { type: "[obj card]", default: [] },

	_spell_animation_time: { type: "int", default: 0 },

	_choice_object: { type: "null|obj choice_controller" },

	_deck_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_discard_obj: { type: "[obj citadel_controller.card_back|null]", default: [] },
	_hand_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_level_obj: { type: "[obj citadel_controller.card_back]", default: [] },

	_cards_suggest_discard: { type: "[int]|null" },

	font: "string<- 'RobotoCondensed-Regular'",
	color: "string<- 'antique_white'",
	font_color: "string<- 'antique_white'",

	_spell_windup_sound_being_played: { type: "string|null" },

	//the game_icon objects representing the mana the active player has
	_mana_symbol_objects: { type: "[obj game_icon]", default: [] },

	return_callback: { type: "function(bool) ->commands" },

	observer: { type: "bool", default: false },

	game_created: { type: "bool", default: false },
	session_id: { type: "int", default: -1 },
	selected_deck: { type: "string", default: "" },
	game_server_address: { type: "string", default: "@eval TBS_SERVER_ADDRESS" },
	game_server_port: { type: "int", default: "@eval TBS_SERVER_PORT" },

	level_width: "int :: level.dimensions[2]",
	level_height: "int :: level.dimensions[3]",

	card_keeps: "[int]<-  [card.hand_index | card <- level.chars, card is obj card, card.in_hand, card.keep]",

	card_keep_draw_id: "[int] :: [card.card_type.draw_id | card <- level.chars, card is obj card, card.in_hand, card.keep]",

	end_turn_message: "{string -> any}<- {type: 'end_turn', keep: card_keeps}",

	get_zorder: "def(string key) ->int lib.citadel.zorder(key)",

	set_status_label: "def(string text, string color='white', int duration=150) ->commands 
	[
		if(_status_label, remove_object(_status_label)),
		spawn('citadel_controller.status_label', 0, 0, 1, [
			set(_status_label, child),
			set(child.zorder, get_zorder('status_label')),
			if(duration > 0, execute(child, schedule(duration,
			                                         remove_object(child)))),
			debug('init label: ' + text),
			child.init_label(text, color, int(_card_hand_top)),
		])
	]",

	awaiting_input: "bool :: _playing_card != -1 or _playing_ability != null",

	clear_input_state: "def() ->commands execute(me, [
		if(me.card_mouseover, mouse_leave_card(me.card_mouseover)),
		[set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		set(_playing_card, -1),
		set(_playing_ability, null),
		set(_targets_chosen, []),
		set(_cards_suggest_discard, null),
		set(me.card_mouseover, null),
	])",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def() ->commands
	  if(myplayer.hand != myplayer.previous.hand, clear_input_state())
	",

	//debug function to execute FFL on the server.
	server_exec: "def(string code) ->commands
	execute(me, tbs_send(client, {
		type: 'moves',
		state_id: _state_id,
		moves: [{
			type: 'debug',
			exe: code
		}]
	}))
	",

	send_chat: "def(string msg) ->commands
		execute(me, tbs_send(client, {
			type: 'chat_message',
			text: msg,
			nick: USERNAME,
		}))
	",

	debug_draw: "def(int ncards) ->commands server_exec('players[current_player].draw_cards(me, ' + ncards + ')')",
	debug_mana: "def(int nmana) ->commands server_exec('add(players[current_player].resources, ' + nmana + ')')",
	debug_card: "def(string name) ->commands server_exec('add(players[current_player].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",
	debug_card_enemy: "def(string name) ->commands server_exec('add(players[next_player_index].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",

	debug_enemy_hand: "[string]<- map(state.opponent_obj.hand, value.name)",
	
	animation_up_to_date: "bool<- _processed_state_id = _state_id",
	reserve_animation_time: "def(int ncycles) ->commands if(end_time > _animation_end_time, set(me._animation_end_time, end_time)) where end_time = level.cycle + ncycles",
	myplayer: "class player<- _state.players[_state.nplayer] asserting _state",
	enemy_player: "class player<- _state.players[(_state.nplayer+1)%2] asserting _state",

	hand_index_after_discarding: "def(int nhand) ->int nhand - count(level.chars, value is obj card and value.discarded and value.hand_index < nhand)",

	mark_sent_discards: "commands<-
	[set(card.sent_discard_msg, true) |
	  card <- level.chars, card is obj card, card.discarded = true]
	",

	discard_command: "def([int] additional_indexes=[]) ->[map]
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = additional_indexes + [card.hand_index |
	    card <- level.chars, card is obj card, card.discarded = true,
		                     card.sent_discard_msg = false]
	",

	resources_from_discards: "def() ->int
	  size([card | card <- level.chars, card is obj card, card.discarded = true, card.sent_discard_msg = false])",

	remove_preview_card: "def(any card) ->commands if(_card_preview and (me._card_preview_for = card or card = null), [remove_object(_card_preview), set(_card_preview, null)])",

	mouse_enter_card: "def(obj card card) ->commands [
	 if(card.in_hand, [
		set(card.zorder, get_zorder('card_highlight')),
		set(card.animation_target, {mid_x: pos.mid_x, mid_y: pos.mid_y - 200, rotate: 0.0, cycles: 10, total_cycles: 10, card_size: pos.card_size*2}) where pos = cards_in_hand_positions(state.players[state.nplayer].hand)[card.hand_index],
		set(me.card_mouseover, card),
	 ]),
	 (if(me._playing_card = -1, if(me.card_mouseover = card, null,
	  if(me.card_mouseover != null, [
			mouse_leave_card(me.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.in_hand,
	  if(discards != null and possible_targets != [],
	  [
	 	card.show_halo(),
	    set(me.card_mouseover, card),
	    set(_cards_suggest_discard, discards),

		//synthetic clicks to suggest discarding
	  	[card_right_clicked(card) | card <- level.chars, card is obj card, card.hand_index in discards]
	  ])
	  where discards = (local_player.suggest_discards(local_player.calculate_cost(local_player.hand[card.hand_index]) - resources_from_discards(), filter([card.hand_index] + [card.hand_index | card <- level.chars, card is obj card, card.discarded or card.keep], value != null))
		  ))
 	  where possible_targets = if(card.card_type is class card, card.card_type.possible_targets(state, state.nplayer, []), [])
	  )))

	asserting (not card.in_hand) or (card.hand_index < size(local_player.hand)) | 
	[size(local_player.hand), card.hand_index, card.card_type.name, [[card.hand_index, card.in_hand, card.card_type.name] | card <- level.chars, card is obj card], [card.name | card <- local_player.hand]]
	  )]
	  where local_player = myplayer",
	
	_end_mouseover: "def(obj card card) -> commands
	  if(card.in_hand and find(level.chars, value = card) and find(state.players[state.nplayer].hand, value = card.card_type) != null,
	    [
		card.hide_halo(),
		set(card.zorder, pos.zorder),
		set(card.animation_target, {mid_x: pos.mid_x, mid_y: pos.mid_y, rotate: pos.rotate, cycles: 10, total_cycles: 10, card_size: pos.card_size}),
	    ] where pos = cards_in_hand_positions(state.players[state.nplayer].hand)[card.hand_index]
	  )
	",

	mouse_leave_card: "def(obj card card) ->commands [

	  set(me.card_mouseover, null),
	  if(me.card_mouseover = card and _cards_suggest_discard != null, [
		map(_cards_suggest_discard, if(obj and obj.discarded, card_clicked(obj)) where obj = find(level.chars, value is obj card and value.hand_index = context.value)),
		set(_cards_suggest_discard, null),
	])
	]",

	mouse_drag_card_start: "def(obj card card) ->commands
		if(card = card_mouseover,
		[
			set(card.card_size, 1.0),
			set(card.mid_x, mouse_x),
			set(card.mid_y, mouse_y),
		]
		)
	",

	mouse_drag_card: "def(obj card card) ->commands
	if(card.in_hand and card.hand_index != null,
	[
		if(pos != -1, [
		   set(card.keep, mouse_x >= _card_regions_left_to_right[0].left and (obj_replacing.keep or mouse_x > _card_regions_left_to_right[size(_card_regions_left_to_right)-1].right)),
		   set_card_hand_position(card.hand_index, pos),
		   bind_command(spawn_cards_in_hand)
		  ]
		  where obj_replacing = find_or_die(level.chars, value is obj card and value.hand_index = _card_regions_left_to_right[pos].card_num)) 
		  where pos = index(_card_regions_left_to_right, find(_card_regions_left_to_right,
		     mouse_y > value.top and (
		     (mouse_x > (value.left + value.right)/2 and mouse_x < value.right) or
			 (index = 0 and mouse_x < value.left and mouse_x > value.left - (value.right - value.left)) or
			 (index = size(_card_regions_left_to_right)-1 and mouse_x > (value.right)))))
	])",

	mouse_drag_card_end: "def(obj card card) ->commands [
		if(card = card_mouseover,
			[
				mouse_leave_card(card),
			]
		)
	]",

	mouse_x: "int<- ctrl_mice[0][0]",
	mouse_y: "int<- ctrl_mice[0][1]",


	mouse_enter_discard: "def(int nplayer) ->commands execute(me, [

	])",

	mouse_click_discard: "def(int nplayer) ->commands []",

	mouse_leave_discard: "def(int nplayer) -> commands execute(me, [
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(obj tile tile) ->commands
	if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
		 set(me._card_preview_for, tile.loc)
	   ]) where card = lib.json.get_document_map('data/cards.cfg')[creature.name])
	      where creature = state.creature_at_loc(tile.loc)",
	mouse_leave_tile: "def(object tile) ->commands remove_preview_card(tile.loc)",

	mouse_enter_log: "def(int index) ->commands
	   if(items = null, if(is_string(me._card_preview_for),
			           remove_preview_card(me._card_preview_for)),
		[
//			 mouse_enter_card({card_type: construct('card',
//			    get_document('data/cards.cfg')[items[1]])}),
			 set(me._card_preview_for, items[1])
	    ])
	    where items = if(index = -1, null,
		   regex_match(state.log[index], '(.*) plays (.*)'))",

	card_clicked: "def(obj card card) ->commands if(state.nplayer = state.current_player and observer = false,
	  if(card.discarded,
	  [debug('set not discarded'), card.set_discarded(false)],
	  [tile_clicked(null),

	   //commit to any card discard at this point.
	   set(me.card_mouseover, null),
	   set(_cards_suggest_discard, null),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])
	]))",
	card_right_clicked: "def(obj card card) ->commands [
	 if(state.nplayer = state.current_player and observer = false,
	 if((not card.discarded) and (not card.card_type.hero), [
	   debug('set card discarded'),
	   tile_clicked(null),
	   card.set_discarded(true),
	],
	 if(card.card_type.hero, set_status_label('Hero cards may not be discarded for mana', 'red'))
	))
	]",

	option_clicked: "def(null|int|string choice_value) ->commands execute(me, [
	debug('option clicked: ' + choice_value),
	tbs_send(client, {
		type: 'moves',
		state_id: _processed_state_id,
		moves: [{
			type: 'make_choice',
			choice: choice_value,
		}],
	})
	])",
	      
	tile_clicked: "def(obj tile|null tile) ->commands
	[if(not state.current_choice, [
	   execute(me, 	map(level.chars, if(value is obj tile,
	                                    set(value.selectable, false)))),
	   if(tile and me._playing_card != -1 and tile.selectable,
		  choose_targets_for_card(
		   obj card<- //assert we succeed in finding.
		    find(level.chars, value is obj card and
			                  value.hand_index = me._playing_card),
			_targets_chosen + [tile.loc]),
		 
		 if(tile and _playing_ability != null and tile.selectable,
		    choose_targets_for_ability(_playing_ability.creature,
			                           _playing_ability.ability,
									   [tile.loc]),

		//cancel all discards
	   [
		if(tile, [card_clicked(card) |
				  card <- level.chars,
				  card is obj card,
				  card.discarded]),
		if(tile != null, clear_input_state())
	   ]))
	 ])]",
	
	choose_targets_for_ability: "def(class creature creature, class activated_ability ability, [Loc] targets) ->commands execute(me, [
		 tbs_send(client, {
		   type: 'moves',
		   state_id: _processed_state_id,
		   moves: discard_command(if(discards, discards, []) where discards = myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability.name, targets: targets, player_index: state.current_player}]
		  }),
		  mark_sent_discards,
		  [set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		  set(me._playing_card, -1),
		  set(_targets_chosen, []),
		  set(_playing_ability, construct('util.playing_activated_ability', {creature: creature, ability: ability})),
	]) asserting client",
	
	choose_targets_for_card: "def(obj card card, [Loc] current_targets) ->commands
	execute(me,
	if(card_instance and state.in_response_phase and not card_instance.is_response,
	set_status_label('Can only cast response spells during response phase', 'red'),
	[
	   if(card_instance and card.hand_index != null and state.nplayer = state.current_player and observer = false,
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [] and not unique_violation,
		      if(possible_targets = null,
				[
				 tbs_send(client, {
				   type: 'moves',
				   state_id: _processed_state_id,
				   moves: discard_command() + [{
					type: 'play_card',
					index: hand_index_after_discarding(card.hand_index),
					player_index: state.current_player,
					targets: current_targets,
				   }]
				  }) asserting _client,
				 mark_sent_discards,
				 set(me._playing_card, -1),
				 set(_playing_ability, null),
				],
			    [
				 map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
				 set(me._playing_card, card.hand_index),
				 set(_playing_ability, null),
				 set(_targets_chosen, current_targets)
				]),
			  [
			   set_status_label(if(possible_targets = [],
			    if(card_instance.creature_object != null and card_instance.hero /*and find(state.creatures, value.controller = state.current_player and value.name = card_instance.creature_object.name) != null*/, 'Cannot play duplicate heroes', 'No valid targets'),
			        if(not can_afford, 'Not enough mana: ' + myplayer.resources + ' to play ' + card_instance.name,
						card_instance.name + ' is already on the field, you may not play copies of a hero.')), 'red')
			  ])]
		where unique_violation = card_instance.hero and card_instance.creature and find(state.creatures, value.name = card_instance.name and value.controller = state.nplayer)

		//we should already have suggested discards at this point, so
		//if the card is playable, the player can afford it straight-up
		where can_afford = (myplayer.suggest_discards(myplayer.calculate_cost(card_instance) - resources_from_discards()) = [])
		where possible_targets = card_instance.possible_targets(state, state.nplayer, current_targets))
	 ])) where card_instance = null|class card <- if(card.card_type is class card, card.card_type, null)",
	
	
	creature_clicked: "def(obj creature creature) ->commands execute(me, [
	    if(creature.creature_object and creature.creature_object.is_on_board,
		  [map(filter(level.chars, value is obj creature_status), value.destroy()),
		   spawn('creature_status', 300, 410, { creature_object: creature.creature_object })]
		  )
	  ])",
	
	can_use_ability: "def(class creature creature, string ability_name) ->bool
	 state.nplayer = state.current_player and observer = false and
	 state.nplayer = creature.controller and
	 ((not state.in_response_phase) or ability.is_response) and
	 ((not ability.exhausts_creature) or (not creature.is_exhausted)) and
	 (myplayer.suggest_discards(myplayer.calculate_cost(ability)) != null) and
	 creature.summoned and
	 ability.is_usable(state, creature)
	  asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)",
	 
	
	ability_clicked: "def(class creature creature, string ability_name) ->commands
	execute(me, [
	if(animation_up_to_date and can_use_ability(creature, ability_name),
		//we'll calculate our possible_targets:
		// - null means we play the ability right now
		// - [] means there are no valid targets and the ability can't play
		// - a list of targets means we invite the player to select their
		//   preferred target.
		if(possible_targets = null, 
	    [
		  tbs_send(client, 
		  {
			type: 'moves',
			state_id: me._state_id,
		    moves: (if(discards, discard_command(discards), []) where discards = myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name, targets: [], player_index: state.current_player}],
		  }) asserting client,
		  mark_sent_discards
		  ],
		 if(possible_targets = [], set_status_label('No available targets for ability', 'red'),
		    [
				[set(tile.selectable, if(tile.loc in possible_targets, true, false)) | tile <- level.chars, tile is obj tile],
				set(me._playing_card, -1),
				set(_targets_chosen, []),
				set(_playing_ability, construct('util.playing_activated_ability', {creature: creature, ability: ability})),
				
			]))
		where possible_targets = ability.possible_targets(state, creature, [])
	) asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)
	  ])",
	
	animate_draw_cards: "def(int ncards) ->commands
	  if(size(cards) >= ncards, map(cards, value.animate_draw(index)))
	  where cards = sort([card | card <- level.chars, card is obj card, card.in_hand, card.hand_index != null], a.hand_index > b.hand_index)",
	
	card_on_stack: "def(object card) ->class message.play_card_base|null
	   find(state.stack, value.stack_id = card.stack_id)
	     asserting _state",

	handle_animation_hint: "def(class animation.hint hint) ->commands [

	if(hint is class animation.play_card_hint,
	  ([
		reserve_animation_time(100),
		set(_spell_animation_time, 0),
		spawn('card', xloc, 300 + 40*size(state.stack),
		  {
			 card_type: hint.card,
			 controller: me,
			 in_hand: false,
			 allow_drag: true,
			 stack_id: hint.stack_id,
			 card_size: 2,
			 alpha: 0,
			 zorder: get_zorder('card_stack_base') + hint.stack_id,
		  },
			   [
			    if(_animated_spell_card, [
		   		    add(_spells_on_stack, [_animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(_animated_spell_card, child),
				[
				  if(windup_sound, sound_loop(windup_sound, lib.citadel.sound_volume(windup_sound), 0.5)),
				  set(_spell_windup_sound_being_played, windup_sound)
				] where windup_sound = hint.card.windup_sound,
				schedule(20, set(child.draw_primitives, filter(map(hint.targets, if(target_tile, {
					type: 'arrow',
					texture: 'ink.png',
					texture_scale: 0.2,
					arrow_head_length: 40,
					arrow_head_width: 0.4,
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value is obj tile and value.loc = context.value)), value != null))),

				  if(prev_card != null, child.animate_from(prev_card, 30))
				] where prev_card = find(level.chars, value is obj card and value.card_type = hint.card))
]
	  where xloc = if(size(state.stack)%2 = 1, level_width*0.15, level_width*0.85)
	  )
	),
	if(hint.type in ['fizzle', 'resolve'],
	  if(fizzling_card,
		if(hint.type = 'fizzle', fizzling_card.start_fizzle_animation(), fizzling_card.start_resolve_animation()))
		where fizzling_card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	)
   ]
",

	set_widgets_for_message: "def(class game game) ->commands
	  if(game.nplayer = game.current_player and observer = false, 
	    set_widgets(
	
		[
		{
			type: 'button',
			id: 'end_turn_button',
			x: level_width - 524,
			y: level_height - 568,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: if((not game.in_response_phase), if(game.has_unresolved_combat, 'Combat', 'End Turn'), 'End Response'), font: me.font, size: 16, color: me.color},
			on_click: def() execute(me, if(animation_up_to_date, [set_widgets([]),
			             set(me._playing_card, -1),
						 set(_playing_ability, null),
						 tbs_send(client, {
						  type: 'moves',
						  state_id: me._state_id,
						  moves: [end_turn_message]
						 })
						 ])),
		},
		
		]),
	    set_widgets([{
			type: 'label',
			text: game.players[game.current_player].name + q('s ) + if((not game.in_response_phase), 'Main Phase', 'Response Phase'),
			id: 'status_label',
			x: level_width - 524,
			y: level_height - 538,
			font: me.font, 
			align_h: 'center',
			size: 16, 
			color: me.color			
	   }]))",
	
	set_schedule_for_message: "def(class game game) ->commands [

	]",

	board_ypos: "int :: max(20, 100 - if(level_height < 900, 900 - level_height, 0))",

	spawn_tiles: "def(class game game) ->commands [
		 if(find(level.chars, value is obj tile) = null, 
		   map(range(game.rows), map(range(game.columns),
		     spawn('tile', 0, 0, { x: (level_width - 500)/2 + row*100, y: board_ypos + if(state.nplayer = 0, (state.columns-1) - col, col)*100, _controller: me, game_state: game, loc: [row,col] }) where col = value) where row = value),
		   [ [set(tile.game_state, game)] | tile <- level.chars, tile is obj tile]
		  )
	]
	",

	_cards_sorted_by_hand_position: { default: [], type: "[class card]" },
	_card_hand_positions: { default: [], type: "[int]", set: "[set(_cards_sorted_by_hand_position, map(sort(map(hand, {card: value, score: if(index < size(context.value), context.value[index], index)}), a.score < b.score), value.card)), set(_data, value)] where hand = state.players[state.nplayer].hand" },

	card_hand_position: "def(int hand_index) ->int if(hand_index < size(_card_hand_positions), _card_hand_positions[hand_index], hand_index)",
	position_to_hand_index: "def(int pos, int n=0) ->int if(card_hand_position(n) = pos, n, position_to_hand_index(pos, n+1))",

	set_card_hand_position: "def(int hand_index, int new_position) ->commands
	[
		set(me._card_hand_positions, remapped_positions),
	] where remapped_positions =
	   map(range(max(hand_index+1, size(_card_hand_positions), new_position+1)),
	       if(index = hand_index, new_position,
			  pos + if(pos < current_position and pos >= new_position, 1,
			           if(pos > current_position and pos <= new_position, -1, 0))
			 )
			 where pos = card_hand_position(index)
		  )
	  where current_position = card_hand_position(hand_index)
	",

	cards_in_hand_positions: "def([class card] hand) ->[{zorder: int, mid_x: int, mid_y: int, rotate: decimal, card_size: decimal}]
	  map(hand,
	   {
		 mid_x: int(level.dimensions[2] *(0.33 + ratio*0.33)) + if(card_obj != null and card_obj.keep, int(0.08*level.dimensions[2]), 0),
		 mid_y: int(level_height - 100 + if(level_height < 900, (900 - level_height)/6, 0)),
		 rotate: int(-5 + ratio*10.0),
		 card_size: 1.0,
		 zorder: get_zorder('card_in_hand_base') - card_hand_position(index)
	   }
		 where ratio = (card_hand_position(index) + 0.5)/size(hand)
		 where card_obj = null|obj card ::
		   find(level.chars, (value is obj card) and value.card_type = context.value)
	  )
	",

	find_card_obj: "def(class card card) ->null|obj card find(level.chars, (value is obj card) and value.card_type = card)",

	//_schedule_fg: { type: "obj citadel_controller.schedule_canvas", init: "object('citadel_controller.schedule_canvas', 0, 0, {zorder: 5})" },
	//_schedule_bg: { type: "obj citadel_controller.schedule_canvas", init: "object('citadel_controller.schedule_canvas', 0, 0, {zorder: 4})" },

	//_current_schedule_state: { default: 'none' },

	_schedule_obj: { type: "obj game_icon", init: "object('game_icon', 0, 0, {icon: 'sun.svg', size: 64 })" },

	update_schedule_objects: "def() -> commands [
		if(schedule_obj.user_info = null, [
			set(schedule_obj.user_info, 'schedule'),
			add_object(schedule_obj),
		]),

		if(state.is_day = false, set(schedule_obj.rotation, 0)),
		set(schedule_obj.event_handlers.process, if(state.is_day, q(add(me.rotation, 0.001)), q(null))),

		set(schedule_obj.mid_x, (level_width + 500)/2 + 100),
		set(schedule_obj.mid_y, 180),

		set(schedule_obj.icon, if(state.is_day, 'sun.svg', 'moon.svg')),
	] where schedule_obj = obj game_icon <- (find(level.chars, value is obj game_icon and value.user_info = 'schedule') or object('game_icon', 0, 0, { icon: 'sun.svg', size: 96}))",
	

	spawn_cards_in_graveyard: "def() ->commands [
		[remove_object(card) | card <- level.chars, card is obj card, card.in_graveyard],
		map(state.players,
		  map(reverse(player.visible_discard_pile),
	         spawn('card', 200 + 10*index, if(player_index = 0, level_height - 140 - index*10, 140 + index*10), {
				zorder: get_zorder('card_in_graveyard_base') + if(player_index = 0, -1, 1)*index,
				card_size: 0.8,
				controller: me,
				card_type: value,
				in_graveyard: true,
				red: 128,
				green: 128,
				blue: 128,
			 })
		  )
		where player = value
		where player_index = if(index = state.nplayer, 0, 1))
	]",

	spawn_cards_in_hand: "def() ->commands

	[
	   set(_card_hand_positions, map(hand, index(hand_sorted, value))),
	   bind_command(_spawn_cards_in_hand_internal),
	]
	    
		where hand_sorted =[class card] ::
		  sort(hand, if(keep_a != keep_b, keep_a < keep_b, if(new_a != new_b, new_a > new_b, index_a < index_b))
		    where new_a = (index_a = -1) where new_b = (index_b = -1)
		    where index_a = index(_cards_sorted_by_hand_position, a)
			where index_b = index(_cards_sorted_by_hand_position, b)
		    where keep_a = obj_a != null and obj_a.keep where keep_b = obj_b != null and obj_b.keep
		    where obj_a = find_card_obj(a) where obj_b = find_card_obj(b))
		where hand = [class card] :: state.players[state.nplayer].hand
	",

	_spawn_cards_in_hand_internal: "def() ->commands
	[
	  set(_card_regions, []),
	  map(state.players[state.nplayer].hand,
	    
	   [
	   if(card_obj != null,
	     [
		   set(card_obj.hand_index, index),
		   set(card_obj.in_hand, true),

		   if(card_obj != card_mouseover, [
			   animate(card_obj, {
				  mid_x: pos.mid_x,
				  mid_y: pos.mid_y,
				  rotate: positions[index].rotate
				}, {
				  duration: 10,
				}),

			   set(card_obj.zorder, pos.zorder),
			   set(card_obj.card_size, pos.card_size),
		   ])
		 ],

	     spawn('card', pos.mid_x, int(card_top),
		 {
			facing: 1,
			controller: me,
			in_hand: true,
			hand_index: index,
			zorder: pos.zorder,
			rotate: positions[index].rotate,
			card_size: pos.card_size,
			player: state.players[state.nplayer],
			card_type: value,
		 }, 
		 [
		    set(child.mid_x, pos.mid_x),
			set(child.mid_y, pos.mid_y),

			//make the new card animate its way in if it's just been drawn.
			fire_event(child, 'animate_draw'),

		  ])
		),
		add(_card_regions, [{left: int(pos.mid_x - card_width/2), right: int(pos.mid_x + card_width/2), top: int(card_top), card_num: index}] where card_width = 160)
		]
		 
		 where card_obj = null|obj card :: find_card_obj(card_instance)
		 where pos = positions[index]
		 where card_instance = class card :: value
	   ) where positions = cards_in_hand_positions(state.players[state.nplayer].hand),

	   set(me._card_hand_top, card_top),
	]
  where card_top = decimal :: max(board_ypos + 500 + 8, level_height - 300)
  where hand_size = int :: size(state.players[state.nplayer].hand)
	",

	spawn_chat_widgets: "def() ->commands [
		if(_chat_area = null, [set(_chat_area, w), add_object(w)]),
		set(w.x, level_width - chat_width - 40),
		set(w.y, 300),
		set(w.chat_width, chat_width),
		debug('ZZZ: chat: ' + chat_width),
	] where w = if(_chat_area, _chat_area, object('chat_area', 0, 0, { chat_width: chat_width }))
	  where chat_width = 300 - if(level_width < 1200, 1200 - level_width, 0)/2",

	spawn_opponent_cards: "def() ->commands [
	  //get rid of existing opponent cards that should no longer be there.
	  [ if(card.card_type.orphaned_by_update,
	  	   animate(card, {
			mid_x: 60,
			mid_y: 204,
			scale: 0.5,
			rotate: 0,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   }),
		   remove_object(card))

	   | card <- level.chars, card is obj card, card.in_opponent_hand, find(hand, value = card.card_type) = null],

	  //create new card objects and update existing ones.
	  map(pos, if(obj = null, spawn('card', 0, 0, {
			 zorder: value.zorder,
			 rotate: -value.rotate,
			 show_back: observer = false,
			 in_opponent_hand: true,
			 card_type: hand[index],
			 controller: me,
			 mid_x: 80,
			 mid_y: 80,
			 rotate: 0,
			 upside_down: 1,
			 scale: 0.4,
		},
		[
			animate(child, {
				mid_x: value.mid_x,
				mid_y: level_height - value.mid_y - 130 - if(level_height < 900, 900 - level_height, 0)/3,
				rotate: -value.rotate,
				scale: if(observer, 0.4, 1.0),
			}, {
				duration: 25,
			}),
		]),

		[
			animate(obj, {	
				mid_x: value.mid_x,
				mid_y: level_height - value.mid_y - 130 - if(level_height < 900, 900 - level_height, 0)/3,
				rotate: -value.rotate,
			}, {
				duration: 10,
			}),
			set(obj.zorder, value.zorder),
		]

		)

	  where obj = find(level.chars, value is obj card and value.in_opponent_hand and value.card_type = hand[context.index]))
	]
      where pos = cards_in_hand_positions(hand)
	  where hand = state.players[(state.nplayer+1)%2].hand
	",

	_calculate_end_of_turn_state: "def(class game state) ->class game
		if(state.current_choice != null or
		   (not state.in_response_phase) and
		   state.has_unresolved_combat = false,
		   state, _calculate_end_of_turn_state(get_modified_object(state, def(class game g) g.end_turn())))
	",

	spawn_game_icons: "def(class game state) ->commands [
		[remove_object(icon) | icon <- level.chars, icon is obj game_icon, icon.user_info = 'status_icon'],
		[spawn('game_icon', pos[0]+50, pos[1] + if(state.nplayer != c.controller, 100, 0), {size: 48, zorder: get_zorder('status_icon'), icon: 'crossed-axes.svg', user_info: 'status_icon'}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.is_engaged(state)],

		[spawn('game_icon', pos[0]+50, pos[1] + 40, {size: 48, zorder: get_zorder('status_icon'), icon: 'bowman.svg', user_info: 'status_icon'}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.is_exhausted = false, c.is_engaged(state) = false, c.range > 0, size(c.targets_attacking(state)) > 0],

		[map(filter(map(c.status_effects, icon_info[value]), value != null),
		     spawn('game_icon', pos[0]+90 - index*4 - index*index*2, pos[1] + 50 - 20*index,
			   {size: 24, user_info: 'status_icon', zorder: get_zorder('status_icon')} + value))
		  where pos = get_tile_pos(c.loc) | c <- state.creatures]
		     where icon_info = {string -> map} <-
			     get_document('data/status_effect_icons.cfg'),

		if(end_of_turn_state != null,
		   [ spawn('game_icon', pos[0]+50, pos[1] + 40, {size: 48, zorder: get_zorder('status_icon'), icon: 'skull-crack.svg', alpha: 0, user_info: 'status_icon'}, [map(range(20), set(child.alpha, value*10))]) where pos = get_tile_pos(c.loc) | c <- state.creatures, find(end_of_turn_state.creatures, c.summon_id = value.summon_id) = null]),
	]",
	
	get_tile_pos: "def(Loc pos) ->Loc [
		(level.dimensions[2] - 500)/2 + pos[0]*100,
		board_ypos + if(state.nplayer = 0, (state.columns-1) - pos[1], pos[1])*100,
	]",

	_resource_y_pos: "def(bool is_local, int nresource, int max_resource) ->int
	   if(is_local, level_height - 380 - nresource*54,
			        260 + nresource*54)",

	_xp_objects: { type: "[custom_obj]", default: [] },
	
	_spawn_xp_objects: "def(class game state, int xpos, int ypos, {resource: int, lvl: int, xp: int, xp_needed: int} info) ->commands [
		spawn('game_icon', xpos + 28, ypos + 28, {icon: 'school-' + SCHOOL_NAMES[info.resource] + '.svg', size: 48, zorder: get_zorder('xp_objects')}, [add(me._xp_objects, [child])]),
		spawn('canvas', 0, 0, { zorder: get_zorder('xp_objects')}, [
			child.draw(250, 60, [
				//c.rectangle(0,0,250,60), c.set_source_rgba(0,0,0,0.2), c.fill(),

				c.set_font('Roboto_Condensed/RobotoCondensed-Bold.ttf'),

				c.save(),

				c.set_font_size(14),
				c.translate(58, 36),

				c.text_path('Lvl'),
				c.set_source_rgba(1, 1, 1, 1),
				c.fill(),

				c.restore(),

				c.save(),
				c.set_font_size(36),

				c.translate(74, 42),

				c.text_path(str(info.lvl)),
				c.set_source_rgba(1, 1, 1, 1),
				c.fill(),

				c.restore(),

			] +
			fold(map(range(info.xp_needed), [
				c.arc(110 + index*28, 30, 10, 0, 2*3.14),
				if(index >= info.xp, c.set_source_rgba(0.4, 0.4, 0.4, 1),
					switch(info.resource,
					GOLD, c.set_source_rgba(0.5, 0.5, 0, 1),
					BLOOD, c.set_source_rgba(0.8, 0.3, 0.3, 1),
					FOOD, c.set_source_rgba(0.0, 0.5, 0, 1),
					SCROLLS, c.set_source_rgba(0.3, 0.3, 0.8, 1),
					FAITH, c.set_source_rgba(1.0, 1.0, 1.0, 1),
					c.set_source_rgba(0.1, 0.1, 0.6, 1),
					)
				),
				c.fill(),
			]), a+b)
			
			) where c = canvas(),
			set(child.x, xpos),
			set(child.y, ypos),
			add(me._xp_objects, [child]),
		]),
	]",

	display_player_xp: "def(class game state) ->commands [
	  map(_xp_objects, remove_object(value)),
	  set(_xp_objects, []),

	  map(state.players, 
	    
		map(resources,
		  _spawn_xp_objects(state, 40, ypos, resource)
		  where resource = value
		  where ypos = _resource_y_pos(is_local, index, size(resources))
		)

	    where resources = sort(filter(map(p.resource_level, {resource: key, lvl: value, xp: p.xp_level[key], xp_needed: p.xp_needed[key]}), value.lvl > 0), a.lvl < b.lvl or a.lvl = b.lvl and a.xp < b.xp)
	    where is_local = (nplayer = state.nplayer)
		where p = value
	    where nplayer = index
	  )
	]",

	_mana_x_pos: "def(int nmana, int max_mana) ->int
	   40 + nmana*spacing where spacing =  int(min(40, (level_width*0.2)/max_mana))",
	
	_processed_animation_hints: { type: "[class animation.gain_mana_hint]", default: [] },

	display_player_mana: "def(class game state) ->commands [
	   set(_processed_animation_hints, filter(state.animation_hints, value is class animation.gain_mana_hint)),

	   set(_mana_symbol_objects, []),
	   map(state.players, map(range(max(value.resources, 0)), spawn('game_icon', _mana_x_pos(index, context.value.resources), if(context.index != state.nplayer, 100, 600), { icon: 'mana.svg', size: 32, user_info: 'player_mana', zorder: get_zorder('mana_symbols') },
	     [
		   if(nplayer = state.nplayer, add(_mana_symbol_objects, [child])),
		 
		   //if we have an animation hint regarding this mana item, we
		   //animate its entry
		   if(anim_index < size(mana_anim), [
			 set(child.mid_x, source_pos[0]),
			 set(child.mid_y, source_pos[1]),
			 set(child.alpha, 0),
			 animate(child, {
				mid_x: child.mid_x,
			 }, {
				duration: 40,
				easing: 'swing',
			 }),

			 animate(child, {
				mid_y: child.mid_y,
			 }, {
				duration: 30,
				easing: 'swing',
			 }),

			 animate(child, {
				alpha: 255
			 }, {
				duration: 6
			 }),
		   ] where source_pos = if(anim.move_from is Loc,
		      map(get_tile_pos(anim.move_from), value+50),
			  if(card_obj != null, [card_obj.mid_x, card_obj.mid_y],
					               [child.mid_x, child.mid_y])
			  where card_obj = find(level.chars, value is obj card and value.card_type.draw_id = anim.card_from))
		     where anim = mana_anim[anim_index])
			   where anim_index = state.players[nplayer].resources - index - 1
		 ]))
	   where mana_anim = [class animation.gain_mana_hint] ::
	          filter(state.animation_hints,
			         value is class animation.gain_mana_hint and
					 value.player = nplayer and
					 find(_processed_animation_hints, context.value = value) = null)
	   where nplayer = index)
	]",

	display_game_status: "def(class game state) ->commands [
		[remove_object(lb) | lb <- level.chars, lb is obj citadel_controller.label, lb.user_info = 'game_status'],

		spawn('citadel_controller.label', 0, 0, {
			text: myplayer.name,
			user_info: 'game_status',
			xpos: (level_width - 500)/2 - 120,
			ypos: 570,
			size: 24,
		}),

		spawn('citadel_controller.label', 0, 0, {
			text: enemy_player.name,
			user_info: 'game_status',
			xpos: (level_width - 500)/2 - 120,
			ypos: 110,
			size: 24,
		}),

		spawn('citadel_controller.label', 0, 0, {
			text: state.players[state.current_player_turn_index].name + q('s Turn) + ((state.turn/size(state.players))+1),
			user_info: 'game_status',
			xpos: (level_width + 500)/2 + 60,
			ypos: 130,
			size: 24,
		}),

	]",

	display_player_life: "def(class game state) ->commands [

		map(state.players, map(range(max(value.life, 0)), spawn('game_icon', (level_width - 500)/2 - 50 - index*40, if(context.index != state.nplayer, 140, 600), { icon: 'life.svg', size: 32, user_info: 'player_life' })))
	]",
	
	display_choice: "def(class game state) ->commands [
	  if(_choice_object, [_choice_object.destroy(), set(_choice_object, null)]),
	  if(state.current_choice and state.current_choice.player_index = state.nplayer,
	  	spawn('choice_controller', 0, 0,
		{
			facing: facing,
			game: state,
		}, [
			set(_choice_object, child),
			debug('spawned choice'),
		 ]))
    ]",

	update_log: "def(class game game) ->commands
	 log_controller.set_log([string]<- game.log, if(_state, myplayer, null))
	  asserting log_controller
	  where log_controller = find(level.chars, value is obj log_controller)",
	
	bdk: "def(string bot_name) ->commands [
		if(_bdk_controller, remove_object(_bdk_controller)),
		spawn('bdk_controller', 0, 0, { controller: me }, [
			child.load(bot_name),
			set(_bdk_controller, child),
		]),
	]",

	force_submit_deck: "def([string] deck) ->commands
		execute(me, tbs_send(client, {type: 'submit_deck', deck: deck, force: true}))",
},

on_generate_mouseover_card: "mouse_enter_card(obj card<- arg.card)",

on_create: "[ 
	fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),
	console_output_to_screen(false),
	
	if(observer,
	[
		set(me._client, cl),
		tbs_send(cl, {type: 'observe_game', user: USERNAME}),
	] where cl = tbs_client(game_server_address, game_server_port, session_id),

	if(size(get_module_args()) > 0, 
	[set(me._client, cl),
	tbs_send(cl, {type: 'start_game'}), debug('game created')] where cl = tbs_client(string<- get_module_args().server_address, string|int<- get_module_args().server_port, int<- get_module_args().session_id),
	if(game_created, 
	[set(me._client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		where cl = tbs_client(game_server_address, game_server_port, session_id),
	set_widgets(
	[{
		type: 'grid',
		columns: 1,
		children: [

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Join Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(me._client, cl),
				             tbs_send(cl, {type: 'request_updates', state_id: _state_id})]
				         where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 2))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Create Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(me._client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Play vs Bot', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(me._client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', bot: true, bot_type: 'evolutionary', args: {rules: 'evo/evolution12.cfg'}, session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

		]
	},
	]))))]
",

on_update_discard_and_deck: "[
	map(_deck_obj, value.set_label(str(size(state.players[index].deck)), me.font)),
	map(_discard_obj, if(value, value.set_label(str(size(state.players[index].discard_pile)), me.font))),
]",

on_window_resize: "[
debug('ZZZ RESIZE: ' + [new_width,new_height]),
	[ [add(card_back.x, delta_w)]
	| card_back <- level.chars,
	  card_back is obj citadel_controller.card_back,
	  card_back.player_index = 1],

	[ tile.destroy() | tile <- level.chars, tile is obj tile ],

    [remove_object(heart) | heart <- level.chars, heart is obj game_icon, heart.user_info in ['player_life', 'player_mana', 'player_level']],

	set(level.dimensions, [0,0,new_width,new_height]),

	fire_event('dimensions_updated'),

] where delta_w = new_width - level_width
  where delta_h = new_height - level_height
  where card_width = min(135*card_scale, if(hand_size, card_area/hand_size, 100))
  where card_scale = max(1.0, decimal(card_area)/decimal(1024 - 300))
  where card_area = new_width - 300
  where new_width = max(int<- arg.width,1024)-1
  where new_height = max(int<- arg.height,768)-1
  where hand_size = count(level.chars, value is obj card and value.in_hand)",

on_dimensions_updated: "[
	spawn_chat_widgets(),

	if(_last_state_message, [
        display_choice(state),
		set_widgets_for_message(state),
		set_schedule_for_message(state),
		spawn_tiles(state),
		adapt_input_state(),
		display_game_status(state),
		display_player_life(state),
		display_player_mana(state),
		display_player_xp(state),
		update_log(state),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		spawn_opponent_cards(),
		update_schedule_objects(),

		fire_event('game_updated'),
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0,
	       { controller: me, game_state: state, facing: 1, creature_object: creature.creature_object })
	          asserting creature.creature_object]
	| creature <- level.chars,
	  creature is obj creature,
	  creature.creature_object.is_on_board ]
]",

on_update_spells_on_stack: "
 [
  set(_spells_on_stack, survivors),
  map(leaving, execute(value, [
	if(_spell_windup_sound_being_played, stop_sound(_spell_windup_sound_being_played, 0.5)),
	[schedule(n, [
	  map(value.draw_primitives, set(value.color, [255,0,0,255-n*10]))])
	  | n <- range(25)],
	schedule(26, remove_object(value)),
  ]))
 ]
  where leaving = filter(_spells_on_stack, not card_on_stack(value))
  where survivors = filter(_spells_on_stack, card_on_stack(value))",

on_update_game: "
   if((not force_process) and
      (_game_state_queue != [] or level.cycle < _animation_end_time),
	 add(_game_state_queue, [message]),

     if(state_id > _processed_state_id,
	 [
	    if(_state != null, [update_object(_state, game_state)],
				           set(_state, game_state)),

	    set(me._processed_state_id, state_id),

	    set(_last_state_message, message),

		set(end_of_turn_state, _calculate_end_of_turn_state(game_state)),

		fire_event('game_updated'),
     ]
     where game_state = class game<- message.state
))
     where state_id = int<- message.state_id
     where message = map<- arg.message,
         force_process = null|bool<- arg.force_process
",

on_game_updated: "[
	 	adapt_input_state(),

		[
			debug('game updated'),
		    map(_deck_obj + _discard_obj + _hand_obj + _level_obj,
			    if(value, remove_object(value))),
			set(_deck_obj, deck_obj),
			set(_discard_obj, discard_obj),
			map(discard_obj, if(value, set(value.controller, me))),
			set(_hand_obj, hand_obj),
			set(_level_obj, level_obj),
			map(discard_obj, if(value, set(value.player_index, index))),
			map(deck_obj, set(value.player_index, index)),
			map(hand_obj, set(value.player_index, index)),
			map(level_obj, set(value.player_index, index)),
			map(hand_obj, set(value.animation, 'hand')),
			map(level_obj, set(value.animation, 'hand')),
			map(deck_obj, set(value.scale, 0.5)),
			map(discard_obj, if(value, set(value.scale, 0.5))),
			map(hand_obj, set(value.scale, 0.5)),
			map(level_obj, set(value.scale, 0.5)),
			map(deck_obj, add_object(value)),
			map(discard_obj, if(value, add_object(value))),
			map(hand_obj, add_object(value)),
			map(level_obj, add_object(value)),
		] where deck_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', 60, if(index = game_state.nplayer, level_height - 84, 80), 1, {controller: me} ))
		  where discard_obj = map(range(size(game_state.players)), if(size(game_state.players[index].discard_pile) > 0, object('citadel_controller.card_back', 60, if(index = game_state.nplayer, level_height - 200, 204), 1, {controller: me} )))
		  where hand_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 250, level_width - 250), 450, 1, {controller: me} ))
		  where level_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 250, 1, {controller: me} )),

	 	reserve_animation_time(10),
		map(animation_hints, handle_animation_hint(value)),
		set(_animation_hints_id, game_state.animation_hints_id),
		set(_furthest_animation_hint, size(game_state.animation_hints)),
		debug('SET NEW STATE'),

    	[remove_object(heart) | heart <- level.chars, heart is obj game_icon, heart.user_info in ['player_life', 'player_mana', 'player_level']],

		display_game_status(game_state),
		display_player_life(game_state),
		display_player_mana(game_state),
		display_player_xp(state),
		display_choice(game_state),
	    if(creature_status,
			if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
			   where creature = find(game_state.permanents,
			        value.summon_id = creature_status.creature_object.summon_id)
				
				) where creature_status = find(level.chars, value is obj creature_status),
	    [

		//cards to discard.
		[
		   //animate to the discard pile and then disappear.
		   animate(card, {
			mid_x: 60,
			mid_y: level_height - 200,
			scale: 0.5,
			rotate: 0,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   })

		| card <- level.chars,
		  card is obj card, card.in_hand,
		  find(myplayer.hand, value = card.card_type) = null
		],
		
		[card.destroy() | card <- level.chars,
		 card is obj card,
		 card.in_hand = false and card.in_opponent_hand = false and
		 card.card_type.orphaned_by_update
		],

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(game_state)
	  ],

	  if(game_state.in_response_phase and game_state.nplayer = game_state.current_player,
		[

	      set(_response_pause_counter, -1),
		  set_status_label(if(game_state.stack, '', 'Combat phase -- ') + 'Response phase', 'white', 150),

	   //   set(_response_pause_counter, 150),
	//	  set_status_label(if(game_state.stack, '', 'Combat phase -- ') + 'Press SPACE if you want to respond', 'white', 150),
		],

		[
			set(_response_pause_counter, -1),
		]
	  ),

	  set_widgets_for_message(game_state),
	  set_schedule_for_message(game_state),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(game_state.creatures,
		                     value.summon_id = creature.summon_id) or
							 game_state.graveyard[creature.summon_id]
	    where creature = obj.creature_object
		| obj <- level.chars, obj is obj creature],
		value), 30, 0)), 

	  map(filter(level.chars, value is obj creature and
	          find(game_state.permanents,
			       context.value.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = game_state.graveyard[value.creature_object.summon_id]), 
	  [fire_event(card, 'game_updated') | card <- level.chars, card is obj card],
	  [
	    spawn_opponent_cards(),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		update_schedule_objects(),
		if(drawn_cards > 0, reserve_animation_time(30 + 10*size(game_state.players[game_state.nplayer].hand)))
	  ]
		  where drawn_cards =
		    fold([hint.ncards | hint <- animation_hints,
		                        hint is class animation.draw_cards_hint,
							    hint.player = game_state.nplayer], a+b, 0),
	  

	  map(game_state.permanents,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     [set(obj.game_state, state),
			  set(obj.creature_object, value),
			 if(card_rules, set(value.rules, card_rules))],
	      
		  //create a new object to represent this creature.
		  [debug('SPAWN CREATURE: ' + value.name),
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: value,
				  game_state: state,
				  controller: me,
				},
				[if(card_rules, set(value.rules, card_rules)),
				 if(move_hint != null, child.teleport_and_walk_from(move_hint.move_from)) where move_hint = find(animation_hints, value is class animation.move_hint and value.creature = context.value)] asserting value)])
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value is obj creature and
		                                value.creature_object.summon_id = context.value.summon_id) where card_rules = if(doc and doc.rules, string<- doc.rules, '')
										where doc = map|null<- lib.json.get_document_map('data/cards.cfg')[value.name]),
	
	  spawn_game_icons(state),
										
	  if(game_state.winner, set_widgets(me, {
		type: 'dialog',
		background_alpha: 255,
		background_frame: 'empty_window',
		zorder: get_zorder('winner_dialog'),
		rect:[-50, -50, 500, 100],
		children: [
			{
				type:'grid', 
				columns:1, 
				xy:[0,20], 
				column_widths:500, 
				column_alignments:'center', 
				children: [
					{
						type: 'label',
						size: 40, 
						zorder: get_zorder('winner_dialog'),
						text: game_state.winner.name + ' Wins!', 
						font: 'RobotoCondensed-Bold', 
						color: 'red'
					},

					{
						type: 'button',
						label: {type: 'label', font: font, size: 18, color: font_color, text: 'Leave Game'},
						on_click: bind(me.return_callback, game_state.winner = game_state.players[0]),
					},
				]
			}
		],
	  })),

	  update_log(game_state),


fire_event('update_discard_and_deck')

]
  where animation_hints =
   if(_animation_hints_id != game_state.animation_hints_id,
	  game_state.animation_hints,
	  game_state.animation_hints[_furthest_animation_hint:])
  where game_state = state
",

on_message_received: "[
  trigger_garbage_collection(),
  switch(message.type,
		 'chat_message',
		 [if(_chat_area, _chat_area.message_received(nick, text)) where text = string<- message.text where nick = string<- message.nick],
		 'game_created',
         [set(me._client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = tbs_client(game_server_address, game_server_port, 1),

         'game',
		 if(game_state.players[game_state.nplayer].deck_submitted = false,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
			if(selected_deck and user_decks, [
				map(user_decks[selected_deck].cards, null asserting lib.json.get_document_map('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
				tbs_send(me.client, {type: 'submit_deck', deck: deck}) asserting deck,
				] where deck = user_decks[selected_deck].cards,
				null asserting selected_deck | 'must specify a deck')
		  ]
		    where user_decks = lib.citadel.get_decks(),
	
	    [
	    set(me._state_id, max(_state_id, int<- message.state_id)),
		fire_event('update_game', {message: message})
		]
	   ), // end 'game' case.

         //default case.
         [debug('got message: ', message)]) asserting message.type != 'invalid_session',
		 fire_event('request_updates')]
	 where game_state = class game<- message.state
	 where message = map<- arg.message",

on_request_updates: "if(client.in_flight = 0,
					      [debug('request_updates: ' + _state_id), tbs_send(client, { type: 'request_updates', state_id: _state_id })])",
on_connection_error: "[debug('message error', string<- arg.error), fire_event('request_updates')]",

on_process: "
 [
  [
  if(card_mouseover and card_mouseover.in_hand,
	map(_mana_symbol_objects, if(index < myplayer.calculate_cost(card_mouseover.card_type), add(value.rotate, 4))),
  ),

  if(card_mouseover and card_mouseover.in_hand and card_mouseover.hand_index != card_over,
     mouse_leave_card(card_mouseover)),
  if(card_over != -1 and (card_mouseover = null or card_mouseover.hand_index != card_over),
	 mouse_enter_card(find_or_die(level.chars, value is obj card and value.in_hand and value.hand_index = card_over))
  )
  ] where card_over = _hand_card_moused_over,

  set(me._prev_ctrl_keys, level.player.ctrl_keys),

  if(_state and _state.nplayer = _state.current_player and
     (enter_key in level.player_info.ctrl_keys) and
	 (not (enter_key in _prev_ctrl_keys))
	 and (_chat_area = null or _chat_area.has_focus = false), [
	 	if(_spell_animation_time < 78,
		   set(_spell_animation_time, 78)),
		set_widgets([]),
		set_status_label(''),
		tbs_send(client, {
		 type: 'moves',
		 state_id: _state_id,
		 moves: [end_turn_message]
		})
	  ]
     ) where enter_key = 13,

  if(_response_pause_counter > 0, [
	  add(_response_pause_counter, -1),
	  if(' ' in level.player_info.ctrl_keys, [
		set(_response_pause_counter, -1),
		set_status_label('Take your time to think about how you want to respond', 'white'),
	  ])
  ]),
  if(_response_pause_counter = 0, [
	set(_response_pause_counter, -1),
	tbs_send(client, {
	 type: 'moves',
	 state_id: _state_id,
	 moves: [end_turn_message]
	}),
  ]),
  if(_animated_spell_card,
	 if(_spell_animation_time >= 100, [
			 debug('REMOVE SPELL: ' + if(_animated_spell_card in level.chars, true, false)),
		add(_spells_on_stack, [_animated_spell_card]),
		set(_animated_spell_card, null),
		set(_spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(_spell_animation_time = 80 and (level.player_info.ctrl_mod_key in [1,2]),
	     reserve_animation_time(20),
	 [
	    add(_spell_animation_time, 1),
		if(_spell_animation_time <= 20, [
			set(_animated_spell_card.alpha, new_alpha),
			map(_animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = if(_spell_animation_time <= 20, _spell_animation_time*22, (100 - _spell_animation_time)*22)
			),
	 ]))), //end animated_spell_card

  if(_game_state_queue != [] and level.cycle >= _animation_end_time,
	[
	  set(_game_state_queue, _game_state_queue[1:]),
	  fire_event('update_game', {message: _game_state_queue[0], force_process: true})
	]),
    if(client, tbs_process(client))
 ]",

on_end_anim: "animation('normal')",
zorder: 50,
timer_frequency: 10,
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [

	{
		id: "schedule_canvas",
		animation: [
			{
				id: "day",
				image: "schedule/schedule-afternoon.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "none",
				image: "schedule/schedule-afternoon.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "dawn",
				image: "schedule/schedule-dawn.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "night",
				image: "schedule/schedule-secondwatch.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "dusk",
				image: "schedule/schedule-dusk.png",
				rect: [0,0,123,38],
				scale: 1,
			},
		],
	},

	{
		id: "card_back",
		animation: [
			{
				id: "normal",
				image: "card-back.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "front",
				image: "card-citadel.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "hand",
				image: "card-hand.png",
				rect: [0,0,145,203],
				scale: 1,
			},

		],

		properties: {

			set_label: "def(string text, string font) ->commands execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'black',
				x: 74,
				y: 80,
			}]))",

			set_text: "def([string] text_list, string font) ->commands execute(me, set_widgets(
			  map(text_list, {
			  	type: 'label',
				text: value,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'white',
				x: 74,
				y: 40 + index*26
			  })))",

			set_widgets: "def([map] widgets) ->commands execute(me, set_widgets(widgets))",

			player_index: { default: 0 },
			controller: { type: "obj citadel_controller" },
		},

		on_mouse_enter: "if(controller, controller.mouse_enter_discard(player_index))",
		on_mouse_leave: "if(controller, controller.mouse_leave_discard(player_index))",
		on_click: "if(controller, controller.mouse_click_discard(player_index))",
	},

	{
		id: "status_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			init_label: "def(string text, Color color, int card_top) ->commands
			execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				color: color,
				size: 18,
				x: 100,
				y: card_top - 20,
			}]))",

			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		},
	},

	{
		id: "label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			text: { type: "string" },
			font: { default: "RobotoCondensed-Regular" },
			color: { type: "Color", default: "black" },
			size: { default: 18 },

			user_info: { type: "any" },

			xpos: { default: 0 },
			ypos: { default: 0 },

		},

		on_create: "
		set_widgets([{
			type: 'label',
			text: text,
			font: font,
			color: color,
			size: size,
			x: xpos,
			y: ypos,
		}])",
	},

	{
		id: "turn_schedule",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			create_label: "def(string text) ->map {
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				size: 12,
				color: 'gray',
			}",

			state: {
				type: "null|class game",
				set_type: "class game",
				set: "execute(me, [
					set(_data, value),
					set_widgets([{
						type: 'grid',
						columns: 2,
						children: [
							create_label(''),
							create_label(value.players[value.turn%size(value.players)].name) + {color: 'white'},
							create_label(''),
							create_label('Turn ' + ((value.turn/size(value.players))+1)) + {color: 'white'},
							create_label(if(value.has_unresolved_combat, '-> ', '')),
							create_label('Main Phase'),
							create_label(''),
							create_label('Move Phase') + {color: 'dim_gray'},
							create_label(if(value.precombat_phase, '-> ', '')),
							create_label('Combat Phase'),
							create_label(if(value.has_unresolved_combat = false and not value.precombat_phase, '-> ', '')),
							create_label('Main Phase'),
						],
					}])
				])"
			}
		}
	}

],
}
