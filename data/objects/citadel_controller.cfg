{
id: "citadel_controller",
next_animation: "'normal'",
is_human: true,
always_active: true,
hidden_in_game: true,
vars: {
	last_triggered: -400,
	client: null,
	state: null,
	state_id: -1,
	processed_state_id: -1,
	card_preview: null,
	card_preview_for: null,
},

tmp: {
	playing_card: -1,
	targets_chosen: [],
	active_targets: [],
	animation_move_time: 0,
	animation_end_time: -1,
	game_state_queue: [],
	furthest_animation_hint: 0,
	animated_spell_card: null,
	spell_animation_time: 0,
},

properties: {
	animation_up_to_date: "vars.processed_state_id = vars.state_id",
	reserve_animation_time: "def(ncycles) if(end_time > tmp.animation_end_time, set(me.tmp.animation_end_time, end_time)) where end_time = level.cycle + ncycles",
	myplayer: "vars.state.players[vars.state.nplayer]",

	hand_index_after_discarding: "def(nhand) nhand - count(level.chars, value.type = 'card' and value.vars.discarded and value.vars.hand_index < nhand)",

	mark_sent_discards: "
	[set(card.vars.sent_discard_msg, true) |
	  card <- level.chars, card.type = 'card', card.vars.discarded = true]
	",

	discard_command: "
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = [card.vars.hand_index |
	    card <- level.chars, card.type = 'card', card.vars.discarded = true,
		                     card.vars.sent_discard_msg = false]
	",

	remove_preview_card: "def(card) if(vars.card_preview and (vars.card_preview_for = card or card = null), [if(vars.card_preview.vars.creature, vars.card_preview.vars.creature.destroy()), remove_object(vars.card_preview), set(vars.card_preview, null)])",

	/*mouse_enter_card: "def(card) execute(me, [
	  remove_preview_card(null),
	  set(vars.card_preview_for, card),

	  spawn('card', 760, 120, 1, [
	     set(vars.card_preview, child),
		 set(child.vars.in_hand, true),
		 set(child.scale, 2.0),
		 set(child.vars.player, myplayer),
		 set(child.card_type, card.card_type)
	  ])
	])",*/

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(tile) if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
		 set(vars.card_preview_for, tile.vars.loc)
	   ]) where card = get_document('data/cards.cfg')[creature.name])
	      where creature = vars.state.creature_at_loc(tile.vars.loc)",
	mouse_leave_tile: "def(tile) remove_preview_card(tile.vars.loc)",

	mouse_enter_log: "def(index)
	   if(items = null, if(is_string(vars.card_preview_for),
			           remove_preview_card(vars.card_preview_for)),
		[
//			 mouse_enter_card({card_type: construct('card',
//			    get_document('data/cards.cfg')[items[1]])}),
			 set(vars.card_preview_for, items[1])
	    ])
	    where items = if(index = -1, null,
		   regex_match(vars.state.log[index], '(.*) plays (.*)'))",

	card_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	  if(card.vars.discarded,
	  [card.set_discarded(false), add(myplayer.resources, -1)],
	  [tile_clicked(null), choose_targets_for_card(card, [])]))",
	card_right_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	 if(not card.vars.discarded, [
	   tile_clicked(null),
	   add(myplayer.resources, 1),
	   card.set_discarded(true)
	]))",
	      
	tile_clicked: "def(tile) [
	   execute(me, 	map(level.chars, if(value.type = 'tile', set(value.selectable, false)))),
	   if(tile and tmp.playing_card != -1, choose_targets_for_card(find(level.chars, value.vars.hand_index = tmp.playing_card), tmp.targets_chosen + [tile.vars.loc]))
	 ]",
	
	choose_targets_for_card: "def(card, current_targets) execute(me, [
	  debug('choose targets ' + current_targets),
	   if(vars.state.nplayer = vars.state.current_player and (vars.state.response_phase = 0 or card.card_type.is_response),
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [],
		      if(possible_targets = null,
				[
				 tbs_send(vars.client, {
				   type: 'moves',
				   state_id: vars.processed_state_id,
				   moves: discard_command + [{type: 'play_card', index: hand_index_after_discarding(card.vars.hand_index), targets: current_targets}]
				  }),
				 mark_sent_discards,
				 set(tmp.playing_card, -1)
				],
			    [
				 map(level.chars, if(value.type = 'tile', set(value.selectable, value.vars.loc in possible_targets))),
				 set(tmp.playing_card, card.vars.hand_index),
				 set(tmp.active_targets, []),
				 set(tmp.targets_chosen, current_targets)
				]
					 ),
			  [
			  	debug('no valid targets')
			  ])]
		where can_afford = myplayer.can_afford(card.card_type.school, card.card_type.cost, card.card_type.loyalty_cost)
		where possible_targets = card.card_type.possible_targets(vars.state, vars.state.nplayer, current_targets))
	 ])",
	
	
	creature_clicked: "def(creature) execute(me, [
	    if(creature.vars.creature_object.loc != null,
		  [map(filter(level.chars, value.type = 'creature_status'), value.destroy()),
		   spawn('creature_status', 600, 0, 1, [set(child.creature_object, creature.vars.creature_object)])]
		  )
	  ])",
	
	can_use_ability: "def(creature, ability_name)
	 vars.state.nplayer = vars.state.current_player and
	 (vars.state.response_phase = 0 or ability.is_response) and
	 myplayer.can_afford(ability.school, ability.cost, ability.loyalty_cost) and creature.summoned and
	 ability.is_usable(vars.state, creature)
	  asserting ability
	  where ability = find(creature.abilities, (not is_string(value)) and value.name = ability_name)",
	 
	
	ability_clicked: "def(creature, ability_name)
	execute(me, [
	if(animation_up_to_date and can_use_ability(creature, ability_name),
	    [
		  tbs_send(vars.client, 
		  {
			type: 'moves',
			state_id: vars.state_id,
		    moves: discard_command + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name}],
		  }),
		  mark_sent_discards
		  ]
	) asserting ability
	  where ability = find(creature.abilities, (not is_string(value)) and value.name = ability_name)
	  ])",

	handle_animation_hint: "def(hint) if(hint.type = 'play_card', [
		reserve_animation_time(100),
		set(tmp.spell_animation_time, 0),
		spawn('card', xloc, 240, 1,
			   [if(tmp.animated_spell_card, remove_object(tmp.animated_spell_card)),
			    set(tmp.animated_spell_card, child),
		        set(child.vars.in_hand, false),
		        set(child.vars.hand_index, 0),
			    set(child.scale, 2),
			    set(child.alpha, 0),
			    set(child.zorder, 1000),
				set(draw_primitives, map(hint.targets, if(target_tile, {
					type: 'arrow',
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   200 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   200 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value.vars.loc = context.value))),
			    set(child.card_type, construct('card', get_document('data/cards.cfg')[hint.card_type]))])
])
	  where xloc = if(find(hint.targets, value[1] <= 3),
	            if(find(hint.targets, value[1] >= 7), 400, 600),
	  
	           //none on left
			   if(hint.targets, 200, 400))
",
},

on_create: "
	set_widgets(
	[{
		type: 'grid',
		columns: 1,
		children: [

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Join Game', font: 'default', size: 1},
				on_click: q([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'request_updates', state_id: vars.state_id})]
				         where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 2))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Create Game', font: 'default', size: 1},
				on_click: q([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Play vs Bot', font: 'default', size: 1},
				on_click: q([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', bot: true, session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

		]
	},
	])
",

on_update_game: "
   if((not force_process) and
      (tmp.game_state_queue != [] or level.cycle < tmp.animation_end_time),
	 add(tmp.game_state_queue, [message]),

	 [
	 	reserve_animation_time(10),
	    set(vars.processed_state_id, message.state_id),

		map(animation_hints, handle_animation_hint(value))
		  where animation_hints =
		   if(tmp.furthest_animation_hint > size(message.state.animation_hints),
			  message.state.animation_hints,
			  message.state.animation_hints[tmp.furthest_animation_hints:]),
		set(tmp.furthest_animation_hint, size(message.state.animation_hints)),
	    debug('got state_id: ' + message.state_id + '/' + vars.state_id + ' response phase: ' + vars.state.response_phase),
	    [remove_object(heart) | heart <- level.chars, heart.type = 'citadel_controller.heart'],
		map(message.state.players, map(range(max(value.life, 0)), spawn('citadel_controller.heart', -50 + if(context.index = 1, 910), 210 + index*40, 1))),
	    if(creature_status,
			if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
			   where creature = find(message.state.creatures,
			        value.summon_id = creature_status.creature_object.summon_id)
				
				) where creature_status = find(level.chars, value.type = 'creature_status'),
	    [map(filter(level.chars, value.type in ['card', 'tile.level_label']), remove_object(value)),
		 if(find(level.chars, value.type = 'tile') = null, 
		   map(range(message.state.rows), map(range(message.state.columns), spawn('tile', 20 + col*90 + if(row%2 = 1, 45, 0), 170 + row*52, 1, [set(child.vars.loc, [row,col]), set(child.game_state, message.state)]) where col = value) where row = value),
		   [ [set(tile.game_state, message.state)] | tile <- level.chars, tile.type = 'tile']
		  )
		],
	  set(vars.state, message.state),
	  if(message.state.nplayer = message.state.current_player, 
	    set_widgets(
		
		if((not message.state.done_movement) and find(message.state.creatures, value.controller = message.state.nplayer) != null,
		[ 
		{
			type: 'button',
			id: 'movement_button',
			x: 500,
			y: 180,
			padding: [25, 15],
			resolution: 'double',
			label: {type: 'graphical_font_label', text: 'Movement', font: 'default', size: 1},
			on_click: q(if(animation_up_to_date, [set_widgets([]),
			             set(vars.playing_card, -1),
			             set(vars.active_targets, []),
						 tbs_send(vars.client,
						   {
						     type: 'moves',
							 state_id: vars.state_id,
						     moves: discard_command + [{type: 'movement'}]
						   }
						  ),
						  mark_sent_discards
						 ])),
		}
		], []) +
	
		[
		{
			type: 'button',
			id: 'end_turn_button',
			x: 500,
			y: 230,
			padding: [25, 15],
			resolution: 'double',
			label: {type: 'graphical_font_label', text: if(message.state.response_phase = 0, 'End Turn', 'End Response'), font: 'default', size: 1},
			on_click: q(if(animation_up_to_date, [set_widgets([]),
			             set(vars.playing_card, -1),
			             set(vars.active_targets, []),
						 tbs_send(vars.client, {
						  type: 'moves',
						  state_id: vars.state_id,
						  moves: discard_command + [{type: 'end_turn'}]
						 }),
						 mark_sent_discards
						 ])),
		},
		
		]),
	    set_widgets([{
			type: 'graphical_font_label',
			text: if(message.state.response_phase = 0, 'Main Phase', 'Response Phase'),
			id: 'status_label',
			x: 500,
			y: 230,
			size: 1,
			font: 'default'
	   }])),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(tmp.animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(message.state.creatures,
		                     value.summon_id = creature.summon_id) or
							 message.state.graveyard[creature.summon_id]
	    where creature = obj.vars.creature_object
		| obj <- level.chars, obj.type = 'creature'],
		value), 30, 0)), 

	  map(filter(level.chars, value.type = 'creature' and
	          find(message.state.creatures,
			       context.value.vars.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = message.state.graveyard[value.creature_object.summon_id]), 
	  map(message.state.players[message.state.nplayer].hand,
	     spawn('card', 5 + index*135, 590, 1,
		   [set(child.vars.in_hand, true),
		    set(child.vars.hand_index, index),
			set(child.zorder, index),
	        set(child.vars.player, message.state.players[message.state.nplayer]),
		    set(child.card_type, value)])),
	  
	  map(message.state.creatures,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     set(obj.creature_object, value),
	      
		  //create a new object to represent this creature.
	      spawn('creature', 0, 0, 1,
				[set(child.creature_object, value)]))
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value.type = 'creature' and
		                                value.vars.creature_object.summon_id = context.value.summon_id)),

find(level.chars, value.type = 'log_controller').set_log(message.state.log)

])
",

on_message_received: "[debug('msg: ' + message.type, message),
  switch(message.type,
		 'game_created',
         [set(vars.client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 1),

         'game',
		 if(message.state.players[message.state.nplayer].deck = null,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
		  	map(get_document('data/player-deck.cfg'), null asserting get_document('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
			tbs_send(vars.client, {type: 'submit_deck', deck: get_document('data/player-deck.cfg')}),
		  ],
	
	    [
	    set(vars.state_id, message.state_id),
		fire_event('update_game', {message: message})
		]
	   ), // end 'game' case.

         //default case.
         [debug('got message: ', message)]),
		 fire_event('request_updates')]",

on_request_updates: "if(vars.client.in_flight = 0,
					      [debug('request_updates: ' + vars.state_id), tbs_send(vars.client, { type: 'request_updates', state_id: vars.state_id })])",
on_connection_error: "[debug('message error', error), fire_event('request_updates')]",

on_process: "
 [
  if(tmp.animated_spell_card,
	 if(tmp.spell_animation_time >= 100, [
		remove_object(tmp.animated_spell_card),
		set(tmp.animated_spell_card, null),
		set(tmp.spell_animation_time, 0),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(tmp.spell_animation_time = 80 and (ctrl_mod_key in [1,2]),
	     reserve_animation_time(20),
	 [
	    add(tmp.spell_animation_time, 1),
		if(tmp.spell_animation_time <= 20 or tmp.spell_animation_time >= 80, [
			set(tmp.animated_spell_card.alpha, new_alpha),
			map(tmp.animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = if(tmp.spell_animation_time <= 20, tmp.spell_animation_time*22, (100 - tmp.spell_animation_time)*22)
			),
	 ]))), //end animated_spell_card

  if(tmp.game_state_queue != [] and level.cycle >= tmp.animation_end_time,
	[
	  set(tmp.game_state_queue, tmp.game_state_queue[1:]),
	  fire_event('update_game', {message: tmp.game_state_queue[0], force_process: true})
	],
    if(vars.client, tbs_process(vars.client)))
 ]",

on_end_anim: "animation('normal')",
zorder: 50,
timer_frequency: 10,
on_timer: "if(level.player.midpoint_x > vars.x_bound and level.player.midpoint_x < vars.x2_bound  and level.player.midpoint_y > vars.y_bound and level.player.midpoint_y < vars.y2_bound and cycle - vars.last_triggered > 250, [fire_event('triggered'),set(vars.last_triggered,cycle)])",
on_triggered: "",
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},
animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [
	{
		id: "heart",
		animation: [
			{
				id: "normal",
				image: "tiles.png",
				rect: [5,67,19,79],
				frames: 1,
			}
		],
	}
],
}
