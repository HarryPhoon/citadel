{
id: "citadel_controller",
prototype: ["citadel_controller_base"],
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,
zorder: 190,

properties: {
	testtest: "c.render(512, 512, [
		c.set_operator('OVER'),
		c.rectangle(0, 0, 256, 512),
		c.set_source_rgba(1, 1, 1, 0.5),
		c.set_operator('OVER'),
		c.rectangle(0, 0, 256, 512),
		c.set_source_rgba(1, 1, 1, 0.5),
		c.fill(),
	]).save('test.png') where c = canvas()",
	
	//code for making the hex board image and saving to a file. Not
	//normally used in game.
	make_hex_board_image: "def(int hex_width=114, int hex_height=85) ->commands
(c.render(1024, 512,

 fold([[c.save(), c.translate((xpos-1)*hex_width*0.75, ypos*hex_height + if(xpos%2 = 1, hex_height*0.5, 0))] + hex + [
 	c.set_source_rgba(
	(xpos%12)/11.0,
	(ypos%6)/5.0,
	1, 1),
	
	c.fill(), c.restore()] |
   xpos <- range(13),
   ypos <- range(8)
 ], a+b)

).save('test.png')

  where hex = [
  	c.line_to(hex_width*0.25, -hex_height/2),
  	c.line_to(hex_width*0.75, -hex_height/2),
  	c.line_to(hex_width*1.00, 0),
  	c.line_to(hex_width*0.75, hex_height/2),
  	c.line_to(hex_width*0.25, hex_height/2),
  	c.line_to(hex_width*0.00, 0),
  ])
  where c = canvas()
	",

	num_background_hexes: 84,
	background_hex_intensity: { type: "[decimal]", init: "map(range(84), index%2 + 1d100/100.0)" },
	background_hex_intensity_delta: { type: "[decimal]", init: "map(range(84), (50 + 1d50)/20000.0)" },

	process_hex_intensity: "def() ->commands set(background_hex_intensity, map(background_hex_intensity, if(new_value < 0, 1.0, new_value) where new_value = value - background_hex_intensity_delta[index]))",

	concede_game: "def() ->commands [
		execute(me, tbs_send(client, {
			type: 'concede',
		}))
	]",

	process_connection: "def() ->commands [
    	if(client, tbs_process(client))
	]",

	_bdk_controller: { type: "null|obj bdk_controller" },

	_response_pause_counter: { type: "int", default: -1 },

	_last_state_message: { type: "map", default: {} },

	_status_label: { type: "null|obj citadel_controller.status_label" },

	_avatars: { type: "[obj player_avatar]", default: [] },
	_avatar_life: { type: "[obj label]", default: [] },

	_background_canvas: { type: "obj canvas|null" },

	state: "class game<- _state asserting _state",
	_state: { type: "class game|null" },
	end_of_turn_state: { type: "class game|null" },
	_state_id: { type: "int", default: -1 },
	_processed_state_id: { type: "int", default: -1 },
	_client: { type: "object|null" },

	client: "object<- _client asserting _client",

	//the state needed to represent presence to the other player --
	//which cards we have moused over etc.
	_presence_state: "map ::
	if(observer, {},
	{
		hand_card_mouseover: if(_playing_card != null and _playing_card.in_hand and _playing_card.hand_index, _playing_card.hand_index, if(card_mouseover != null and card_mouseover.in_hand, card_mouseover.hand_index)),
		playing_card: _playing_card != null,
	})
	",

	_last_presence_state: { type: "map", default: {} },

	_process_presence_state: "def() ->commands
	if(new_presence != _last_presence_state, [

		tbs_send(client, {
			type: 'chat_message',
			nick: USERNAME,
			sub_type: 'presence',
			info: new_presence,
		}),

		set(_last_presence_state, new_presence),
	]) where new_presence = _presence_state",

	_received_presence_state: "def(map msg) ->commands
	[
		set(_opponent_hand_mouseover, int|null<- msg.hand_card_mouseover),
		set(_opponent_card_playing, bool|null<- msg.playing_card),
		bind_command(spawn_opponent_cards),

	]
	where opponent_cards = filter(level.chars, value is obj card and value.in_opponent_hand)
	",

	_opponent_hand_mouseover: { type: "int|null" },
	_opponent_card_playing: { type: "null|bool" },

	force_skip_responses: { default: false },

	_card_preview: { type: "obj card|null" },
	card_mouseover: { type: "obj card|null",
	   set: "if(value != _data, [
	     if(_data != null, [set(_data.allow_drag, false), _end_mouseover(_data)]),
		 if(value != null, set(value.allow_drag, true)),
		 set(_data, value)
	   ])"
	 },

	_card_regions: { type: "[{left: int, right: int, top: int, card_num: int}]", default: [] },
	_card_regions_left_to_right: "[{left: int, right: int, top: int, card_num: int}] :: sort(_card_regions, a.left < b.left)",
	_hand_card_moused_over: "int ::
	 (if(region = null, -1, region.card_num)
	      where region =
		     if(card_mouseover, find(card_regions_ordered,
			   (index >= mouseover_index and xpos >= value.right - reserved_region and xpos <= value.right and ypos >= value.top) or
			   (index <= mouseover_index and xpos >= value.left and xpos <= value.left + reserved_region and ypos >= value.top))) or
		  	 
		     //prefer the already selected card
		     if(card_mouseover, find(card_regions_ordered, card_mouseover.hand_index = value.card_num and (card_mouseover.being_dragged or xpos >= value.left and xpos <= value.right + 0.2*(value.right - value.left) and ypos >= value.top))) or

			 //not over an already selected card, find the first match.
		     find(card_regions_ordered, xpos >= value.left and xpos <= value.right and ypos >= value.top)
	      where xpos = ctrl_mice[0][0]
	      where ypos = ctrl_mice[0][1])
		  asserting size(ctrl_mice) = 1
		  where reserved_region = min(10, 200 / (size(card_regions_ordered)+1))

		  //Since card regions overlap, we want to order the card regions by
		  //their order of priority if a match is found. We prefer to match
		  //to a region closest to the already selected card, so reverse cards
		  //to the left in order while keeping cards to the right in order.
		  where card_regions_ordered = if(mouseover_index < 0, _card_regions_left_to_right, reverse(_card_regions_left_to_right[:mouseover_index]) + _card_regions_left_to_right[mouseover_index:])
		  where mouseover_index = index(_card_regions_left_to_right, find(_card_regions_left_to_right, card_mouseover != null and card_mouseover.hand_index = value.card_num))",

	//location of the tops of our cards
	_card_hand_top: { type: "decimal", default: 0.0 },

	_prev_ctrl_keys: { type: "[string]", default: [] },

	_playing_card: { type: "null|obj card", default: null,
		set: "[
			if(_data != null, [
				set(_data.draw_primitives, []),
				_data.hide_halo()
			]),
			if(value != null, [
				value.show_halo(),
				animate(value, {x: 50, y: 50, rotate: 0}, {duration: 10}),
				set(value.zorder, get_zorder('card_play')),
			]),
			set(_data, value),
		]"
	},
	_playing_ability: { type: "class util.playing_activated_ability|null" },

	_targets_chosen: { type: "[Loc]", default: [] },

	animation_move_time: { type: "int", default: 0 },
	_animation_end_time: { type: "int", default: -1 },

	_game_state_queue: { type: "[map]", default: [] },
	_furthest_animation_hint: { type: "int", default: 0 },

	_animation_hints_id: { type: "int", default: 0 },

	_animated_spell_card: { type: "null|obj card", default: null },
	_spells_on_stack: { type: "[obj card]", default: [] },

	top_of_stack: "obj card|null :: choose(filter(level.chars, value is obj card and value.stack_id != null), value.stack_id)",

	_spell_animation_time: { type: "int", default: 0 },

	_choice_object: { type: "null|obj choice_controller" },

	_deck_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_display_icons: { type: "[obj game_icon]", default: [] },
	_hand_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_level_obj: { type: "[obj citadel_controller.card_back]", default: [] },

	_end_turn_button: { type: "null|obj end_turn_button" },
	_turn_counter: { type: "null|obj turn_counter" },

	_display_area_labels: { type: "[obj display_area_label]", default: [] },

	font: "string<- 'RobotoCondensed-Regular'",
	color: "string<- 'antique_white'",
	font_color: "string<- 'antique_white'",

	_spell_windup_sound_being_played: { type: "string|null" },

	return_callback: { type: "function(bool) ->commands" },

	restart_game: "def() ->commands [
		execute(me, tbs_send(client, {
			type: 'start_game',
		}))
	]",

	observer: { type: "bool", default: false },

	game_created: { type: "bool", default: false },
	session_id: { type: "int", default: -1 },
	selected_deck: { type: "string", default: "" },
	game_server_address: { type: "string", default: "@eval TBS_SERVER_ADDRESS" },
	game_server_port: { type: "int", default: "@eval TBS_SERVER_PORT" },

	create_tbs_client: "def() ->object
	  if(game_server_address, tbs_client(game_server_address, game_server_port, session_id), tbs_internal_client(session_id))
	  ",

	level_width: "int :: level.dimensions[2]",
	level_height: "int :: level.dimensions[3]",

	card_keeps: "[int]<-  [card.hand_index | card <- level.chars, card is obj card, card.in_hand, card.keep]",

	card_keep_draw_id: "[int] :: [card.card_type.draw_id | card <- level.chars, card is obj card, card.in_hand, card.keep]",

	end_turn_message: "{string -> any}<- {type: 'end_turn', keep: card_keeps}",

	_end_turn_pending: { default: false },

	end_turn: "def() ->commands
	if(_tutorial.inhibit_end_turn(me) = false,
	[
	//remove the end turn button immediately to appear responsive to
	//pressing the end turn button.
	if(_end_turn_button, [
		set(_end_turn_button, null),
		remove_object(_end_turn_button),
	]),
	execute(me, if(animation_up_to_date, [set_widgets([]),
	                     set(_end_turn_pending, false),
			             set(me._playing_card, null),
						 set(_playing_ability, null),
						 tbs_send(client, {
						  type: 'moves',
						  state_id: me._state_id,
						  moves: [end_turn_message]
						 })
						 ],
						 set(_end_turn_pending, true)))
	])
	",

	get_zorder: "def(string key) ->int lib.citadel.zorder(key)",

	set_status_label: "def(string text, string color='white', int duration=150) ->commands 
	[
		if(_status_label, remove_object(_status_label)),
		spawn('citadel_controller.status_label', 0, 0, 1, [
			set(_status_label, child),
			set(child.zorder, get_zorder('status_label')),
			if(duration > 0, execute(child, schedule(duration,
			                                         remove_object(child)))),
			debug('init label: ' + text),
			child.init_label(text, color, int(_card_hand_top)),
		])
	]",

	awaiting_input: "bool :: _playing_card != null or _playing_ability != null",

	clear_input_state: "def() ->commands execute(me, [
		//if(me.card_mouseover, mouse_leave_card(me.card_mouseover)),
		[set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		[set(player.selectable, false) | player <- level.chars, player is obj mana_display],
		set(_playing_card, null),
		set(_playing_ability, null),
		set(_targets_chosen, []),
		//set(me.card_mouseover, null),
		_spawn_tile_cursors(),
	])",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def() ->commands
	  if(myplayer.hand != myplayer.previous.hand, clear_input_state())
	",

	//debug function to execute FFL on the server.
	server_exec: "def(string code) ->commands
	execute(me, tbs_send(client, {
		type: 'moves',
		state_id: _state_id,
		moves: [{
			type: 'debug',
			exe: code
		}]
	}))
	",

	send_chat: "def(string msg) ->commands
		execute(me, tbs_send(client, {
			type: 'chat_message',
			text: msg,
			nick: USERNAME,
		}))
	",

	debug_draw: "def(int ncards) ->commands server_exec('players[current_player].draw_cards(me, ' + ncards + ')')",
	debug_mana: "def(int nmana) ->commands server_exec('add(players[current_player].resources, ' + nmana + ')')",
	debug_card: "def(string name) ->commands server_exec('add(players[current_player].hand, [lib.citadel.create_card(q(' + name + '))])')",
	debug_card_enemy: "def(string name) ->commands server_exec('add(players[next_player_index].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",

	debug_enemy_hand: "[string]<- map(state.opponent_obj.hand, value.name)",
	
	animation_up_to_date: "bool<- _processed_state_id = _state_id",
	reserve_animation_time: "def(int ncycles) ->commands if(end_time > _animation_end_time, set(me._animation_end_time, end_time)) where end_time = level.cycle + ncycles",
	myplayer: "class player<- _state.players[_state.nplayer] asserting _state",
	enemy_player: "class player<- _state.players[(_state.nplayer+1)%2] asserting _state",

	hand_index_after_discarding: "def(int nhand) ->int nhand - count(level.chars, value is obj card and (value.discarded or value.in_furnace) and value.hand_index < nhand)",

	mark_sent_discards: "commands<-
	[set(card.sent_discard_msg, true) |
	  card <- level.chars, card is obj card, card.discarded = true]
	",

	discard_command: "def([int] additional_indexes=[]) ->[map]
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = additional_indexes + [card.hand_index |
	    card <- level.chars, card is obj card,
		                     card.discarded = true or card.in_furnace,
		                     card.sent_discard_msg = false]
	",

	resources_from_discards: "def() ->int
	  size([card | card <- level.chars, card is obj card, card.in_furnace or card.discarded = true, card.sent_discard_msg = false])",

	remove_preview_card: "def(any card) ->commands if(_card_preview and card = null, [remove_object(_card_preview), set(_card_preview, null)])",

	_hint_label: { type: "null|obj hint_label", set: "[
		if(_data, _data.destroy()),
		set(_data, value),
	]" },

	mouse_enter_card: "def(obj card card) ->commands [
	 if(card.in_hand, [
		set(card.zorder, get_zorder('card_highlight')),
		if(card.in_furnace = false and card != _playing_card, [
			animate(card, {
				mid_x: pos.mid_x,
				mid_y: pos.mid_y - 200,
				rotate: 0.0,
				card_size: pos.card_size*2,
			}, {
				duration: 10,
				name: 'card_move',
				replace_existing: true,
			}),

		]) where pos = cards_in_hand_positions(state.players[state.nplayer].hand)[card.hand_index],
		set(me.card_mouseover, card),
	 ]),
	 (if(me._playing_card = null, if(me.card_mouseover = card, null,
	  if(me.card_mouseover != null, [
			mouse_leave_card(me.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.in_hand,

	  [
	  if(discards != null and possible_targets != [],
	  [
	 	card.show_halo(),
	    set(me.card_mouseover, card),

		//synthetic clicks to suggest discarding
	  	[mark_for_discard(card) | card <- level.chars, card is obj card, card.hand_index in discards]
	  ]),

		spawn('hint_label', 0, 0, {
			zorder: 2000,
			_text: ['Costs ' + str(local_player.calculate_cost(local_player.hand[card.hand_index])) + ' mana.'] +
			        if(discards = null,
					   ['Cannot afford to cast.', if(card.card_type.hero, 'Hero cards may not be burned for mana', 'Right-click to burn for one mana.')],
					   possible_targets = [], ['No available targets.', if(card.card_type.hero, 'Hero cards may not be burned for mana', 'Right-click to burn for one mana.')],
					   discards = [], ['Click to cast'],
					   ['Burn ' + size(discards) + ' cards to cast.']),
			subject: card,
			_delay: 50,
		}, [
			set(_hint_label, child),
		]),
	  ]
	  where discards = (local_player.suggest_discards(local_player.calculate_cost(local_player.hand[card.hand_index]) - resources_from_discards(), filter([card.hand_index] + [card.hand_index | card <- level.chars, card is obj card, card.discarded or card.keep or card.in_furnace], value != null))
		  ))
 	  where possible_targets = if(card.card_type is class card, card.card_type.possible_targets(state, state.nplayer, []), [])
	  )))

	asserting (not card.in_hand) or (card.hand_index < size(local_player.hand)) | 
	[size(local_player.hand), card.hand_index, card.card_type.name, [[card.hand_index, card.in_hand, card.card_type.name] | card <- level.chars, card is obj card], [card.name | card <- local_player.hand]]
	  )]
	  where local_player = myplayer",
	
	_end_mouseover: "def(obj card card) -> commands
	  if(card.in_hand and find(level.chars, value = card) and find(state.players[state.nplayer].hand, value = card.card_type) != null,
	    [
		if(_playing_card != card, [
			card.hide_halo(),
			animate(card, {
				mid_x: pos.mid_x,
				mid_y: pos.mid_y,
				rotate: pos.rotate,
				card_size: pos.card_size,
			}, {
				duration: 10,
				name: 'card_move',
				replace_existing: true,
			})
		]),
		set(card.zorder, pos.zorder),
	    ] where pos = cards_in_hand_positions(state.players[state.nplayer].hand)[card.hand_index]
	  )
	",

	mouse_leave_card: "def(obj card card) ->commands [
	  if(_hint_label and _hint_label.subject = card, set(_hint_label, null)),

	  set(me.card_mouseover, null),
	  if(me.card_mouseover = card, [
		card.set_discarded(false) | card <- level.chars, card is obj card, card.discarded
	 ])
	]",

	mouse_drag_card_start: "def(obj card card) ->commands
		if(card = card_mouseover,
		[
			set(card.card_size, 1.0),
			set(card.mid_x, mouse_x),
			set(card.mid_y, mouse_y),
		]
		)
	",

	mouse_drag_card: "def(obj card card) ->commands
	[
	if(card.in_hand and card.hand_index != null,
	[
		if(pos != -1, [
		   set(card.keep, mouse_x >= right_edge_display_areas and (obj_replacing.keep or mouse_x > _card_regions_left_to_right[size(_card_regions_left_to_right)-1].right)),

		   if(card.discarded, card.set_discarded(false)),
		   set_card_hand_position(card.hand_index, pos),
	   	   bind_command(spawn_cards_in_hand)
		  ]
		  where obj_replacing = find_or_die(level.chars, value is obj card and value.hand_index = _card_regions_left_to_right[pos].card_num)) 
		  where pos = index(_card_regions_left_to_right, find(_card_regions_left_to_right,
		     mouse_y > value.top and (
		     (mouse_x > (value.left + value.right)/2 and mouse_x < value.right) or
			 (index = 0 and mouse_x < value.left and mouse_x > value.left - (value.right - value.left)) or
			 (index = size(_card_regions_left_to_right)-1 and mouse_x > (value.right))))),
	])]",

	mouse_drag_card_end: "def(obj card card) ->commands [
		if(card = card_mouseover,
			[
				mouse_leave_card(card),
			]
		),

		if(in_furnace != card.in_furnace, [
			set(card.in_furnace, in_furnace),
	   	    bind_command(spawn_cards_in_hand),
			debug('AAA: END DRAG'),

			if(mana_display, if(in_furnace, [
				animate_furnace_mana_gain()
			], [
				add(mana_display.amount, -1),
				fire_event(mana_display, 'update'),
			]))
		   	where mana_display = find(level.chars, value is obj mana_display and value.player_num = state.nplayer),
		])

		where in_furnace = mouse_x <= left_edge_display_areas and mouse_y > top_player_area
	]",

	mouse_x: "int<- ctrl_mice[0][0]",
	mouse_y: "int<- ctrl_mice[0][1]",


	mouse_enter_discard: "def(int nplayer) ->commands execute(me, [

	])",

	mouse_click_discard: "def(int nplayer) ->commands []",

	mouse_leave_discard: "def(int nplayer) -> commands execute(me, [
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(obj tile tile) ->commands [
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen + if(tile.selectable, [tile.loc], [])),
		]),

	if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
	   ]) where card = lib.json.get_document_map('data/cards.cfg')[creature.name])
	      where creature = state.creature_at_loc(tile.loc)
	]",
	mouse_leave_tile: "def(object tile) ->commands remove_preview_card(tile.loc)",

	mouse_enter_log: "def(int index) ->commands null",

	_tutorial: { type: "class client_tutorial", init: "construct('client_tutorial')" },
	
	_cards_burned_for_current_cast: { type: "[obj card]", default: [] },

	card_clicked: "def(obj card card) ->commands if(state.nplayer = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false,
	  if(_playing_card,
	  [
	  	set(_playing_card, null),
		rollback_discards(),
	    _spawn_tile_cursors(),
	  ],
			  
	  card.discarded,
	  [debug('set not discarded'), card.set_discarded(false)],
	  card.in_furnace,
	  [
	  	set(card.in_furnace, false),
		bind_command(spawn_cards_in_hand),
		if(mana_display, [
			add(mana_display.amount, -1),
			fire_event(mana_display, 'update'),
		]),
	  ]
		   where mana_display = find(level.chars, value is obj mana_display and value.player_num = state.nplayer),
	  [
	   tile_clicked(null),

	   set(_cards_burned_for_current_cast, []),

	   //commit to any card discard at this point.
	   [[
	   		card.set_discarded(false),
			set(card.in_furnace, true),
		    animate_furnace_mana_gain(),
			add(_cards_burned_for_current_cast, [card]),
	    ]
	   	| card <- level.chars,
		  card is obj card,
		  card.discarded
	   ],

	   bind_command(spawn_cards_in_hand),

	   set(me.card_mouseover, null),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])
	]))",

	animate_furnace_mana_gain: "def() ->commands [
		
	  if(mana_display,
	   spawn('game_icon', left_edge_display_areas - display_area_width/2, (top_player_area + level_height)/2, { alpha: 0, icon: 'mana.svg', size: 32, user_info: 'player_mana', zorder: get_zorder('mana_symbols') }, [
	   	animate(child, {
			mid_x: mana_display.mid_x,
			mid_y: mana_display.mid_y,
		}, {
			duration: 50,
			on_complete: [
				remove_object(child),
				add(mana_display.amount, 1),
				fire_event(mana_display, 'update'),
			]
		}),

		animate(child, {
			alpha: 255
		}, {
			duration: 20,
			name: 'fade'
		}),

		animate(child, {
			alpha: 255
		}, {
			duration: 10,
			name: 'fade'
		}),

		animate(child, {
			alpha: 0
		}, {
			duration: 20,
			name: 'fade'
		}),

	   ]))
		   where mana_display = find(level.chars, value is obj mana_display and value.player_num = state.nplayer)
	]",

	card_right_clicked: "def(obj card card) ->commands [
	 if(state.nplayer = state.current_player and observer = false and _tutorial.inhibit_card_right_click(me, card) = false,
	 if((not card.discarded) and (not card.card_type.hero), [
	   debug('set card discarded'),
	   tile_clicked(null),
	   card.set_discarded(false),
	   if(card.in_furnace = false, [
		  set(card.in_furnace, true),
		  animate_furnace_mana_gain(),
	   ]),
	   bind_command(spawn_cards_in_hand)
	],
	 if(card.card_type.hero, set_status_label('Hero cards may not be discarded for mana', 'red'))
	))
	]",

	mark_for_discard: "def(obj card card) ->commands [
	 if(state.nplayer = state.current_player and observer = false,
	 if((not card.discarded) and (not card.card_type.hero), [
	   debug('set card discarded'),
	   tile_clicked(null),
	   card.set_discarded(true),
	],
	 if(card.card_type.hero, set_status_label('Hero cards may not be discarded for mana', 'red'))
	))
	]",

	option_clicked: "def(null|int|string choice_value) ->commands execute(me, [
	debug('option clicked: ' + choice_value),
	tbs_send(client, {
		type: 'moves',
		state_id: _processed_state_id,
		moves: [{
			type: 'make_choice',
			choice: choice_value,
		}],
	})
	])",

	mana_display_clicked: "def(obj mana_display item) ->commands [
		if(me._playing_card != null and item.selectable,
			choose_targets_for_card(
			  find_or_die(level.chars, value is obj card and value.hand_index = me._playing_card.hand_index), _targets_chosen + [[-1, item.player_num]])
		)
	]",
	      
	tile_clicked: "def(obj tile|null tile) ->commands
	[if(not state.current_choice, [
	   [set(player.selectable, false) | player <- level.chars, player is obj mana_display],
	   execute(me, 	map(level.chars, if(value is obj tile,
	                                    set(value.selectable, false)))),
	   if(tile and me._playing_card != null and tile.selectable,
		  choose_targets_for_card(
		   obj card<- //assert we succeed in finding.
		    find(level.chars, value is obj card and
			                  value.hand_index = me._playing_card.hand_index),
			_targets_chosen + [tile.loc]),
		 
		 if(tile and _playing_ability != null and tile.selectable,
		    choose_targets_for_ability(_playing_ability.creature,
			                           _playing_ability.ability,
									   [tile.loc]),

		//cancel all discards
		rollback_discards()
	   )),
	   _spawn_tile_cursors(),
	 ]),

	 set(_cards_burned_for_current_cast, []),
	 ]",
	
	rollback_discards: "def() ->commands [
		[card.set_discarded(false) |
		 card <- level.chars,
		 card is obj card,
		 card.discarded],
		clear_input_state(),

		//if we burned cards for the purposes of this discard, cancel the burning
		//and return cards to hand.
		if(_cards_burned_for_current_cast and mana_display != null,
		[
		   [[set(card.in_furnace, false), add(mana_display.amount, -1)] |
		    card <- _cards_burned_for_current_cast, find(level.chars, value = card) != null],

		   fire_event(mana_display, 'update'),
		])
		   where mana_display = find(level.chars, value is obj mana_display and value.player_num = state.nplayer),
	   bind_command(spawn_cards_in_hand),
	   set(_cards_burned_for_current_cast, []),
	]",
	
	choose_targets_for_ability: "def(class creature creature, class activated_ability ability, [Loc] targets) ->commands execute(me, [
		 tbs_send(client, {
		   type: 'moves',
		   state_id: _processed_state_id,
		   moves: discard_command(if(discards, discards, []) where discards = myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability.name, targets: targets, player_index: state.current_player}]
		  }),
		  mark_sent_discards,
		  [set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
	      _spawn_tile_cursors(),
		  set(me._playing_card, null),
		  set(_targets_chosen, []),
		  set(_playing_ability, construct('util.playing_activated_ability', {creature: creature, ability: ability})),
	]) asserting client",
	
	choose_targets_for_card: "def(obj card card, [Loc] current_targets) ->commands
	execute(me,
	if(card_instance and state.in_response_phase and not card_instance.is_response,
	set_status_label('Can only cast response spells during response phase', 'red'),
	[
	   if(card_instance and card.hand_index != null and state.nplayer = state.current_player and observer = false,
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [] and not unique_violation,
		      if(possible_targets = null,
				[
				 tbs_send(client, {
				   type: 'moves',
				   state_id: _processed_state_id,
				   moves: discard_command() + [{
					type: 'play_card',
					index: hand_index_after_discarding(card.hand_index),
					player_index: state.current_player,
					targets: current_targets,
				   }]
				  }) asserting _client,
				 mark_sent_discards,
				 set(me._playing_card, null),
				 set(_playing_ability, null),
				 clear_input_state(),
				],
			    [
				 [set(player.selectable, [-1, player.player_num] in possible_targets) | player <- level.chars, player is obj mana_display, player.icon = 'gui_life.svg'],
				 map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
				 _spawn_tile_cursors(),
				 set(me._playing_card, card),
				 set(_playing_ability, null),
				 set(_targets_chosen, current_targets)
				]),
			  [
			   set_status_label(if(possible_targets = [],
			    if(card_instance.creature_object != null and card_instance.hero /*and find(state.creatures, value.controller = state.current_player and value.name = card_instance.creature_object.name) != null*/, 'Cannot play duplicate heroes', 'No valid targets'),
			        if(not can_afford, 'Not enough mana: ' + myplayer.resources + ' to play ' + card_instance.name,
						card_instance.name + ' is already on the field, you may not play copies of a hero.')), 'red')
			  ])]
		where unique_violation = card_instance.hero and card_instance.creature and find(state.creatures, value.name = card_instance.name and value.controller = state.nplayer)

		//we should already have suggested discards at this point, so
		//if the card is playable, the player can afford it straight-up
		where can_afford = (myplayer.suggest_discards(myplayer.calculate_cost(card_instance) - resources_from_discards()) = [])
		where possible_targets = card_instance.possible_targets(state, state.nplayer, current_targets))
	 ])) where card_instance = null|class card <- if(card.card_type is class card, card.card_type, null)",

	_spawn_tile_cursors: "def() ->commands bind_command(_spawn_tile_cursors_internal)",

	_spawn_tile_cursors_internal: "def() ->commands
	[
	if(find(level.chars, value is obj tile and value.selectable or value is obj mana_display and value.selectable) = null,
	   [ remove_object(cursor) | cursor <- level.chars, cursor is obj tile_cursor], [
		[remove_object(cursor) | cursor <- level.chars, cursor is obj tile_cursor, find(level.chars, value = cursor.tile) = null or cursor.tile.selectable = false],

		[fire_event(cursor, 'create') | cursor <- level.chars, cursor is obj tile_cursor, find(level.chars, value = cursor.tile) != null],

		[spawn('tile_cursor', 0, 0, {hex_height: tile_width, tile: tile}) | tile <- level.chars, tile is obj tile, find(level.chars, value is obj tile_cursor and value.tile = tile) = null]

	]),

	[fire_event(player, 'update') | player <- level.chars, player is obj mana_display]
	]",
	
	creature_clicked: "def(obj creature creature) ->commands execute(me, [
	    if(creature.creature_object and creature.creature_object.is_on_board,
		  [map(filter(level.chars, value is obj creature_status), value.destroy()),
		   spawn('creature_status', 300, 410, { creature_object: creature.creature_object })]
		  )
	  ])",
	
	can_use_ability: "def(class creature creature, string ability_name) ->bool
	 state.nplayer = state.current_player and observer = false and
	 state.nplayer = creature.controller and
	 ((not state.in_response_phase) or ability.is_response) and
	 ((not ability.exhausts_creature) or (not creature.is_exhausted)) and
	 (myplayer.suggest_discards(myplayer.calculate_cost(ability)) != null) and
	 creature.summoned and
	 ability.is_usable(state, creature)
	  asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)",
	 
	
	ability_clicked: "def(class creature creature, string ability_name) ->commands
	execute(me, [
	if(animation_up_to_date and can_use_ability(creature, ability_name),
		//we'll calculate our possible_targets:
		// - null means we play the ability right now
		// - [] means there are no valid targets and the ability can't play
		// - a list of targets means we invite the player to select their
		//   preferred target.
		if(possible_targets = null, 
	    [
		  tbs_send(client, 
		  {
			type: 'moves',
			state_id: me._state_id,
		    moves: (if(discards, discard_command(discards), []) where discards = myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name, targets: [], player_index: state.current_player}],
		  }) asserting client,
		  mark_sent_discards
		  ],
		 if(possible_targets = [], set_status_label('No available targets for ability', 'red'),
		    [
				[set(tile.selectable, if(tile.loc in possible_targets, true, false)) | tile <- level.chars, tile is obj tile],
				_spawn_tile_cursors(),
				set(me._playing_card, null),
				set(_targets_chosen, []),
				set(_playing_ability, construct('util.playing_activated_ability', {creature: creature, ability: ability})),
				
			]))
		where possible_targets = ability.possible_targets(state, creature, [])
	) asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)
	  ])",
	
	set_playing_card_arrows: "def([Loc] targets) ->commands
		if(_playing_card, set(_playing_card.draw_primitives, map(targets,
		{
			type: 'arrow',
			texture: 'ink.png',
			texture_scale: 0.2,
			arrow_head_length: 40,
			arrow_head_width: 0.4,
			points: [
			  [_playing_card.x2,
			   _playing_card.mid_y + 40*(index+1)/(size(targets)+1)],
			  [target_tile.mid_x, 
			   _playing_card.mid_x + 40*(index+1)/(size(targets)+1)],
			  [target_tile.mid_x, target_tile.mid_y]
			],
		}
		 where target_tile = find_or_die(level.chars, value is obj tile and value.loc = context.value)
		)))
	",
	
	animate_draw_cards: "def(int ncards) ->commands
	  if(size(cards) >= ncards, map(cards, value.animate_draw(index)))
	  where cards = sort([card | card <- level.chars, card is obj card, card.in_hand, card.hand_index != null], a.hand_index > b.hand_index)",
	
	card_on_stack: "def(object card) ->class message.play_card_base|null
	   find(state.stack, value.stack_id = card.stack_id)
	     asserting _state",

	play_player_damage_hint: "def(class animation.player_damage_hint hint) ->commands if(src and hint.target_player < size(_avatar_life), [
		spawn('player_damage_effect', src.mid_x, src.mid_y, {
			amount: hint.amount,
			zorder: 10000,
		}, [
			animate(child, {
				mid_y: _avatar_life[hint.target_player].mid_y,
			}, {
				duration: 40,
			}),

			animate(child, {
				mid_x: _avatar_life[hint.target_player].mid_x,
			}, {
				duration: 50,
				on_complete: remove_object(child),
			})
		]),
	]) where src = find(level.chars, value is obj creature and value.creature_object = hint.source)",

	handle_animation_hint: "def(class animation.hint hint) ->commands [

	if(hint is class animation.player_damage_hint, schedule(90, bind_command(me.play_player_damage_hint, hint))),

	if(hint is class animation.play_card_hint,
	  ([
		reserve_animation_time(100),
		set(_spell_animation_time, 0),
		if(hint.card.flavor_text != null, spawn('flavor_text_label', level_width/4 + 1d (level_width/2), level_height/4 + 1d (level_height/2), {velocity_x: -50 + 1d100, velocity_y: -50 + 1d100, _text: string<- hint.card.flavor_text, zorder: 5000})),

		spawn('card', xloc, 300 + 40*size(state.stack),
		  {
			 card_type: hint.card,
			 controller: me,
			 in_hand: false,
			 allow_drag: true,
			 stack_id: hint.stack_id,
			 card_size: 2,
			 alpha: 0,
			 zorder: get_zorder('card_stack_base') + hint.stack_id,
		  },
			   [
			    if(_animated_spell_card, [
		   		    add(_spells_on_stack, [_animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(_animated_spell_card, child),
				[
				  if(windup_sound, sound_loop(windup_sound, lib.citadel.sound_volume(windup_sound), 0.5)),
				  set(_spell_windup_sound_being_played, windup_sound)
				] where windup_sound = hint.card.windup_sound,
				schedule(20, set(child.draw_primitives, filter(map(hint.targets, if(target_tile, {
					type: 'arrow',
					texture: 'ink.png',
					texture_scale: 0.2,
					arrow_head_length: 40,
					arrow_head_width: 0.4,
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value is obj tile and value.loc = context.value or context.value[0] = -1 and value is obj mana_display and value.icon = 'gui_life.svg' and value.player_num = context.value[1])), value != null))),

				  if(prev_card != null, child.animate_from(prev_card, 30))
				] where prev_card = find(level.chars, value is obj card and value.card_type = hint.card))
]
	  where xloc = if(size(state.stack)%2 = 1, level_width*0.15, level_width*0.85)
	  )
	),
	if(hint.type in ['fizzle', 'resolve'],
	  if(fizzling_card,
		if(hint.type = 'fizzle', fizzling_card.start_fizzle_animation(), fizzling_card.start_resolve_animation()))
		where fizzling_card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	)
   ]
",

	set_widgets_for_message: "def(class game game) ->commands
	[
	  if(_end_turn_button, remove_object(_end_turn_button)),
	  set(_end_turn_button, null),

	  if(_turn_counter, remove_object(_turn_counter)),
	  set(_turn_counter, null),
	
	  spawn('turn_counter', level_width - avatar_width - 80, top_player_area - 50, {
		_controller: me,
		count: 60,
		zorder: get_zorder('hud') + 20,
	  }, [
		set(_turn_counter, child),
	  ]),
	       
	  if(game.nplayer = game.current_player and observer = false and _end_turn_pending = false,
	  [

	    spawn('end_turn_button', level_width - avatar_width + 20, top_player_area - 50, {
			_controller: me,
			_text: if(game.in_response_phase, 'P A S S', if(game.has_unresolved_combat, 'C O M B A T', 'E N D  T U R N')),
			_phase: if(game.in_response_phase, 'R E S P O N S E   P H A S E', 'P L A Y   P H A S E'),
			zorder: get_zorder('hud'),
			highlight: game.in_response_phase or not game.players[game.current_player].has_possible_play(game),
		}, [
			set(_end_turn_button, child),
		]),

	    set_widgets([])

	  ],
	    set_widgets([{
			type: 'label',
			text: game.players[game.current_player].name + q('s ) + if((not game.in_response_phase), 'Main Phase', 'Response Phase'),
			id: 'status_label',
			x: level_width - 524,
			y: level_height - 538,
			font: me.font, 
			align_h: 'center',
			size: 16, 
			color: me.color			
	   }]))
	]",
	
	set_schedule_for_message: "def(class game game) ->commands [

	]",

	board_ypos: "int :: (bot_opponent_area + top_player_area)/2 - board_height/2",

	board_width: "tile_width*5",
	board_height: "tile_width*5",
	tile_width: "int :: val - val%4 where val = (top_player_area - bot_opponent_area)/5",
	tile_height: "int :: tile_width",
	tile_border: "int :: 2",
	tile_x_spacing: "int :: tile_width + tile_border",
	tile_y_spacing: "int :: tile_height + tile_border",

	_trophy_labels: { type: "[obj label]", default: [] },

	spawn_trophies: "def(class game game) ->commands [
		map(_trophy_labels, remove_object(value)),
		set(_trophy_labels, []),

		map(game.trophies, map(value,
		 spawn('label', pos[0] + tile_width*0.75, pos[1] + if(nplayer = state.nplayer, tile_height/2, -tile_height/2), {
			_text: [str(value)],
			zorder: get_zorder('status_icon'),
		 }, [
		 	add(_trophy_labels, [child]),
		 ])
		 where pos = get_tile_pos([nlane, if(nplayer = 0, game.lanes[nlane].begin, game.lanes[nlane].begin + game.lanes[nlane].length-1)])
		 where nlane = index)
		 where nplayer = index)
	]",
	
	spawn_tiles: "def(class game game) ->commands [
		 if(find(level.chars, value is obj tile) = null, 
		   map(range(game.rows), map(range(game.columns),
		    if(game.is_loc_on_board([row,col]) = false, null,
		     spawn('tile', 0, 0, {
				x: (level_width - board_width)/2 + row*tile_y_spacing,
				y: board_ypos + if(state.nplayer = 0, (state.columns-1) - col, col)*tile_y_spacing + if(row%2 = 1, if(state.nplayer = 0, -1, 1)*tile_x_spacing/2, 0),
				_controller: me,
				game_state:game,
				loc: [row,col],
				hex_height: tile_width,
			})) where col = value) where row = value),
		   [ [set(tile.game_state, game)] | tile <- level.chars, tile is obj tile]
		  )
	]
	",

	_cards_sorted_by_hand_position: { default: [], type: "[class card]" },
	_card_hand_positions: { default: [], type: "[int]", set: "[set(_cards_sorted_by_hand_position, map(sort(map(hand, {card: value, score: if(index < size(context.value), context.value[index], index)}), a.score < b.score), value.card)), set(_data, value)] where hand = state.players[state.nplayer].hand" },

	card_hand_position: "def(int hand_index) ->int if(hand_index < size(_card_hand_positions), _card_hand_positions[hand_index], hand_index)",
	position_to_hand_index: "def(int pos, int n=0) ->int if(card_hand_position(n) = pos, n, position_to_hand_index(pos, n+1))",

	set_card_hand_position: "def(int hand_index, int new_position) ->commands
	[
		set(me._card_hand_positions, remapped_positions),
	] where remapped_positions =
	   map(range(max(hand_index+1, size(_card_hand_positions), new_position+1)),
	       if(index = hand_index, new_position,
			  pos + if(pos < current_position and pos >= new_position, 1,
			           if(pos > current_position and pos <= new_position, -1, 0))
			 )
			 where pos = card_hand_position(index)
		  )
	  where current_position = card_hand_position(hand_index)
	",

	hand_left_side: "0.31",
	hand_area: "0.33",
	hand_right_side: "hand_left_side + hand_area",
	hand_card_size: "if(level_width > 1200, 1.0, 0.8)",

	//metrics for the crypt/discard/etc display areas.
	left_edge_display_areas: "(hand_left_side-0.03)*level_width",
	right_edge_display_areas: "(hand_right_side+0.07)*level_width",
	display_area_width: "if(hand_card_size = 0.8, 138, 170)",

	cards_in_hand_positions: "def([class card] hand) ->[{zorder: int, mid_x: int, mid_y: int, rotate: decimal, card_size: decimal}]
	  map(hand,
	   {
		 mid_x: int(if(card_obj != null and card_obj.in_furnace,
		           left_edge_display_areas - display_area_width/2,
		           card_obj != null and card_obj.keep,
		           right_edge_display_areas + display_area_width/2 + index_keep*40
				     where index_keep = count(hand, index < context.index and card != null and card.keep where card = hand_cards[index]),
		           20 + level.dimensions[2] * (hand_left_side + ratio*hand_area))),
		 mid_y: int(level_height - 100 + if(level_height < 900, (900 - level_height)/6, 0) + if(card_obj != null and (card_obj.keep or card_obj.in_furnace), 40, 0)),
		 rotate: int(-5 + ratio*10.0),
		 card_size: me.hand_card_size,
		 zorder: get_zorder('card_in_hand_base') - card_hand_position(index)
	   }
		 where ratio = (card_hand_position(index) + 0.5)/size(hand)
		 where card_obj = null|obj card :: hand_cards[index]
	  )

	  where hand_cards = map(hand, null|obj card :: find(level.chars, (value is obj card) and value.card_type = context.value))
	",

	find_card_obj: "def(class card card) ->null|obj card find(level.chars, (value is obj card) and value.card_type = card)",

	//_schedule_fg: { type: "obj citadel_controller.schedule_canvas", init: "object('citadel_controller.schedule_canvas', 0, 0, {zorder: 5})" },
	//_schedule_bg: { type: "obj citadel_controller.schedule_canvas", init: "object('citadel_controller.schedule_canvas', 0, 0, {zorder: 4})" },

	//_current_schedule_state: { default: 'none' },

	_schedule_obj: { type: "obj game_icon", init: "object('game_icon', 0, 0, {icon: 'sun.svg', size: 64, zorder: lib.citadel.zorder('hud') })" },

	update_schedule_objects: "def() -> commands [
		if(schedule_obj.user_info = null, [
			set(schedule_obj.user_info, 'schedule'),
			add_object(schedule_obj),
		]),

		if(state.is_day = false, set(schedule_obj.rotation, 0)),
		set(schedule_obj.event_handlers.process, if(state.is_day, q(add(me.rotation, 0.001)), q(null))),

		set(schedule_obj.mid_x, (level_width + board_width)/2 + 100),
		set(schedule_obj.mid_y, 180),

		set(schedule_obj.icon, if(state.is_day, 'sun.svg', 'moon.svg')),
	] where schedule_obj = obj game_icon <- (find(level.chars, value is obj game_icon and value.user_info = 'schedule') or object('game_icon', 0, 0, { icon: 'sun.svg', size: 96, zorder: get_zorder('hud')}))",
	
	spawn_cards_in_graveyard: "def() ->commands [
		[remove_object(card) | card <- level.chars, card is obj card, card.in_graveyard],
		map(state.players,
		  map(reverse(player.visible_discard_pile),
		  [
	         spawn('card', 228 + 10*index, if(player_index = 0, level_height - 125 - index*10, 140 + index*10), {
				zorder: get_zorder('card_in_graveyard_base') + if(player_index = 0, 1, -1)*index,
				card_size: 0.6,
				controller: me,
				card_type: value,
				in_graveyard: true,
				red: 128,
				green: 128,
				blue: 128,

				mid_x: int(left_edge_display_areas - display_area_width*1.5 - index*12 * min(1.0, 5.0/size(player.visible_discard_pile)) + min(20, size(player.visible_discard_pile)*4)),
				y: if(player_index = 0,
				   int(top_player_area + 30 + index*12 * min(1.0, 5.0/size(player.visible_discard_pile)) - min(14, size(player.visible_discard_pile)*4)),
				   int(bot_opponent_area - 200 - index*12)),
				rotate: if(player_index = 0, 0, 180),
			 })
		  ]
		  )
		where player = value
		where player_index = if(index = state.nplayer, 0, 1))
	]",

	spawn_cards_in_hand: "def() ->commands

	[
	   set(_card_hand_positions, map(hand, index(hand_sorted, value))),
	   bind_command(_spawn_cards_in_hand_internal),
	]
	    
		where hand_sorted =[class card] ::
		  sort(hand, if(keep_a != keep_b, keep_a < keep_b, if(new_a != new_b, new_a > new_b, index_a < index_b))
		    where new_a = (index_a = -1) where new_b = (index_b = -1)
		    where index_a = index(_cards_sorted_by_hand_position, a)
			where index_b = index(_cards_sorted_by_hand_position, b)
		    where keep_a = obj_a != null and obj_a.keep where keep_b = obj_b != null and obj_b.keep
		    where obj_a = find_card_obj(a) where obj_b = find_card_obj(b))
		where hand = [class card] :: state.players[state.nplayer].hand
	",

	_spawn_cards_in_hand_internal: "def() ->commands
	[
	  debug(['AAA: spawn: ', card_mouseover = null, count(level.chars, value is obj card and value.in_furnace)]),
	  set(_card_regions, []),
	  map(state.players[state.nplayer].hand,
	    
	   [
	   if(card_obj != null,
	     [
		   set(card_obj.hand_index, index),
		   set(card_obj.in_hand, true),
		   set(card_obj.highlight, highlight_card),

		   if(card_obj != card_mouseover and card_obj != _playing_card, [
			   animate(card_obj, {
				  mid_x: pos.mid_x,
				  mid_y: pos.mid_y,
				  rotate: positions[index].rotate
				}, {
				  duration: 10,
				  name: 'card_move',
				  replace_existing: true,
				}),

			   set(card_obj.zorder, pos.zorder),
			   set(card_obj.card_size, pos.card_size),
		   ])
		 ],

	     spawn('card', pos.mid_x, int(card_top),
		 {
			facing: 1,
			controller: me,
			in_hand: true,
			hand_index: index,
			zorder: pos.zorder,
			rotate: positions[index].rotate,
			card_size: pos.card_size,
			player: state.players[state.nplayer],
			card_type: value,
		 }, 
		 [
		    set(child.mid_x, pos.mid_x),
			set(child.mid_y, pos.mid_y),

			//make the new card animate its way in if it's just been drawn.
			fire_event(child, 'animate_draw'),

			set(child.highlight, highlight_card),

		  ])
		),
		add(_card_regions, [{left: int(pos.mid_x - card_width/2), right: int(pos.mid_x + card_width/2), top: int(card_top), card_num: index}] where card_width = 160)
		]
		 
		 where card_obj = null|obj card :: find_card_obj(card_instance)
		 where pos = positions[index]
		 where highlight_card = state.in_response_phase and card_instance.is_response and state.players[state.nplayer].can_afford_with_discards(card_instance)
		 where card_instance = class card :: value
	   ) where positions = cards_in_hand_positions(state.players[state.nplayer].hand),

	   set(me._card_hand_top, card_top),

	   update_archive_count(),
	]
  where card_top = decimal :: top_player_area
  where hand_size = int :: size(state.players[state.nplayer].hand)
	",

	create_avatars: "def() ->commands [
		map(_avatars, remove_object(value)),
		set(_avatars, []),

		map(_avatar_life, remove_object(value)),
		set(_avatar_life, []),

		map(state.players, spawn('player_avatar', 200, 200, {
			_avatar: player.avatar,
			zorder: get_zorder('avatars'),
			_top: bot_opponent_area,
			_width: (100 + top_player_area - bot_opponent_area)/2,
			_height: top_player_area - bot_opponent_area,
			_edge: if(index = state.nplayer, avatar_width, level_width - avatar_width),
			_available_space: avatar_width,
			_nick: player.name,
			facing: if(index = state.nplayer, 1, -1),
			highlight: state.current_player_index = index,
			current_desaturation: if(prev_avatar, prev_avatar.current_desaturation, if(state.current_player_index = index, 0.0, 1.0)),
			target_desaturation: if(state.current_player_index = index, 0.0, 1.0),
		}, [
			add(_avatars, [child])
		]) where player = value
		   where prev_avatar = if(index < size(_avatars), _avatars[index])),

		[debug(['HAVE PLAYER DAMAGE: ', hint.source.loc])  | hint <- state.animation_hints, hint is class animation.player_damage_hint],

		map(state.players, spawn('label', 200, 200, {
			_text: [str(player.life)],
			zorder: get_zorder('life_labels'),
			mid_x: if(index = state.nplayer, avatar_width/2 - 66, 66 + level_width - avatar_width/2),
			mid_y: bot_opponent_area + 38,
			_outline_width: 0,
			_font: lib.citadel.sans_font,
		}, [
			add(me._avatar_life, [child]),
			if(prev_label != null and prev_label.get_text() != child.get_text(), [
				add_object(prev_label),
				add(child.mid_y, -30),

				set(child.alpha, 0),

				animate(child, {
					alpha: 0,
				}, {
					name: 'move',
					duration: 150,
				}),

				animate(child, {
					mid_y: child.mid_y,
					alpha: 255,
				}, {
					name: 'move',
					duration: 20,
				}),

				animate(prev_label, {
					alpha: 255,
				}, {
					name: 'move',
					duration: 150,
				}),

				animate(prev_label, {
					mid_y: prev_label.mid_y + 30,
					alpha: 0,
				}, {
					name: 'move',
					duration: 20,
					on_complete: remove_object(prev_label),
				}),

			]),
		]) where player = value
		   where prev_label = if(index < size(_avatar_life), _avatar_life[index])),
		
		//spawn level symbols
		map(state.players,
		
		map(sorted_objects, [
			if(value.order = -1, add_object(value)),
			set(value.order, order),
			set(value.mid_x, if(player_index = state.nplayer, avatar_width + positions[index][0], level_width - avatar_width - positions[index][0])),
			set(value.mid_y, (top_player_area + bot_opponent_area)/2 + positions[index][1]),
			set(value.xp, player.xp_level[value.school]),
			set(value.xp_needed, player.xp_needed[value.school]),
			set(value.lvl, player.resource_level[value.school]),

			animate(value, {
				alpha: 255,
			}, {
				duration: 20
			}),

			fire_event(value, 'update'),
		] where positions = [[-70,0],[-70,-66],[-70,66],[-4,-33],[-4,33]]
		  where order = if(value.order = -1, highest_order + index + 1, value.order)
		)
		where sorted_objects = sort(objects, if(a.order=-1, 10000, a.order) < if(b.order=-1, 10000, b.order))
		where highest_order = if(val, val, 0) where val = max(map(objects, value.order))
		where objects = [if(existing, existing,
		   object('level_display', 0, 0, {lvl: 0, xp: 0, xp_needed: 0, school: school, player_num: player_index, alpha: 0, zorder: get_zorder('hud')}))
		     where existing = find(level.chars, value is obj level_display and value.school = school and value.player_num = player_index)
		 | school <- schools]
		where schools = filter(keys(player.resource_level), player.resource_level[value] > 0)
		where player = value
		where player_index = index),

		[remove_object(c) | c <- level.chars, c is obj creature_in_citadel],

		//display mana.
		map(state.players, [
			if(existing = null, add_object(obj)),
			set(obj.amount, value.resources),
			set(obj.amount_delta, count(state.villages, value.controller = player_index)),
			fire_event(obj, 'update'),

			if(existing_life = null, add_object(obj_life)),
			set(obj_life.amount, value.life),
			//set(obj_life.amount_delta, -size(value.creatures_in_citadel)),
			fire_event(obj_life, 'update'),


		] where obj = if(existing, existing, object('mana_display', 0, 0, {
			amount: 0,
			player_num: index,
			zorder: get_zorder('hud'),
			y2: top_player_area-10,
			mid_x: if(index = state.nplayer, pos, level_width - pos) where pos = max(60, avatar_width/2 - 30),
		})) where obj_life = if(existing_life, existing_life, object('mana_display', 0, 0, {
			amount: 0,
			player_num: index,
			icon: 'gui_life.svg',
			title: 'LIFE',
			zorder: get_zorder('hud'),
			mid_x: if(index = state.nplayer, pos + 60, level_width - pos - 60) where pos = max(60, avatar_width/2 - 30),
			y2: top_player_area - if(index = state.nplayer, 54, 70),
		}))
		  where existing = find(level.chars, value is obj mana_display and value.player_num = player_index and value.icon = 'mana.svg')
		  where existing_life = find(level.chars, value is obj mana_display and value.player_num = player_index and value.icon = 'gui_life.svg')
		  where player_index = index
		)
	]",

	spawn_chat_widgets: "def() ->commands [

	]",

	spawn_opponent_cards: "def() ->commands [
	  //get rid of existing opponent cards that should no longer be there.
	  [ if(card.card_type.orphaned_by_update,
	  	   animate(card, {
			mid_x: 60,
			mid_y: 204,
			scale: 0.5,
			rotate: 0,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   }),
		   remove_object(card))

	   | card <- level.chars, card is obj card, card.in_opponent_hand, find(hand, value = card.card_type) = null],

	  //create new card objects and update existing ones.
	  map(pos, if(obj = null, spawn('card', 0, 0, {
			 zorder: value.zorder,
			 rotate: -value.rotate,
			 show_back: observer = false,
			 in_opponent_hand: true,
			 card_type: hand[index],
			 controller: me,
			 mid_x: 80,
			 mid_y: 80,
			 rotate: 0,
			 upside_down: 1,
			 scale: 0.4,
		},
		[
			animate(child, {
				mid_x: if(index = _opponent_hand_mouseover and _opponent_card_playing, 160, value.mid_x),
				mid_y: if(index = _opponent_hand_mouseover and _opponent_card_playing, 160,
				          level_height - value.mid_y - 130 - if(level_height < 900, 900 - level_height, 0)/3 + if(index = _opponent_hand_mouseover, 20, 0)),
				rotate: if(index = _opponent_hand_mouseover, 0, -value.rotate),
				scale: if(observer, 0.4, 1.0),
			}, {
				duration: 25,
			}),
		]),

		[
			animate(obj, {	
				mid_x: if(index = _opponent_hand_mouseover and _opponent_card_playing, 160, value.mid_x),
				mid_y: if(index = _opponent_hand_mouseover and _opponent_card_playing, 160, level_height - value.mid_y - 130 - if(level_height < 900, 900 - level_height, 0)/3 + if(index = _opponent_hand_mouseover, 20, 0)),
				rotate: if(index = _opponent_hand_mouseover, 0, -value.rotate),
			}, {
				duration: 10,
			}),
			set(obj.zorder, value.zorder),
		]

		)

	  where obj = find(level.chars, value is obj card and value.in_opponent_hand and value.card_type = hand[context.index]))
	]
      where pos = cards_in_hand_positions(hand)
	  where hand = state.players[(state.nplayer+1)%2].hand
	",

	_calculate_end_of_turn_state: "def(class game state) ->class game
		if(state.current_choice != null or
		   (not state.in_response_phase) and
		   state.has_unresolved_combat = false,
		   state, _calculate_end_of_turn_state(get_modified_object(state, def(class game g) g.end_turn())))
	",

	spawn_game_icons: "def(class game state) ->commands [
		[remove_object(icon) | icon <- level.chars, icon is obj game_icon, icon.user_info = 'status_icon'],
		[spawn('game_icon', pos[0]+50, pos[1] + if(state.nplayer != c.controller, 100, 0), {size: 48, zorder: get_zorder('status_icon'), icon: 'crossed-axes.svg', user_info: 'status_icon'}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.is_engaged(state)],

		[spawn('game_icon', pos[0]+50, pos[1] + 40, {size: 48, zorder: get_zorder('status_icon'), icon: 'bowman.svg', user_info: 'status_icon'}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.is_exhausted = false, c.is_engaged(state) = false, c.range > 0, size(c.targets_attacking(state)) > 0],

		[map(filter(map(c.status_effects, icon_info[value]), value != null),
		     spawn('game_icon', pos[0]+90 - index*4 - index*index*2, pos[1] + 50 - 20*index,
			   {size: 24, user_info: 'status_icon', zorder: get_zorder('status_icon')} + value))
		  where pos = get_tile_pos(c.loc) | c <- state.creatures]
		     where icon_info = {string -> map} <-
			     get_document('data/status_effect_icons.cfg'),

		if(end_of_turn_state != null,
		   [ spawn('game_icon', pos[0]+50, pos[1] + 40, {size: 48, zorder: get_zorder('status_icon'), icon: 'skull-crack.svg', alpha: 0, user_info: 'status_icon'}, [map(range(20), set(child.alpha, value*10))]) where pos = get_tile_pos(c.loc) | c <- state.creatures, find(end_of_turn_state.creatures, c.summon_id = value.summon_id) = null]),
	]",
	
	get_tile_pos: "def(Loc pos) ->Loc [
		(level.dimensions[2] - board_width)/2 + pos[0]*tile_x_spacing,
		board_ypos + if(state.nplayer = 0, (state.columns-1) - pos[1], pos[1]+1)*tile_x_spacing + if(pos[0]%2 = 1, 0, if(state.nplayer = 0, 1, -1)*tile_x_spacing/2),
	]",

	_sent_game_result: { default: false },

	_resource_y_pos: "def(bool is_local, int nresource, int max_resource) ->int
	   if(is_local, level_height - 380 - nresource*54,
			        260 + nresource*54)",

	_xp_objects: { type: "[custom_obj]", default: [] },

	_mana_x_pos: "def(int nmana, int max_mana) ->int
	   40 + nmana*spacing where spacing =  int(min(40, (level_width*0.2)/max_mana))",
	
	_processed_animation_hints: { type: "[class animation.gain_mana_hint]", default: [] },

	display_player_mana: "def(class game state) ->commands [
	   set(_processed_animation_hints, filter(state.animation_hints, value is class animation.gain_mana_hint)),

	   map(state.players, map(range(max(value.resources, 0)),spawn('game_icon', _mana_x_pos(index, context.value.resources), if(context.index != state.nplayer, 100, 600), { icon: 'mana.svg', size: 32, user_info: 'player_mana', zorder: get_zorder('mana_symbols') },
	     [
		   //if we have an animation hint regarding this mana item, we
		   //animate its entry
		   if(anim_index < size(mana_anim) and mana_display, [
			 set(child.mid_x, source_pos[0]),
			 set(child.mid_y, source_pos[1]),
			 set(child.size, 32),
			 set(child.alpha, 0),
			 animate(child, {
				mid_x: mana_display.mid_x,
				size: child.size,
			 }, {
				duration: 40,
				easing: 'swing',
			 }),

			 animate(child, {
				mid_y: mana_display.mid_y,
			 }, {
				duration: 30,
				easing: 'swing',
			 }),

			 animate(child, {
				alpha: 255
			 }, {
				name: 'fade',
				duration: 6,
			 }),

			 animate(child, {
				alpha: 255
			 }, {
				name: 'fade',
				duration: 30,
			 }),

			 animate(child, {
				alpha: 0
			 }, {
				name: 'fade',
				duration: 10,
				on_complete: remove_object(child),
			 }),


		   ] where source_pos = if(anim.move_from is Loc,
		      map(get_tile_pos(anim.move_from), value+50),
			  if(card_obj != null, [card_obj.mid_x, card_obj.mid_y],
					               [child.mid_x, child.mid_y])
			  where card_obj = find(level.chars, value is obj card and value.card_type.draw_id = anim.card_from))
		     where anim = mana_anim[anim_index],
			 
			 //no animation hint so just remove it.
			 remove_object(child))
			   where anim_index = state.players[nplayer].resources - index - 1
			   where mana_display = find(level.chars, value is obj mana_display and value.player_num = nplayer)
		 ]))
	   where mana_anim = [class animation.gain_mana_hint] ::
	          filter(state.animation_hints,
			         value is class animation.gain_mana_hint and
					 value.player = nplayer and
					 find(_processed_animation_hints, context.value = value) = null)
	   where nplayer = index)
	]",

	count_cards_in_archive: "int :: count(level.chars, value is obj card and value.keep)",
	update_archive_count: "def() ->commands
	  if(archive != null, [set(archive.amount, count_cards_in_archive), fire_event(archive, 'create')])
	  where archive = find(_display_area_labels, value.purpose = 'archive')",

	display_game_status: "def(class game state) ->commands [

		map(_display_area_labels, remove_object(value)),
		set(_display_area_labels, []),

		map(state.players, [

		spawn('display_area_label', 0, 0, {
			_text: 'C R Y P T',
			amount: size(player_obj.visible_discard_pile),
			_xpos: int(left_edge_display_areas - display_area_width),
			_ypos: yy,
			zorder: get_zorder('hud'),
		}, [add(_display_area_labels, [child])]),

		spawn('display_area_label', 0, 0, {
			_text: 'F U R N A C E',
			amount: size(player_obj.discard_pile) - size(state.players[state.nplayer].visible_discard_pile),
			_xpos: int(left_edge_display_areas),
			_ypos: yy,
			zorder: get_zorder('hud'),
		}, [add(_display_area_labels, [child])]),

		spawn('display_area_label', 0, 0, {
			_text: 'A R C H I V E',
			amount: count_cards_in_archive,
			_xpos: int(right_edge_display_areas + display_area_width),
			_ypos: yy,
			purpose: if(is_opponent, '', 'archive'),
			zorder: get_zorder('hud'),
		}, [add(_display_area_labels, [child])]),

		spawn('display_area_label', 0, 0, {
			_text: 'L I B R A R Y',
			amount: size(player_obj.deck),
			_xpos: int(right_edge_display_areas + display_area_width*2),
			_ypos: yy,
			zorder: get_zorder('hud'),
		}, [add(_display_area_labels, [child])]),

		] where yy = int(if(is_opponent, bot_opponent_area-10, top_player_area+30))
		  where player_obj = state.players[index]
		  where is_opponent = (index != state.nplayer))

	]",
	
	display_choice: "def(class game state) ->commands [
	  if(_choice_object, [_choice_object.destroy(), set(_choice_object, null)]),
	  if(state.current_choice and state.current_choice.player_index = state.nplayer,
	  	spawn('choice_controller', 0, 0,
		{
			facing: facing,
			game: state,
		}, [
			set(_choice_object, child),
			debug('spawned choice'),
		 ]))
    ]",

	update_log: "def(class game game) ->commands
	 log_controller.set_log([string]<- game.log, if(_state, myplayer, null))
	  asserting log_controller
	  where log_controller = find(level.chars, value is obj log_controller)",
	
	bdk: "def(string bot_name) ->commands [
		if(_bdk_controller, remove_object(_bdk_controller)),
		spawn('bdk_controller', 0, 0, { controller: me }, [
			child.load(bot_name),
			set(_bdk_controller, child),
		]),
	]",

	force_submit_deck: "def([string] deck) ->commands
		execute(me, tbs_send(client, {type: 'submit_deck', deck: deck, force: true}))",

	top_player_area: "int :: level_height - if(level_height >= 900, 250, 250 - (900 - level_height)/3)",

	bot_opponent_area: "int :: if(level_height >= 900, 80, 80 - (900 - level_height)/2)",
	avatar_width: "min((100 + top_player_area - bot_opponent_area)/2,
		                           (level_width - 400) / 2)",

	award_card: "def(string card_name) ->commands [

		spawn('card', level_width/2, level_height/2,
		  {
			 card_type: lib.citadel.create_card(card_name),
			 controller: me,
			 in_hand: false,
			 allow_drag: false,
			 card_size: 0.6,
			 alpha: 0,
			 zorder: 20000,
		  },
		  [

		  	animate(child, {
				card_size: 2.0,
				alpha: 255,
			}, {
				name: 'present',
				duration: 100,
			}),

		  	animate(child, {
				alpha: 255,
			}, {
				name: 'present',
				duration: 150,
			}),

		  	animate(child, {
				card_size: 4.0,
				alpha: 0,
			}, {
				name: 'present',
				duration: 50,
				on_complete: remove_object(child)
			}),

		spawn('hint_label', 0, 0, {
			zorder: 10000,
			_text: ['You have won a new card!'],
			subject: child,
			_delay: 50,
		}, [
			schedule(250, remove_object(child))
		]),
	  
		  ]
		)
	]",
},

on_settings_menu: "if(level.show_builtin_settings_dialog and not paused, [
	set(level.show_builtin_settings_dialog, false),
	spawn('pause_dialog', 0, 0, { _mm: me, _controller: me, }),
])",

on_generate_mouseover_card: "mouse_enter_card(obj card<- arg.card)",

on_construct: "[set(lib.citadel.native_card_sizes, [0.8,1.0,2.0])]",

on_create: "[ 
	debug('ZZZ: CREATE: ' + _mm_client_state.tutorial),
	if(_mm_client_state.tutorial is string, set(_tutorial, class client_tutorial<- construct('client_' + _mm_client_state.tutorial))),

	add(level.frame_buffer_shaders, [{
		begin_zorder: -1000000,
		end_zorder: get_zorder('board_shader'),
		shader_info: 'citadel_board_shader',
	}]),

	fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),
	console_output_to_screen(false),
	
	if(observer,
	[
		set(me._client, cl),
		tbs_send(cl, {type: 'observe_game', user: USERNAME}),
	] where cl = create_tbs_client(),

	if(size(get_module_args()) > 0, 
	[set(me._client, cl),
	tbs_send(cl, {type: 'start_game'}), debug('game created')] where cl = create_tbs_client(),
	if(game_created, 
	[set(me._client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		where cl = create_tbs_client()
	)))
]
",

on_update_discard_and_deck: "[
	map(_deck_obj, value.set_label(str(size(state.players[index].deck)), me.font)),
	//map(_display_icons, if(value, value.set_label(str(size(state.players[index].discard_pile)), me.font))),
]",

on_window_resize: "[
debug('ZZZ RESIZE: ' + [new_width,new_height]),
	[ [add(card_back.x, delta_w)]
	| card_back <- level.chars,
	  card_back is obj citadel_controller.card_back,
	  card_back.player_index = 1],

	[ tile.destroy() | tile <- level.chars, tile is obj tile ],

	set(level.dimensions, [0,0,new_width,new_height]),

	fire_event('dimensions_updated'),

] where delta_w = new_width - level_width
  where delta_h = new_height - level_height
  where card_width = min(135*card_scale, if(hand_size, card_area/hand_size, 100))
  where card_scale = max(1.0, decimal(card_area)/decimal(1024 - 300))
  where card_area = new_width - 300
  where new_width = max(int<- arg.width,1024)-1
  where new_height = max(int<- arg.height,768)-1
  where hand_size = count(level.chars, value is obj card and value.in_hand)",

on_dimensions_updated: "[

	if(_background_canvas, remove_object(_background_canvas)),

	spawn('canvas', 0, 0, {zorder: -10}, [
		child.draw(bg_width, bg_height, [
			c.scale(bg_width/888.0, bg_height/423.0),
			c.paint_image('images/citadel-background.png')
		] where c = canvas()),
		set(child.mid_x, level_width/2),
		set(child.y, bot_opponent_area),
		set(_background_canvas, child)
	])
	where bg_width = level_width - avatar_width*2
	where bg_height = top_player_area - bot_opponent_area,

	set(draw_primitives, [
	{
		type: 'rect',
		area: [0,0,level_width,bot_opponent_area],
		color: [0,115,105],
	},
	{
		type: 'rect',
		area: [0,top_player_area,level_width,level_height],
		color: [0,115,105],
	},
	
	] + fold(map([left_edge_display_areas-display_area_width*2,left_edge_display_areas-display_area_width,left_edge_display_areas,right_edge_display_areas,right_edge_display_areas+display_area_width,right_edge_display_areas+display_area_width*2], 

	[
	{
		type: 'rect',
		area: [line_pos,0,line_pos,bot_opponent_area-30] where line_pos = value,
		color: 'white',
	},
	{
		type: 'rect',
		area: [line_pos,top_player_area+30,line_pos,level_height-40] where line_pos = value,
		color: 'white',
	}
	]
	), a+b)),

	spawn_chat_widgets(),

	if(_last_state_message, [
        display_choice(state),
		set_widgets_for_message(state),
		set_schedule_for_message(state),
		spawn_trophies(state),
		spawn_tiles(state),
		adapt_input_state(),
		display_game_status(state),
		display_player_mana(state),
		update_log(state),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		spawn_opponent_cards(),
		update_schedule_objects(),

		fire_event('game_updated'),
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0,
	       { controller: me, game_state: state, facing: 1, creature_object: creature.creature_object, hex_height: tile_width })
	          asserting creature.creature_object]
	| creature <- level.chars,
	  creature is obj creature,
	  creature.creature_object.is_on_board ]
]",

on_update_spells_on_stack: "
 [
  set(_spells_on_stack, survivors),
  map(leaving, execute(value, [
	if(_spell_windup_sound_being_played, stop_sound(_spell_windup_sound_being_played, 0.5)),
	[schedule(n, [
	  map(value.draw_primitives, set(value.color, [255,0,0,255-n*10]))])
	  | n <- range(25)],
	schedule(26, remove_object(value)),
  ]))
 ]
  where leaving = filter(_spells_on_stack, not card_on_stack(value))
  where survivors = filter(_spells_on_stack, card_on_stack(value))",

on_update_game: "
   if((not force_process) and
      (_game_state_queue != [] or level.cycle < _animation_end_time),
	 add(_game_state_queue, [message]),

     if(state_id > _processed_state_id,
	 [
	    if(_state != null and _state._uuid = game_state._uuid,
		   [update_object(_state, game_state)],
		   set(_state, game_state)
		),

		if(is_new_turn or _state = null, spawn('turn_banner', 0, 0, {
			_text: if(observer, game_state.players[game_state.current_player_turn_index].name + q('s Turn), if(is_your_turn, 'Your Turn', q(Opponent's Turn))),
			zorder: 4000,
		})),

	    set(me._processed_state_id, state_id),

	    set(_last_state_message, message),

		set(end_of_turn_state, _calculate_end_of_turn_state(game_state)),

		set(force_skip_responses, new_force_skip_responses),

		// automatically send end turn in response phases.
		if(observer = false and game_state.nplayer = game_state.current_player_index and game_state.in_response_phase and (new_force_skip_responses or game_state.players[game_state.nplayer].has_possible_response(game_state) = false), end_turn()),

		fire_event('game_updated'),
     ]
	 //we are force skipping responses until the next turn
	 where new_force_skip_responses = force_skip_responses and not (is_new_turn and is_your_turn)
	 where is_your_turn = (game_state.nplayer = game_state.current_player_index)
	 where is_new_turn = (_state != null and _state._uuid = game_state._uuid and game_state.nturn != _state.nturn)
     where game_state = class game<- message.state
))
     where state_id = int<- message.state_id
     where message = map<- arg.message,
         force_process = null|bool<- arg.force_process
",

on_game_updated: "[
	 	adapt_input_state(),

		[
			create_avatars(),

			debug('game updated'),
		    map(_deck_obj + _display_icons + _hand_obj + _level_obj,
			    if(value, remove_object(value))),
//			set(_deck_obj, deck_obj),
			set(_display_icons, display_icons),
			set(_hand_obj, hand_obj),
			set(_level_obj, level_obj),
//			map(display_icons, if(value, set(value.player_index, index))),
//			map(deck_obj, set(value.player_index, index)),
			map(hand_obj, set(value.player_index, index)),
			map(level_obj, set(value.player_index, index)),
			map(hand_obj, set(value.animation, 'hand')),
			map(level_obj, set(value.animation, 'hand')),
//			map(deck_obj, set(value.scale, 1.0)),
//			map(display_icons, if(value, set(value.scale, 1.0))),
			map(hand_obj, set(value.scale, 0.5)),
			map(level_obj, set(value.scale, 0.5)),
//			map(deck_obj, add_object(value)),
			map(display_icons, if(value, add_object(value))),
			map(hand_obj, add_object(value)),
			map(level_obj, add_object(value)),
		] where deck_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', 84, if(index = game_state.nplayer, top_player_area + 130, -48), 1, {controller: me} ))
		  where display_icons = map(
		    ['crypt.svg', 'furnace.svg', 'archive.svg', 'library.svg'],
			object('game_icon', positions[index],
			       (top_player_area + level_height)/2, 1,
				   {icon: value, size: 96.0, draw_circle: true, zorder: get_zorder('hud')}) )
		     where positions = [
			   int(left_edge_display_areas - display_area_width*1.5),
			   int(left_edge_display_areas - display_area_width*0.5),
			   int(right_edge_display_areas + display_area_width*0.5),
			   int(right_edge_display_areas + display_area_width*1.5),
			 ]
		  where hand_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 250, level_width - 250), 450, 1, {controller: me} ))
		  where level_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 250, 1, {controller: me} )),

	 	reserve_animation_time(10),
		map(animation_hints, handle_animation_hint(value)),
		set(_animation_hints_id, game_state.animation_hints_id),
		set(_furthest_animation_hint, size(game_state.animation_hints)),
		debug('SET NEW STATE'),


		display_game_status(game_state),
		display_player_mana(game_state),
		display_choice(game_state),
	    if(creature_status,
			if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
			   where creature = find(game_state.permanents,
			        value.summon_id = creature_status.creature_object.summon_id)
				
				) where creature_status = find(level.chars, value is obj creature_status),
	    [

		//cards to discard.
		[
		   //animate to the discard pile and then disappear.
		   animate(card, {
			mid_x: 60,
			mid_y: level_height - 200,
			scale: 0.5,
			rotate: 0,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   })

		| card <- level.chars,
		  card is obj card, card.in_hand,
		  find(myplayer.hand, value = card.card_type) = null
		],
		
		[card.destroy() | card <- level.chars,
		 card is obj card,
		 card.in_hand = false and card.in_opponent_hand = false and
		 card.card_type.orphaned_by_update
		],

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(game_state),
		spawn_trophies(game_state),
	  ],

	  if(game_state.in_response_phase and game_state.nplayer = game_state.current_player,
		[

	      set(_response_pause_counter, -1),
		  set_status_label(if(game_state.stack, '', 'Combat phase -- ') + 'Response phase', 'white', 150),

	   //   set(_response_pause_counter, 150),
	//	  set_status_label(if(game_state.stack, '', 'Combat phase -- ') + 'Press SPACE if you want to respond', 'white', 150),
		],

		[
			set(_response_pause_counter, -1),
		]
	  ),

	  set_widgets_for_message(game_state),
	  set_schedule_for_message(game_state),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(game_state.creatures,
		                     value.summon_id = creature.summon_id) or
							 game_state.graveyard[creature.summon_id]
	    where creature = obj.creature_object
		| obj <- level.chars, obj is obj creature],
		value), 30, 0)), 

	  map(filter(level.chars, value is obj creature and
	          find(game_state.permanents,
			       context.value.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = game_state.graveyard[value.creature_object.summon_id]), 
	  [fire_event(card, 'game_updated') | card <- level.chars, card is obj card],
	  [
	    spawn_opponent_cards(),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		update_schedule_objects(),
		if(drawn_cards > 0, reserve_animation_time(30 + 10*size(game_state.players[game_state.nplayer].hand)))
	  ]
		  where drawn_cards =
		    fold([hint.ncards | hint <- animation_hints,
		                        hint is class animation.draw_cards_hint,
							    hint.player = game_state.nplayer], a+b, 0),
	  

	  map(game_state.permanents,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     [set(obj.game_state, state),
			  set(obj.creature_object, value),
			 if(card_rules, set(value.rules, card_rules))],
	      
		  //create a new object to represent this creature.
		  [debug('SPAWN CREATURE: ' + value.name),
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: value,
				  game_state: state,
				  controller: me,
				  hex_height: tile_width,
				},
				[if(card_rules, set(value.rules, card_rules)),
				 if(move_hint != null, child.teleport_and_walk_from(move_hint.move_from)) where move_hint = find(animation_hints, value is class animation.move_hint and value.creature = context.value)] asserting value)])
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value is obj creature and
		                                value.creature_object.summon_id = context.value.summon_id) where card_rules = if(doc and doc.rules, string<- doc.rules, '')
										where doc = map|null<- lib.json.get_document_map('data/cards.cfg')[value.name]),
	
	  spawn_game_icons(state),
										
	  if(game_state.winner, 
			  
	   [
	   if(observer = false and _sent_game_result = false,
		[
		debug('ZZZ SEND GAME RESULT'),
		set(_sent_game_result, true),
	   	if(mm_client, tbs_send(mm_client, {
			type: 'finish_bot_game',
			user: myplayer.name,
		   })),
		]),

	   set_widgets(me, {
		id: 'winner_dialog',
		type: 'dialog',
		background_alpha: 255,
		background_frame: 'empty_window',
		zorder: get_zorder('winner_dialog'),
		rect:[-50, -50, 500, 100],
		children: [
			{
				type:'grid', 
				columns:1, 
				xy:[0,20], 
				column_widths:500, 
				column_alignments:'center', 
				children: [
					{
						type: 'label',
						size: 40, 
						zorder: get_zorder('winner_dialog'),
						text: game_state.winner.name + ' Wins!', 
						font: 'RobotoCondensed-Bold', 
						color: 'red'
					},

					{
						type: 'button',
						color_scheme: lib.citadel.button_color_scheme,
						label: {type: 'label', font: font, size: 18, color: font_color, text: 'Leave Game'},
						on_click: bind(me.return_callback, game_state.winner = game_state.players[0]),
					},

					{
						type: 'button',
						color_scheme: lib.citadel.button_color_scheme,
						label: {type: 'label', font: font, size: 18, color: font_color, text: 'Rematch'},
						on_click: me.restart_game,
					},

				]
			}
		],
	  })
	  ]),

	  update_log(game_state),


fire_event('update_discard_and_deck')

]
  where animation_hints =
   if(_animation_hints_id != game_state.animation_hints_id,
	  game_state.animation_hints,
	  game_state.animation_hints[_furthest_animation_hint:])
  where game_state = state
",

on_message_received: "[
  trigger_garbage_collection(),
  switch(message.type,
		 'message', [], //has message.message with the server message.

		 'chat_message',
		 if(message.sub_type = 'presence',
		   if(_state != null and message.nick = enemy_player.name and message.info is map,
			_received_presence_state(map<- message.info)
		   ),
		   [], //has {text: string, nick: string}
		   ),
		 
		 'game_created',
         [set(me._client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = create_tbs_client(),

         'game',
		 if(game_state.players[game_state.nplayer].deck_submitted = false,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
			if(selected_deck and user_decks, [
				map(user_decks[selected_deck].cards, null asserting lib.json.get_document_map('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
				tbs_send(me.client, {type: 'submit_deck', deck: deck}) asserting deck,
				] where deck = user_decks[selected_deck].cards,
				null asserting selected_deck | 'must specify a deck')
		  ]
		    where user_decks = lib.citadel.get_decks(),
	
	    [
	    set(me._state_id, max(_state_id, int<- message.state_id)),
		fire_event('update_game', {message: message})
		]
	   ) where game_state = class game<- message.state, // end 'game' case.

         //default case.
         [debug('got message: ', message)]) asserting message.type != 'invalid_session',
		 fire_event('request_updates')]
	 where message = map<- arg.message",

on_request_updates: "if(client.in_flight = 0,
					      [debug('request_updates: ' + _state_id), tbs_send(client, { type: 'request_updates', state_id: _state_id })])",
on_connection_error: "[debug('message error', string<- arg.error), fire_event('request_updates')]",

on_process: "
 [
  process_hex_intensity(),

  _process_presence_state(),

  if(_end_turn_pending, end_turn()),
  [

  if(card_mouseover and card_mouseover.in_hand and card_mouseover.hand_index != card_over,
     mouse_leave_card(card_mouseover)),
  if(card_over != -1 and (card_mouseover = null or card_mouseover.hand_index != card_over),
	 mouse_enter_card(find_or_die(level.chars, value is obj card and value.in_hand and value.hand_index = card_over))
  )
  ] where card_over = _hand_card_moused_over,

  set(me._prev_ctrl_keys, level.player.ctrl_keys),

  if(_response_pause_counter > 0, [
	  add(_response_pause_counter, -1),
	  if(' ' in level.player_info.ctrl_keys, [
		set(_response_pause_counter, -1),
		set_status_label('Take your time to think about how you want to respond', 'white'),
	  ])
  ]),
  if(_response_pause_counter = 0, [
	set(_response_pause_counter, -1),
	tbs_send(client, {
	 type: 'moves',
	 state_id: _state_id,
	 moves: [end_turn_message]
	}),
  ]),
  if(_animated_spell_card,
	 if(_spell_animation_time >= 100, [
			 debug('REMOVE SPELL: ' + if(_animated_spell_card in level.chars, true, false)),
		add(_spells_on_stack, [_animated_spell_card]),
		set(_animated_spell_card, null),
		set(_spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(_spell_animation_time = 80 and (level.player_info.ctrl_mod_key in [1,2]),
	     reserve_animation_time(20),
	 [
	    add(_spell_animation_time, 1),
		if(_spell_animation_time <= 20, [
			set(_animated_spell_card.alpha, new_alpha),
			map(_animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = if(_spell_animation_time <= 20, _spell_animation_time*22, (100 - _spell_animation_time)*22)
			),
	 ]))), //end animated_spell_card

  if(_game_state_queue != [] and level.cycle >= _animation_end_time,
	[
	  set(_game_state_queue, _game_state_queue[1:]),
	  fire_event('update_game', {message: _game_state_queue[0], force_process: true})
	]),
	process_connection(),
 ]",

on_end_anim: "animation('normal')",
timer_frequency: 10,
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [

	{
		id: "schedule_canvas",
		animation: [
			{
				id: "day",
				image: "schedule/schedule-afternoon.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "none",
				image: "schedule/schedule-afternoon.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "dawn",
				image: "schedule/schedule-dawn.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "night",
				image: "schedule/schedule-secondwatch.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "dusk",
				image: "schedule/schedule-dusk.png",
				rect: [0,0,123,38],
				scale: 1,
			},
		],
	},

	{
		id: "furnace",
		animation: [{
			id: "normal",
			image: "furnace_ico.png",
			rect: [0,0,88,126],
			scale: 1,
		}],

		properties: {
			controller: { type: "obj citadel_controller" },
			player_index: { default: 0 },
			set_label: "def(string text, string font) ->commands []",
		},
	},

	{
		id: "card_back",
		animation: [
			{
				id: "normal",
				image: "card-back.png",
				rect: [0,0,147,261],
				scale: 1,
			},

			{
				id: "front",
				image: "card-citadel.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "hand",
				image: "card-hand.png",
				rect: [0,0,145,203],
				scale: 1,
			},
		],

		properties: {

			set_label: "def(string text, string font) ->commands execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'black',
				x: 74,
				y: 80,
			}]))",

			set_text: "def([string] text_list, string font) ->commands execute(me, set_widgets(
			  map(text_list, {
			  	type: 'label',
				text: value,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'white',
				x: 74,
				y: 40 + index*26
			  })))",

			set_widgets: "def([map] widgets) ->commands execute(me, set_widgets(widgets))",

			player_index: { default: 0 },
			controller: { type: "obj citadel_controller" },
		},

		on_mouse_enter: "if(controller, controller.mouse_enter_discard(player_index))",
		on_mouse_leave: "if(controller, controller.mouse_leave_discard(player_index))",
		on_click: "if(controller, controller.mouse_click_discard(player_index))",
	},

	{
		id: "status_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			init_label: "def(string text, Color color, int card_top) ->commands
			execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				color: color,
				size: 18,
				x: 100,
				y: card_top - 20,
			}]))",

			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		},
	},

],
}
