{
id: "citadel_controller",
prototype: ["citadel_controller_base"],
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,
zorder: 190,

properties: {
	_theme: { type: "class theme", init: "lib.theme" },

	game_log: {
		type: "[map]",
		default: [],
		set: "[
			write_document('last-game-log.cfg', value),
			set(_data, value)
		]",
	},

	_storyline: { type: "obj storyline_base", init: "object('storyline_null')" },

	in_background: { default: false },

	get_mm_client_state: "def() ->class mm_client_state _mm_client_state",

	testtest: "c.render(512, 512, [
		c.set_operator('OVER'),
		c.rectangle(0, 0, 256, 512),
		c.set_source_rgba(1, 1, 1, 0.5),
		c.set_operator('OVER'),
		c.rectangle(0, 0, 256, 512),
		c.set_source_rgba(1, 1, 1, 0.5),
		c.fill(),
	]).save('test.png') where c = canvas()",

	render_card_image_to_file: "def(string card_name, decimal size, string fname='card.png') ->commands
		object('card', 0, 0, {
			 card_type: lib.citadel.create_card(card_name),
			 controller: me,
			 card_size: size
		}).render_card_to_file(size, fname)
	",

	output_cards_in_set: "def(string set) ->commands
	map(cards, render_card_image_to_file(value.name, 2.0,
	  'all-cards/' + (string<- set) + '-' +
	   (string<- if(size(value.school_list) > 1, 'multi',
	       if(value.first_school = -1, 'none',
			  SCHOOL_NAMES[value.first_school])
	   )) + '-' +
	   if(value.artist in [null,'eleazzaar'], 'incomplete', 'complete') + '-' +
	   (string<- sum(map(value.name, if(value = ' ', '-', value)), '')) + '.png'
	  )
	)
	where cards = lib.citadel.get_card_objects_in_set(set)
	",
	
	//code for making the hex board image and saving to a file. Not
	//normally used in game.
	make_hex_board_image: "def(int hex_width=114, int hex_height=85) ->commands
(c.render(1024, 512,

 fold([[c.save(), c.translate((xpos-1)*hex_width*0.75, ypos*hex_height + if(xpos%2 = 1, hex_height*0.5, 0))] + hex + [
 	c.set_source_rgba(
	(xpos%12)/11.0,
	(ypos%6)/5.0,
	1, 1),
	
	c.fill(), c.restore()] |
   xpos <- range(13),
   ypos <- range(8)
 ], a+b)

).save('test.png')

  where hex = [
  	c.line_to(hex_width*0.25, -hex_height/2),
  	c.line_to(hex_width*0.75, -hex_height/2),
  	c.line_to(hex_width*1.00, 0),
  	c.line_to(hex_width*0.75, hex_height/2),
  	c.line_to(hex_width*0.25, hex_height/2),
  	c.line_to(hex_width*0.00, 0),
  ])
  where c = canvas()
	",

	num_background_hexes: 84,
	background_hex_intensity: { type: "[decimal]", init: "map(range(84), index%2 + 1d100/100.0)" },
	background_hex_intensity_delta: { type: "[decimal]", init: "map(range(84), (50 + 1d50)/20000.0)" },

	process_hex_intensity: "def() ->commands set(background_hex_intensity, map(background_hex_intensity, if(new_value < 0, 1.0, new_value) where new_value = value - background_hex_intensity_delta[index]))",

	_ping_time: { type: "int", default: 0 },
	ping_game: "def(int nbytes=0) ->commands [
		execute(me, tbs_send(client, {
			type: 'ping_game',
			payload: map(range(nbytes/10), 1d10000000),
		})),
		set(_ping_time, cycle),
	]",

	pong_game: "def() ->commands [
		debug(['PONG', cycle - _ping_time]),
	]",

	concede_game: "def() ->commands [
		execute(me, tbs_send(client, {
			type: 'concede',
		}))
	]",

	process_connection: "def() ->commands execute(me, [
    	if(client, tbs_process(client))
	])",

	_response_pause_counter: { type: "int", default: -1 },

	_last_state_message: { type: "map", default: {} },

	_avatars: { type: "[obj player_avatar]", default: [] },
	avatar_life: { type: "[obj life_bar]", default: [] },

	avatar_crypts: { type: "[obj crypt_library_display]", default: [] },
	avatar_decks: { type: "[obj crypt_library_display]", default: [] },

	_disconnected_players: { type: "{string -> int}", default: {} },
	_disconnection_dialog: { type: "obj disconnection_dialog|null" },

	process_disconnected_label: "def() ->commands
	if(_disconnection_dialog != null, set(_disconnection_dialog.disconnected_players, _disconnected_players))
	",

	_background_canvas: { type: "obj canvas|null" },

	state: "class game<- _state asserting _state",
	_state: { type: "class game|null" },
	end_of_turn_state: { type: "class game|null" },
	next_turn_state: { type: "class game|null" },

	_sent_move_message: { type: "int|null" },

	send_move_message: "def(map msg) ->commands [
		tbs_send(client, msg),
		set(_sent_move_message, cycle),
	]",

	_animation_status_label_key: { type: "any" },
	_animation_status_label: { type: "obj label|null" },
	create_animation_status_label: "def(int ntime) ->commands
	if(key != _animation_status_label_key, [
		set(_animation_status_label_key, key),
		if(_animation_status_label, remove_object(_animation_status_label)),

/*
		spawn('label', level_width-avatar_width + 32, 48, {
			zorder: get_zorder('debug_labels'),
			_text: [if(ntime <= 0, 'no animation', 'animating ' + _animation_reason + ': ' + str(ntime))],
			_halign: 'left',
			_font_size: 12,
			_bg_color: [0,0,0,1],
		}, [
			set(me._animation_status_label, child),
		]),
*/
	]) where key = [max(0, ntime)]
	",

	_server_response_label: { type: "obj label|null" },

	create_server_response_label: "def(int state_id, int server_time_ms) ->commands if(_sent_move_message != null, [
		set(_sent_move_message, null),

		debug('timing_message: state id = ' + str(state_id) + ' took ' + str(latency_ms) + 'ms server ' + str(server_time_ms) + 'ms'),

		if(_server_response_label != null, remove_object(_server_response_label)),
/*
		spawn('label', level_width-avatar_width + 32, 16, {
			zorder: get_zorder('debug_labels'),
			_text: ['state id = ' + str(state_id) + ' took ' + str(latency_ms) + 'ms server ' + str(server_time_ms) + 'ms'],
			_halign: 'left',
			_font_size: 12,
			_bg_color: [0,0,0,1],
		}, [
			set(me._server_response_label, child),
		]),
*/
	] where latency_ms = (cycle - _sent_move_message)*20)",

	_state_id_sync_label: { type: "obj label|null" },

	create_sync_label: "def(string txt) ->commands [
		if(_state_id_sync_label, remove_object(_state_id_sync_label)),
/*
		spawn('label', level_width-avatar_width + 32, 32, {
			zorder: get_zorder('debug_labels'),
			_text: [txt],
			_halign: 'left',
			_font_size: 12,
			_bg_color: [0,0,0,1],
		}, [
			set(me._state_id_sync_label, child),
		]),
		*/
	]",

	refresh_state_id_sync_label: "def() ->commands
	if(_remote_state_id != -1,
	if(in_sync != _state_id_in_sync, [
		set(_state_id_in_sync, in_sync),
		if(in_sync = false, set(_state_id_last_sync_time, cycle)),

		if(in_sync, create_sync_label('In sync (' + str((cycle - _state_id_last_sync_time)*20) + 'ms) stateid = ' + str(_state_id))),


	], [
		if(in_sync = false,
		   create_sync_label('Out of sync (' + str((cycle - _state_id_last_sync_time)*20) + 'ms) stateid = ' + str(_state_id) + ' vs ' + str(_remote_state_id)))
	]) where in_sync = (_remote_state_id = _state_id))",

	_state_id_in_sync: { type: "bool", default: true },
	_state_id_last_sync_time: { type: "int", default: 0 },

	_remote_state_id: { type: "int", default: -1 },
	_remote_state_id_timestamp: { type: "int", default: -1 },

	_state_id_timestamp: { type: "int", default: -1 },
	_state_id: { type: "int", default: -1 },
	_processed_state_id: { type: "int", default: -1 },
	_client: { type: "object|null" },

	client: "object<- _client asserting _client",

	//the state needed to represent presence to the other player --
	//which cards we have moused over etc.
	_presence_state: "map ::
	if(observer, {},
	{
		hand_card_mouseover: if(_playing_card != null and _playing_card.in_hand and _playing_card.hand_index != null, _playing_card.hand_index, if(card_mouseover != null and card_mouseover.in_hand, card_mouseover.hand_index)),
		playing_card: _playing_card != null,
	})
	",

	_last_presence_state: { type: "map", default: {} },

	_process_presence_state: "def() ->commands
	if(new_presence != _last_presence_state, [

		tbs_send(client, {
			type: 'chat_message',
			nick: username,
			sub_type: 'presence',
			info: new_presence,
		}),

		set(_last_presence_state, new_presence),
	]) where new_presence = _presence_state",

	_received_presence_state: "def(map msg) ->commands
	[
		set(_opponent_hand_mouseover, int|null<- msg.hand_card_mouseover),
		set(_opponent_card_playing, bool|null<- msg.playing_card),
		bind_command(spawn_opponent_cards),

	]
	where opponent_cards = filter(level.chars, value is obj card and value.in_opponent_hand)
	",

	_opponent_hand_mouseover: { type: "int|null" },
	_opponent_card_playing: { type: "null|bool" },

	force_skip_responses: { default: false },

	_pending_card_discard: { type: "obj card|null" },
	_card_preview: { type: "obj card|null" },
	card_mouseover: { type: "obj card|null",
	   set: "if(value != _data, [
	     if(_data != null, [set(_data.allow_drag, false), _end_mouseover(_data)]),
		 if(new_value != null, set(new_value.allow_drag, true)),
		 set(_data, new_value),
	   ] where new_value = if(value = _pending_card_discard, null, value))"
	 },

	 _discard_card_button: { type: "obj button_controller|null", set: "if(value != _data, [remove_object(_data), set(_data, value)])" },

	_card_regions: { type: "[{left: int, right: int, top: int, card_num: int}]", default: [] },
	_card_regions_left_to_right: "[{left: int, right: int, top: int, card_num: int}] :: sort(_card_regions, a.left < b.left)",
	_hand_card_moused_over: "int ::
	 (if(region = null, -1, region.card_num)
	      where region =
		     if(card_mouseover, find(card_regions_ordered,
			   (index >= mouseover_index and xpos >= value.right - reserved_region and xpos <= value.right and ypos >= value.top) or
			   (index <= mouseover_index and xpos >= value.left and xpos <= value.left + reserved_region and ypos >= value.top))) or
		  	 
		     //prefer the already selected card
		     if(card_mouseover, find(card_regions_ordered, card_mouseover.hand_index = value.card_num and (card_mouseover.being_dragged or xpos >= value.left and xpos <= value.right + 0.2*(value.right - value.left) and ypos >= value.top))) or

			 //not over an already selected card, find the first match.
		     find(card_regions_ordered, xpos >= value.left and xpos <= value.right and ypos >= value.top)
	      where xpos = ctrl_mice[0][0]
	      where ypos = ctrl_mice[0][1])
		  asserting size(ctrl_mice) = 1
		  where reserved_region = min(10, 200 / (size(card_regions_ordered)+1))

		  //Since card regions overlap, we want to order the card regions by
		  //their order of priority if a match is found. We prefer to match
		  //to a region closest to the already selected card, so reverse cards
		  //to the left in order while keeping cards to the right in order.
		  where card_regions_ordered = if(mouseover_index < 0, _card_regions_left_to_right, reverse(_card_regions_left_to_right[:mouseover_index]) + _card_regions_left_to_right[mouseover_index:])
		  where mouseover_index = index(_card_regions_left_to_right, find(_card_regions_left_to_right, card_mouseover != null and card_mouseover.hand_index = value.card_num))",

	//location of the tops of our cards
	_card_hand_top: { type: "decimal", default: 0.0 },

	_prev_ctrl_keys: { type: "[string]", default: [] },

	_playing_card_channeling_label: { type: "obj label|null" },
	_playing_card_channeling_controls: { type: "[obj up_down_button]", default: [] },

	_amount_channeled: { type: "int|null" },

	_spawn_channeling_controls: "def(null|obj card card) ->commands [
		remove_object(_playing_card_channeling_label),
		map(_playing_card_channeling_controls, remove_object(value)),
		set(_playing_card_channeling_label, null),
		set(_playing_card_channeling_controls, []),

		if(card != null and card.card_type.is_channeled, [

			_spawn_channeling_label(amount_channeled),

			spawn('up_down_button', lib.citadel.px(230), lib.citadel.py(362), {
				_up: true,
				zorder: 2000,
				_onclick: bind(me._adjust_channeling, 1),
			}, [
				add(me._playing_card_channeling_controls, [child]),
			]),

			spawn('up_down_button', lib.citadel.px(230), lib.citadel.py(382), {
				_up: false,
				zorder: 2000,
				_onclick: bind(me._adjust_channeling, -1),
			}, [
				add(me._playing_card_channeling_controls, [child]),
			]),

			set(_amount_channeled, amount_channeled),

		] where amount_channeled = state.players[state.nplayer].resources - state.players[state.nplayer].calculate_cost(card.card_type)
	)
	]",

	_spawn_channeling_label: "def(int amount) ->commands [
		remove_object(_playing_card_channeling_label),
		spawn('label', lib.citadel.px(130), lib.citadel.py(380), {
			zorder: 2000,
			_text: ['Channeling: ' + str(amount)],
			_font_size: lib.citadel.px(26),
		}, [
			set(me._playing_card_channeling_label, child),
		]),
	]",

	_adjust_channeling: "def(int adj) ->commands if(_playing_card != null and _amount_channeled != null, [
		set(_amount_channeled, new_channel),
		_spawn_channeling_label(new_channel),
		
	] where new_channel = if(_amount_channeled+adj > max_channel, 0, _amount_channeled+adj < 0, max_channel, _amount_channeled+adj)
	  where max_channel = state.players[state.nplayer].resources - state.players[state.nplayer].calculate_cost(_playing_card.card_type))",
	

	_playing_card: { type: "null|obj card", default: null,
		set: "[
			set(_preview_creature, null),
			if(_data != null, [
				set(_data.draw_primitives, []),
				_data.hide_halo(),
				if(_data.in_ability, remove_object(_data)),
			]),
			if(value != null, [
				value.show_halo(),
				animate(value, {x: lib.citadel.px(50), y: lib.citadel.py(50), rotate: 0, card_size: 1.0}, {duration: 10}),
				set(value.zorder, get_zorder('card_play')),
			]),
			set(_data, value),
			if(_data != value, _spawn_channeling_controls(value)),
		]"
	},

	no_mandatory_play: "bool :: _playing_card = null or _playing_card.mandatory_play = false",

	_targets_chosen: { type: "[Loc]", default: [] },

	animation_move_time: { type: "int", default: 0 },
	_animation_end_time: { type: "int", default: -1 },
	_animation_reason: { type: "string", default: "" },
	_card_resolve_time: { type: "int", default: -1 },

	_game_state_queue: { type: "[map]", default: [] },
	_furthest_animation_hint: { type: "int", default: 0 },

	_animation_hints_id: { type: "int", default: 0 },

	_animated_spell_card: { type: "null|obj card", default: null },
	_spells_on_stack: { type: "[obj card]", default: [] },

	top_of_stack: "obj card|null :: choose(filter(level.chars, value is obj card and value.stack_id != null), value.stack_id)",

	_spell_animation_time: { type: "int", default: 0 },

	_choice_object: { type: "null|obj choice_controller" },

	_deck_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_hand_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_level_obj: { type: "[obj citadel_controller.card_back]", default: [] },

	_end_turn_button: { type: "null|custom_obj" },
	get_end_turn_button: "def() ->null|custom_obj _end_turn_button",

	font: "string:: lib.font.regular_font",
	color: "string:: 'antique_white'",
	font_color: "string:: 'antique_white'",

	_spell_windup_sound_being_played: { type: "string|null" },

	return_callback: { type: "function(bool) ->commands" },
	game_result: { type: "bool", default: false },

	quit_game: "def() ->commands execute(me, [
		schedule(100, return_callback(game_result)),
		tbs_send(client, {
			type: 'quit'
		}),
	])",

	//in a campaign the message sent to the server to setup this game.
	game_setup_message: { type: "map|null" },

	campaign_location: { type: "string|null" },
	campaign_scenario: { type: "int|null" },
	campaign_sets: { type: "[string]", default: [] },
	victory_unlock: { type: "string|null" },

	restart_game: "def() ->commands [
		[ remove_object(dlg) | dlg <- level.chars, dlg is obj victory_dialog],
		execute(me, tbs_send(client, {
			type: 'start_game',
		}))
	]",

	get_player_status: "def() ->string if(is_online_game, if(observer, 'watching a game', 'playing multiplayer'), 'playing vs ai')",

	//if the game is an offline game let them know there is someone wanting to
	//play online.
	should_notify_multiplayer_queue: "def() ->bool is_online_game = false",

	is_online_game: "bool :: game_server_address != ''",

	observer: { type: "bool", default: false },

	game_created: { type: "bool", default: false },
	session_id: { type: "int", default: -1 },
	selected_deck: { type: "string", default: "" },
	game_server_address: { type: "string", default: "@eval TBS_SERVER_ADDRESS" },
	game_server_port: { type: "int", default: "@eval TBS_SERVER_PORT" },

	create_tbs_client: "def() ->object
	  if(game_server_address, tbs_client(game_server_address, game_server_port, session_id), tbs_internal_client(session_id))
	  ",

	level_width: "int :: level.dimensions[2]",
	level_height: "int :: level.dimensions[3]",

	card_keeps: "[int]<-  [card.hand_index | card <- level.chars, card is obj card, card.in_hand, card.keep, card.player_index = state.nplayer]",

	card_keep_draw_id: "[int] :: [card.card_type.draw_id | card <- level.chars, card is obj card, card.in_hand, card.keep]",

	end_turn_message: "{string -> any}<- {type: 'end_turn', player_index: state.nplayer, keep: card_keeps}",

	_end_turn_pending: { default: false },

	end_turn: "def() ->commands
	if(_tutorial.inhibit_end_turn(me) = false,
	[
	set(locked_mana, null),

	//remove the end turn button immediately to appear responsive to
	//pressing the end turn button.
	if(_end_turn_button, [
		set(_end_turn_button, null),
		remove_object(_end_turn_button),
	]),
	execute(me, if(animation_up_to_date, [set_widgets([]),
	                     set(_end_turn_pending, false),
			             set(me._playing_card, null),
						 send_move_message({
						  type: 'moves',
						  state_id: me._state_id,
						  moves: [end_turn_message]
						 })
						 ],
						 set(_end_turn_pending, true)))
	],
	
	//trying to click end turn when inhibited, flash any tips
	[
		[tip.flash_tip() | tip<- level.chars, tip is obj tip_dialog]
	])
	",

	get_zorder: "def(string key) ->int lib.citadel.zorder(key)",

	opponent_speak: "def(string text) ->commands [
		spawn('speech_controller', 0, 0, {
			_mm: me,
			_controller: me,
			_text: text,
			_avatar: _avatars[1],
		}),
	]",

	transient_opponent_speak: "def(string text) ->commands [
		reserve_animation_time('transient_opponent_speak', 50),
		spawn('speech_bubble', avatar.x + px(20), avatar.y + px(240), {
			_text: text,
			zorder: 25000,
			_width: px(250),
			_height: px(200),
		}, [
			schedule(200, animate(child, {
				alpha: 0,
			}, {
				duration: 50,
				on_complete: remove_object(child),
			}))
		])
	] where avatar = _avatars[1]",

	awaiting_input: "bool :: _playing_card != null",

	clear_input_state: "def() ->commands execute(me, [
		//if(me.card_mouseover, mouse_leave_card(me.card_mouseover)),
		[set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		[set(player.selectable, false) | player <- level.chars, player is obj player_avatar],
		set(_playing_card, null),
		set(_targets_chosen, []),
		if(_selected_creature, finish_activated_ability_cards());
		//set(me.card_mouseover, null),
		_spawn_tile_cursors(),
	])",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def() ->commands
	  if(myplayer.hand != myplayer.previous.hand, clear_input_state())
	",

	//debug function to execute FFL on the server.
	server_exec: "def(string code) ->commands
	execute(me, tbs_send(client, {
		type: 'moves',
		state_id: _state_id,
		moves: [{
			type: 'debug',
			exe: code
		}]
	}))
	",

	send_chat: "def(string msg) ->commands
		execute(me, tbs_send(client, {
			type: 'chat_message',
			sub_type: 'text',
			text: msg,
			nick: username,
		}))
	",

	debug_draw: "def(int ncards) ->commands server_exec('players[current_player].draw_cards(me, ' + ncards + ')')",
	debug_mana: "def(int nmana) ->commands server_exec('[add(players[current_player].base_income, increase), add(players[current_player].resources, increase)] where increase = ' + nmana)",
	debug_card: "def(string name) ->commands server_exec('add(players[current_player].hand, [lib.citadel.create_card(q(' + name + '))])')",
	debug_card_enemy: "def(string name) ->commands server_exec('add(players[next_player_index].hand, [lib.citadel.create_card(q(' + name + '))])')",

	debug_enemy_hand: "[string]<- map(state.opponent_obj.hand, value.name)",
	
	animation_up_to_date: "bool<- _processed_state_id = _state_id",

	time_to_resolve_card: "int :: max(0, _card_resolve_time - cycle)",
	reserve_card_resolve_time: "def(int ncycles) ->commands if(end_time > _card_resolve_time, set(me._card_resolve_time, end_time)) where end_time = cycle + ncycles",

	cancel_reserved_animation: "def() ->commands
		if(_animation_end_time > cycle, set(_animation_end_time, cycle+1))
	",
	reserve_animation_time: "def(string reason, int ncycles) ->commands if(end_time > _animation_end_time, [set(me._animation_end_time, end_time), set(me._animation_reason, reason)]) where end_time = cycle + ncycles",
	myplayer: "class player<- _state.players[_state.nplayer] asserting _state",
	myteam: "[class player] :: get_player_team(myplayer)",
	enemy_player: "class player<- _state.players[(_state.nplayer+1)%2] asserting _state",
	get_player_team: "def(class player player) ->[class player] sort(state.team(player), if(a.player_index = state.nplayer, true, if(b.player_index = state.nplayer, false, a.player_index < b.player_index)))",

	remove_preview_card: "def(any card) ->commands if(_card_preview and card = null, [remove_object(_card_preview), set(_card_preview, null)])",

	_hint_label: { type: "null|obj hint_label", set: "[
		if(_data, _data.destroy()),
		set(_data, value),
	]" },

	_opponent_preview_card: { set: "[if(_data and _data != value, remove_object(_data)), set(_data, value)]", type: "obj card|null" },
	_opponent_card_mouseover: { type: "obj card|null" },

	mouse_enter_opponent_card: "def(obj card card) ->commands if(card.show_back = false, [
		spawn('card', 0, 0, {
			 card_type: card.card_type,
			 controller: me,
			 in_hand: false,
			 allow_drag: false,
			 card_size: 1.6,
			 zorder: get_zorder('card_stack_base') + 100,
		}, [
			set(_opponent_preview_card, child),
			set(child.mid_x, mouse_x),
			set(child.y, mouse_y + py(32)),
		]),

		set(_opponent_card_mouseover, card),
		debug(['ENTER OPPONENT', card.card_type.name]),
	])",

	mouse_leave_opponent_card: "def(obj card card) ->commands if(_opponent_card_mouseover = card, [
		set(_opponent_preview_card, null),
		set(_opponent_card_mouseover, null),
		debug(['LEAVE OPPONENT', card.card_type.name]),
	])",

	mouse_enter_card: "def(obj card card) ->commands if(_awarding_cards = false, [
	 [creature.hand_card_entered() | creature <- level.chars, creature is obj creature],

	 if(card.in_hand, [
		set(card.zorder, get_zorder('card_highlight')),
		if(card != _playing_card, [
			animate(card, {
				mid_x: pos.mid_x,
				mid_y: pos.mid_y - py(210),
				rotate: 0.0,
				card_size: pos.card_size*2,
			}, {
				duration: 10,
				name: 'card_move',
				replace_existing: true,
			}),

			set(_discard_card_button, null),

			if(state.nteam = state.current_player_index and observer = false and card != _pending_card_discard and _tutorial.inhibit_card_right_click(me, card) = false and state.in_response_phase = false, [
				spawn('button_controller', pos.mid_x - px(40), level_height - px(32), {
					text: 'Discard',
					_font_size: px(16),
					on_click: (def() ->commands me.card_discard(card)),
					button_width: px(80),
					button_height: px(20),
					zorder: get_zorder('card_highlight') + 100,
				}, [
					set(me._discard_card_button, child),
				])
			]),

		]) where pos = cards_in_hand_positions(_current_hand, hand_left_side, hand_area)[card.hand_index],
		set(me.card_mouseover, card),
		_set_mana_bar_using(if(card.is_castable, state.players[state.nplayer].calculate_cost(card.card_type), 0)),
	 ]),
	 (if(me._playing_card = null, if(me.card_mouseover = card, null,
	  if(me.card_mouseover != null, [
			mouse_leave_card(me.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.in_hand,

	  [

	  schedule(50, bind_command(me.show_card_tips, card)),

	  if(can_afford and possible_targets != [],
	  [
	 	card.show_halo(),
	    set(me.card_mouseover, card),
	  ]),

		spawn('hint_label', 0, 0, {
			zorder: 2000,
			_text: ['Costs ' + str(local_player.calculate_cost(card.card_type)) + ' mana.'] +
			        if(can_afford = false,
					   ['Cannot afford to cast'],
					   card.card_type.uses_action and _selected_creature != null and _selected_creature.creature_object.has_action = false,
					   ['Creature has already acted this turn'],
					   possible_targets = [], ['No available targets.'],
					   not is_usable, ['Not castable'],
					   ['Click to cast']),
			subject: card,
			_delay: 50,
		}, [
			set(_hint_label, child),
		]),
	  ]
	  where is_usable = card.card_type.is_usable(state, _casting_creature)
	  where can_afford = local_player.can_afford(card.card_type)
	  )
 	  where possible_targets = if(card.card_type is class card, card.card_type.possible_targets(state, _casting_creature, []), [])
	  )))

	  )])
	  where local_player = myplayer",
	
	show_card_tips: "def(obj card card) -> commands
	if(card = card_mouseover, card.show_card_tips())",
	
	_end_mouseover: "def(obj card card) -> commands
	  if(card.in_hand and find(level.chars, value = card) and find(_current_hand, value = card.card_type) != null,
	    [
		if(_playing_card != card, [
			card.hide_halo(),
			animate(card, {
				mid_x: pos.mid_x,
				mid_y: pos.mid_y,
				rotate: pos.rotate,
				card_size: pos.card_size,
			}, {
				duration: 10,
				name: 'card_move',
				replace_existing: true,
			})
		]),
		set(card.zorder, pos.zorder),
	    ] where pos = cards_in_hand_positions(_current_hand, hand_left_side, hand_area)[card.hand_index]
	  )
	",

	mouse_leave_card: "def(obj card card) ->commands [
	  if(_hint_label and _hint_label.subject = card, set(_hint_label, null)),
	  
	  card.clear_card_tips(),

	  set(me.card_mouseover, null),
	  remove_object(_discard_card_button),
	  set(_discard_card_button, null),
	  _set_mana_bar_using(0),
	]",

	mouse_drag_card_start: "def(obj card card) ->commands
		if(card = card_mouseover,
		[
	        remove_object(_discard_card_button),
	        set(_discard_card_button, null),
	  	    card.clear_card_tips(),
			set(card.card_size, 1.0),
			set(card.mid_x, mouse_x),
			set(card.mid_y, mouse_y),
			//choose_targets_for_card(card, []),

			//set up possible targets for the card.
			if(state.nteam = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false and card != _pending_card_discard and possible_targets != [] and possible_targets != null and can_afford and is_usable,
			[
			  if(_playing_card,
			  [
			  	set(_playing_card, null),
				clear_input_state(),
				bind_command(spawn_cards_in_hand),
			  ]),

			  [set(player.selectable, [-1, player.player_num] in possible_targets) | player <- level.chars, player is obj player_avatar],
			   map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
			   _spawn_tile_cursors(),

			  set(_card_drag_play, card),
			  set(_tile_drag_onto, null),

			]
			)
	    where is_usable = card_instance.is_usable(state, _casting_creature)
		where can_afford = myplayer.can_afford(card_instance)
		where possible_targets = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, myplayer.creature_avatar, []))
		where card_instance = class card_base<- card.card_type
		]
		)
	",

	_card_drag_play: { type: "obj card|null" },
	_tile_drag_onto: {
	  type: "obj tile|null",
	  set: "if(_data != value, [
	  	set(_data, value),
		if(_data != null, set(_data.mouseover, false)),
		if(value != null, set(value.mouseover, true)),
	  ])",
	},

	_mycrypt: "null|obj crypt_library_display :: if(state.nplayer >= 0 and state.nplayer < size(avatar_crypts), avatar_crypts[state.nplayer])",

	_card_overlaps_crypt: "def(obj card card) ->bool
	  if(_mycrypt != null,
		card.x < _mycrypt.x2 and card.y < _mycrypt.y2 and
		card.x2 > _mycrypt.x and card.y2 > _mycrypt.y, false)
	",

	_card_overlaps_tile: "def(obj card card) ->obj tile|null
		find(filter(level.chars, value is obj tile and value.selectable), value.mid_x > card.x and value.mid_x < card.x2 and value.mid_y > card.y and value.mid_y < card.y2)
	",

	mouse_drag_card: "def(obj card card) ->commands
	[
	if(card = _card_drag_play, [
	  set(card.card_size, 1.0 - fade_ratio*0.6),
	  set(_tile_drag_onto, _card_overlaps_tile(card))
	] where fade_ratio = if(mouse_y > top_player_area, 0.0, min(1.0, decimal(top_player_area + px(50) - mouse_y)/px(100)))
	),

	if(_mycrypt != null, set(_mycrypt.highlight, _card_overlaps_crypt(card))),

	card.clear_card_tips(),
	if(card.in_hand and card.hand_index != null,
	[
		if(pos != -1, [
		   set(card.keep, mouse_x >= right_edge_display_areas and (obj_replacing.keep or mouse_x > _card_regions_left_to_right[size(_card_regions_left_to_right)-1].right)),

		   set_card_hand_position(card.hand_index, pos),
	   	   bind_command(spawn_cards_in_hand)
		  ]
		  where obj_replacing = find_or_die(level.chars, value is obj card and value.player_index = state.nplayer and value.hand_index = _card_regions_left_to_right[pos].card_num)) 
		  where pos = index(_card_regions_left_to_right, find(_card_regions_left_to_right,
		     mouse_y > value.top and (
		     (mouse_x > (value.left + value.right)/2 and mouse_x < value.right) or
			 (index = 0 and mouse_x < value.left and mouse_x > value.left - (value.right - value.left)) or
			 (index = size(_card_regions_left_to_right)-1 and mouse_x > (value.right))))),
	])]",

	mouse_drag_card_end: "def(obj card card) ->commands [
	    set(_card_drag_play, null),
	    set(_tile_drag_onto, null),

		if(_mycrypt != null, set(_mycrypt.highlight, false)),

		if(card = card_mouseover,
			[
				mouse_leave_card(card),
			]
		),

		if(_mycrypt != null and _mycrypt.highlight,
			card_discard(card),

			_card_drag_play != null and _tile_drag_onto != null,
			choose_targets_for_card(obj card<- _card_drag_play, [_tile_drag_onto.loc asserting _tile_drag_onto != null]),

		   mouse_y < top_player_area - 80, [
			card_clicked(card)
		])
	]",

	_crypt_library_dialog: { type: "obj crypt_library_display_dialog|null" },

	mouse_enter_crypt_library_display: "def(obj crypt_library_display display) ->commands [
		set(display.highlight, true),

		if(_crypt_library_dialog, remove_object(_crypt_library_dialog)),
		set(_crypt_library_dialog, null),

		if(size(display.items) > 0 and (display.is_crypt or display.player_index = state.nplayer),
		spawn('crypt_library_display_dialog', 0, 0, {
			items: if(display.is_crypt = false, sort(display.items), display.items),
			parent_display: display,
			zorder: 10000,
		}, [
			set(me._crypt_library_dialog, child),
		])),
	]",

	mouse_leave_crypt_library_display: "def(obj crypt_library_display display) ->commands [
		set(display.highlight, false),
		if(_crypt_library_dialog, remove_object(_crypt_library_dialog)),
		set(_crypt_library_dialog, null),
	]",

	mouse_x: "int<- ctrl_mice[0][0]",
	mouse_y: "int<- ctrl_mice[0][1]",

	_prev_mouse_pos: { type: "[int,int]", default: [0,0] },

	_last_mouse_move: { type: "int", default: 0 },

	mouse_enter_discard: "def(int nplayer) ->commands execute(me, [

	])",

	mouse_click_discard: "def(int nplayer) ->commands []",

	mouse_leave_discard: "def(int nplayer) -> commands execute(me, [
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(obj tile tile) ->commands [
		if(_card_drag_play = null, set(tile.mouseover, true)),
		//debug(['mouse enter tile', tile.loc]),
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen + if(tile.selectable, [tile.loc], [])),
		]),

	if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
	   ]) where card = lib.json.get_document_map('data/cards.cfg')[creature.name])
	      where creature = state.creature_at_loc(tile.loc)
	]",
	mouse_leave_tile: "def(object tile) ->commands [
		if(_card_drag_play = null, set(tile.mouseover, false)),
		remove_preview_card(tile.loc)
	]",

	mouse_enter_log: "def(int index) ->commands null",

	_tutorial: { type: "class client_tutorial", init: "construct('client_tutorial')" },
	_tutorial_init: { type: "bool", default: false },

	get_tutorial: "class client_tutorial :: _tutorial",
	
	card_clicked: "def(obj card card) ->commands
	if(no_mandatory_play,
	[
	if(state.nteam = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false and card != _pending_card_discard,
	  if(_playing_card,
	  [
	  	set(_playing_card, null),
		clear_input_state(),
		bind_command(spawn_cards_in_hand),
	    _spawn_tile_cursors(),
	  ],

	  [
	   //tile_clicked(null),

	   if(_current_tip != null and _current_tip.tip.key = 'tutorial_play_card' and _current_tip.tip.targets = [card],
			_create_tip_dialog({
				key: 'play_card_pos_tutorial',
				text: 'Click on the tile closest to you to summon your Disciple there.',
				targets: [find_or_die(level.chars, value is obj tile and value.loc = [0,0])],
			})
	   ),

	   if(_current_tip != null and _current_tip.tip.key = 'play_creature' and _current_tip.tip.targets = [card],
	   
	   if(possible_targets != null,
	   [
	   	   _create_tip_dialog({
			  key: 'play_card_pos',
			  text: if(village_targets, 'Click on a tile to summon your creature in that tile. If you summon it in front of a village it will be able to capture the village, gaining you mana each turn.', 'Choose where to summon your creature.'),
			  targets: tile_targets,
		   })
	   ]
	    where tile_targets = filter(level.chars, value is obj tile and value.loc in loc_targets)
		where loc_targets = if(village_targets, village_targets, possible_targets)
	    where village_targets = filter(possible_targets, find(state.constructs, value.loc[0] = loc[0] and value.name = 'Village' and value.controller = -1) where loc = Loc :: value)
		)
		where possible_targets = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, if(_selected_creature, _selected_creature.creature_object, myplayer.creature_avatar), []))
		where card_instance = class card<- card.card_type
	   ),

	   bind_command(spawn_cards_in_hand),

	   set(me.card_mouseover, null),
	   remove_object(_discard_card_button),
	   set(_discard_card_button, null),
	   _set_mana_bar_using(0),

	   //debug(['BBB: CHOOSE TARGETS FOR CARD', card.card_type.name]),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])
	]))
	])",

	card_discard: "def(obj card card) ->commands [
		if(state.nteam = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false and card.in_hand and card != _pending_card_discard and state.in_response_phase = false and no_mandatory_play,
			if(n >= 0, 
		[
		 set(me._pending_card_discard, card),
		 animate(card, {
			mid_x: px(60),
			mid_y: level_height - py(200),
			scale: 0.5,
			rotate: 0,
		   }, {
			duration: 15,
			on_complete: remove_object(card); if(me._pending_card_discard = card, set(me._pending_card_discard, null)),
		   }),
	     set(me.card_mouseover, null),
	     remove_object(_discard_card_button),
	     set(_discard_card_button, null),
	     set(me._playing_card, null),
		 clear_input_state(),
	 	 bind_command(spawn_cards_in_hand),
		 send_move_message({
		   type: 'moves',
		   state_id: _processed_state_id,
		   moves: [{
				  type: 'discard_card',
				  player_index: state.nplayer,
				  index: n,
		   }]
		 })
		 ]
		) where n = index(_current_hand, card.card_type)
		)
	]",

	option_clicked: "def(int index, null|int|string choice_value) ->commands execute(me, [
	debug('OPTION CLICKED: ', choice_value),
	if(_choice_object, [_choice_object.exit_dialog(), set(_choice_object, null)]),
	send_move_message({
		type: 'moves',
		state_id: _processed_state_id,
		moves: [{
			type: 'make_choice',
			choice: choice_value,
			choice_index: index,
		}],
	})
	])",

	mouse_enter_avatar: "def(obj player_avatar item) ->commands [
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen + if(item.selectable, [[-1, item.player_num]], [])),
		]),
	]",

	mouse_leave_avatar: "def(obj player_avatar item) ->commands [
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen),
		]),
	]",

	avatar_clicked: "def(obj player_avatar item) ->commands [
		if(_playing_card != null and item.selectable,
			choose_targets_for_card(
			  _playing_card, _targets_chosen + [[-1, item.player_num]])
		)
	]",

	mana_display_clicked: "def(obj mana_display item) ->commands [
		if(_playing_card != null and item.selectable,
			choose_targets_for_card(
			  _playing_card, _targets_chosen + [[-1, item.player_num]])
		)
	]",
	      
	tile_clicked: "def(obj tile|null tile) ->commands
	if((not state.current_choice) and (no_mandatory_play or tile and tile.selectable), [
	   [set(player.selectable, false) | player <- level.chars, player is obj player_avatar],
	   execute(me, 	map(level.chars, if(value is obj tile,
	                                    set(value.selectable, false)))),
	   if(tile and _playing_card != null and tile.selectable,
		  choose_targets_for_card(_playing_card,
			_targets_chosen + [tile.loc]),

		if(no_mandatory_play,
		[
		clear_input_state(),
		bind_command(spawn_cards_in_hand)
		])

	   ),
	   _spawn_tile_cursors(),
	 ])
	 ",
	
	choose_targets_for_card: "def(obj card card, [Loc] current_targets) ->commands
	[
	execute(me,
	if(card_instance and state.in_response_phase and (not card_instance.is_response) and (not card.mandatory_play),
			[
			//debug(['BBB: RESPONSE_ONLY', card.card_type.name]),
	set_status_label('Can only cast response spells during response phase', 'red'),
	],
	[
	   if(card_instance and (card.hand_index != null or card.parent_creature) and state.nteam = state.current_player and observer = false,
	       [
		    if(can_afford and is_usable and possible_targets != [] and not unique_violation,
		      if(possible_targets = null,
				([
				 set(locked_mana, null),

				//debug('send cast'),
				 send_move_message({
				   type: 'moves',
				   state_id: _processed_state_id,
				   moves: [{
					type: 'play_card',
					index: if(card.parent_creature, -1, card.hand_index),
					player_index: state.nplayer,
					targets: current_targets,
					channel: if(card.card_type.is_channeled and _amount_channeled != null, _amount_channeled, 0),

					creature: if(card.parent_creature, card.parent_creature.summon_id, -1),
					ability: if(card.parent_creature, card.card_type.name, ''),
					free_ability: card.mandatory_play,
				   }]
				  }) asserting _client,
				 set(me._playing_card, null),
				 clear_input_state(),
				 if(card.mandatory_play, [
					set(_selected_creature, null),
					remove_object(card),
				 ]),
				] asserting card_instance.targets_valid(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar), current_targets)
				),
			    [
				 [set(player.selectable, [-1, player.player_num] in possible_targets) | player <- level.chars, player is obj player_avatar],
				 map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
				 _spawn_tile_cursors(),
				 set(me._playing_card, card),
				 set(_targets_chosen, current_targets)
				])
			  )]
		where unique_violation = card_instance.hero and card_instance.creature and find(state.creatures, value.name = card_instance.name and value.controller = state.nplayer)

		//we should already have suggested discards at this point, so
		//if the card is playable, the player can afford it straight-up
	    where is_usable = card_instance.is_usable(state, _casting_creature)
		where can_afford = myplayer.can_afford(card_instance) and (card.parent_creature = null or card_instance.uses_action = false or card.parent_creature.has_action)
		where possible_targets = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar), current_targets)))
	 ]))] where card_instance = null|class card_base <- if(card.card_type is class card_base, card.card_type, null)",

	_spawn_tile_cursors: "def() ->commands bind_command(_spawn_tile_cursors_internal)",

	_spawn_tile_cursors_internal: "def() ->commands
	[
	if(find(level.chars, value is obj tile and value.selectable or value is obj player_avatar and value.selectable) = null,
	   [ remove_object(cursor) | cursor <- level.chars, cursor is obj tile_cursor], [
		[remove_object(cursor) | cursor <- level.chars, cursor is obj tile_cursor, find(level.chars, value = cursor.tile) = null or cursor.tile.selectable = false],

		[fire_event(cursor, 'create') | cursor <- level.chars, cursor is obj tile_cursor, find(level.chars, value = cursor.tile) != null],

		[spawn('tile_cursor', 0, 0, {hex_height: tile_width, tile: tile}) | tile <- level.chars, tile is obj tile, find(level.chars, value is obj tile_cursor and value.tile = tile) = null]

	]),

	]",
	
	creature_clicked: "def(obj creature creature) ->commands execute(me, [
	  ])",
	
	can_use_ability: "def(class creature creature, string ability_name) ->bool
	 state.nteam = state.current_player and observer = false and
	 state.nplayer = creature.controller and
	 ((not state.in_response_phase) or ability.is_response) and
	 ((not ability.uses_action) or creature.has_action) and
	 myplayer.can_afford(ability) and
	 creature.summoned and
	 ability.is_usable(state, creature) and
	 ability.possible_targets(state, creature, []) != []
	  asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)",
	 
	set_status_label: "def(string msg, string color) -> commands [
	]",
	
	_preview_creature: {
		type: "null|custom_obj",
		set: "[
			remove_object(_data),
			set(_data, value),
		]"
	},
	
	set_playing_card_arrows: "def([Loc] targets) ->commands [
		set(_preview_creature, null),

		if(_playing_card != null and targets != [] and _playing_card.card_type is class card and _playing_card.card_type.creature_object != null and _playing_card.card_type.creature_object.is_construct = false and _playing_card.card_type.targets_valid(state, myplayer.creature_avatar, targets), [

		if(creature != null,
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: creature,
				  game_state: outcome,
				  controller: me,
				  hex_height: tile_width,
				  _is_preview: true,
				},
				[
					set(me._preview_creature, child),
				]),
		  if(target_tile != null,
			spawn('game_icon', target_tile.mid_x, target_tile.mid_y - py(16), {
			  size: 48,
			  zorder: get_zorder('status_icon'),
			  icon: 'skull-crack.svg',
			  user_info: 'creature_preview'
			}, [
				set(me._preview_creature, child)
			]
		    )) where target_tile = find(level.chars, value is obj tile and value.loc = targets[0])
		  )
		  
		  //obj represents the existing object representing this creature.
			
		] where creature = outcome.creature_at_loc(targets[0]) or find(outcome.creatures, value.name = _playing_card.card_type.creature_object.name and find(state.creatures, value.summon_id = context.value.summon_id) = null)
		  where outcome = _calculate_play_card(state, _playing_card.card_type, targets)),

		if(_playing_card, set(_playing_card.draw_primitives, map(targets,
		{
			type: 'arrow',
			texture: 'ink.png',
			texture_scale: 0.2,
			arrow_head_length: px(40),
			arrow_head_width: px(100)*0.01*0.4,
			points: [
			  [_playing_card.x2,
			   _playing_card.mid_y + 40*(index+1)/(size(targets)+1)],
			  [target_tile.mid_x, 
			   _playing_card.mid_x + 40*(index+1)/(size(targets)+1)],
			  [target_tile.mid_x, target_tile.mid_y]
			],
		}
		 where target_tile = find_or_die(level.chars, value is obj tile and value.loc = context.value or value is obj player_avatar and context.value = [-1, value.player_num])
		)))
	]",
	
	animate_draw_cards: "def(int ncards) ->commands
	  if(size(cards) >= ncards, map(cards, value.animate_draw(index)))
	  where cards = sort([card | card <- level.chars, card is obj card, card.in_hand, card.hand_index != null], a.hand_index > b.hand_index)",
	
	card_on_stack: "def(object card) ->class message.play_card_base|null
	   find(state.stack, value.stack_id = card.stack_id)
	     asserting _state",

	play_player_damage_hint: "def(class animation.player_damage_hint hint) ->commands if(src and hint.target_player < size(avatar_life), [
		spawn('player_damage_effect', src.mid_x, src.mid_y, {
			amount: hint.amount,
			zorder: 10000,
			_player_index: hint.target_player,
			alpha: 0,
		}, [
			animate(child, {
				alpha: 255,
			}, {
				name: 'anim',
				duration: 90,
			}),

			animate(child, {
				mid_y: avatar_life[hint.target_player].mid_y,
				mid_x: avatar_life[hint.target_player].mid_x,
			}, {
				name: 'anim',
				duration: 50,
				on_complete: remove_object(child),
			})
		]),
	]) where src = find(level.chars, value is obj creature and value.creature_object = hint.source)",

	handle_animation_hint: "def(class animation.hint hint) ->commands [

	if(hint is class animation.player_damage_hint, me.play_player_damage_hint(hint)),
	
	if(hint is class animation.play_card_hint and find(state.stack, value.stack_id = hint.stack_id) != null,
	  ([
		reserve_animation_time('play_card', if(item.player_index = state.nplayer and observer = false, 50, if(lib.citadel.preferences.fast_opponent_plays != true, 150, 100)) where item = find_or_die(state.stack, value.stack_id = hint.stack_id)),
		set(_spell_animation_time, 0),
		if(hint.card.flavor_text != null, spawn('flavor_text_label', level_width/4 + 1d (level_width/2), level_height/4 + 1d (level_height/2), {velocity_x: -50 + 1d100, velocity_y: -50 + 1d100, _text: string<- hint.card.flavor_text, zorder: 5000})),

		spawn('card', xloc, px(220 + 40*size(state.stack)),
		  {
			 card_type: hint.card,
			 controller: me,
			 in_hand: false,
			 allow_drag: true,
			 stack_id: hint.stack_id,
			 stack_info: find_or_die(state.stack, value.stack_id = hint.stack_id),
			 card_size: 1.6,
			 alpha: 0,
			 zorder: get_zorder('card_stack_base') + hint.stack_id,
		  },
			   [
			    if(_animated_spell_card, [
		   		    add(_spells_on_stack, [_animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(_animated_spell_card, child),
				[
				  //if(windup_sound, sound_loop(windup_sound, lib.citadel.sound_volume(windup_sound), 0.5)),
				  if(windup_sound, sound(windup_sound, lib.citadel.sound_volume(windup_sound), 0.5)),
				  set(_spell_windup_sound_being_played, windup_sound)
				] where windup_sound = hint.card.windup_sound,
				schedule(20, set(child.draw_primitives, filter(map(hint.targets, if(target_tile, {
					type: 'arrow',
					texture: 'ink.png',
					texture_scale: 0.2,
					arrow_head_length: px(40),
					arrow_head_width: px(100)*0.01*0.4,
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value is obj tile and value.loc = context.value or context.value[0] = -1 and value is obj player_avatar and value.player_num = context.value[1])), value != null))),

				  if(prev_card != null, child.animate_from(prev_card, 30))
				] where prev_card = find(level.chars, value is obj card and value.card_type = hint.card))
]
	  where xloc = if(hint.player = state.nplayer, level_width*0.15, level_width*0.85)
	  )
	),
	if(hint.type in ['fizzle', 'resolve'],
	  if(fizzling_card,
		if(hint.type = 'fizzle', fizzling_card.start_fizzle_animation(), fizzling_card.start_resolve_animation(targets))
		where targets = filter(level.chars, value is obj tile and value.loc in stack_item.targets) + filter(level.chars, value is obj player_avatar and [-1,value.player_num] in stack_item.targets)
		where stack_item = class message.play_card_base<- fizzling_card.stack_info
	  )
		where fizzling_card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	)
   ]
",

	set_widgets_for_message: "def(class game game) ->commands
	[
	  if(_end_turn_button, remove_object(_end_turn_button)),
	  set(_end_turn_button, null),

	  if(game.nteam = game.current_player and observer = false and _end_turn_pending = false and game.players[game.nplayer].has_ended_turn = false and (game.free_ability = null or not game.free_ability.mandatory),
	  [

	    spawn('end_turn_button', 0, 0, {
			x: 8,
			y: level_height - px(320),
			_width: avatar_width - 16,
			_height: px(60),
			_controller: me,
			_text: if(game.free_ability, 'Cancel', game.in_response_phase, 'Pass', game.has_unresolved_combat, 'Combat', 'End Turn'),
			_phase: if(game.free_ability, 'Triggered Ability', game.in_response_phase, if(game.stack != [], 'Response Phase', if(game.has_unresolved_combat, 'Combat Response Phase', 'Last Chance Response Phase')), 'Play Phase'),
			zorder: get_zorder('hud'),
			highlight: game.in_response_phase or not game.players[game.current_player].has_possible_play(game),
		}, [
			set(_end_turn_button, child),
		]),

	    set_widgets([])

	  ]

     )
	]",
	
	set_schedule_for_message: "def(class game game) ->commands [

	]",

	board_ypos: "int :: (bot_opponent_area + top_player_area)/2 - board_height/2",

	board_width: "tile_width*state.rows",
	board_height: "tile_width*state.columns",
	tile_width: "int :: val - val%4 where val = int((top_player_area - bot_opponent_area - py(80))*0.18 * (5.0/max(state.rows, state.columns)))",
	tile_height: "int :: tile_width",
	tile_border: "int :: 2",
	tile_x_spacing: "int :: tile_width + tile_border",
	tile_y_spacing: "int :: tile_height + tile_border",

	px: "def(int pixels) ->int lib.citadel.py(pixels)",
	py: "def(int pixels) ->int lib.citadel.py(pixels)",


	_trophy_labels: { type: "[obj seal]", default: [] },

	spawn_trophies: "def(class game game) ->commands [
		map(_trophy_labels, [
		  if(game.trophies[value.player_num][value.lane_num] = 0, 
			//this trophy has been destroyed, do its shatter animation
			[
			//if a trophy shatters and a player has less than 20
			//life we will play climax music if it hasn't been played yet.
			if(find(game.players, value.life < 20) != null, play_climax_music()),

			set(value.shattering, true),
			schedule(20, [value.shatter_animation(), remove_object(value)]),
			],
		    remove_object(value)
		  ),
		]),
		set(_trophy_labels, []),

		map(game.trophies, map(value,
		 if(value > 0,
		 spawn('seal', pos[0] + tile_x_spacing*0.5, pos[1] + (if(nplayer = state.nplayer, tile_height, -tile_height)*85)/100, {

			zorder: get_zorder('status_icon'),

			size: px(48),

			player_num: context.index,
			lane_num: index,

			seal_damage: value,
		 }, [
		 	add(_trophy_labels, [child]),
			set(child.mid_x, pos[0] + tile_width*1.3/2),

			if(next_turn_state != null and next_turn_state.trophies[context.index][index] = 0, [
				set(child.green, 0),
				set(child.blue, 0),
			]),
		 ]))
		 where pos = get_tile_pos([nlane, if(nplayer = 0, game.lanes[nlane].begin, game.lanes[nlane].begin + game.lanes[nlane].length-1)])
		 where nlane = index)
		 where nplayer = index)
	]",
	
	spawn_tiles: "def(class game game) ->commands [
		 if(find(level.chars, value is obj tile) = null, 
		   map(locs,
		     spawn('tile', 0, 0, {
				x: get_tile_pos([row,col])[0],
				y: board_ypos + if(state.nteam = 0, (state.columns-1) - col, col)*tile_y_spacing + if(row%2 = 1, if(state.nteam = 0, -1, 1)*tile_x_spacing/2, 0),
				_controller: me,
				game_state:game,
				loc: [row,col],
				hex_height: tile_width,
				_theme: _theme,

				_tile_south: [row,col+if(state.nteam = 0, -1, 1)] in locs,
			})
			  where row = value[0]
			  where col = value[1])
		   
		   where locs = [[row,col] | row<-range(game.rows), col<-range(game.columns), game.is_loc_on_board([row,col])],
		   [ [set(tile.game_state, game)] | tile <- level.chars, tile is obj tile]
		  )
	]
	",

	_cards_sorted_by_hand_position: { default: [], type: "[class card_base]" },
	_card_hand_positions: { default: [], type: "[int]", set: "[set(_cards_sorted_by_hand_position, map(sort(map(hand, {card: value, score: if(index < size(context.value), context.value[index], index)}), a.score < b.score), value.card)), set(_data, value)] where hand = _current_hand" },

	card_hand_position: "def(int hand_index) ->int if(hand_index < size(_card_hand_positions), _card_hand_positions[hand_index], hand_index)",
	position_to_hand_index: "def(int pos, int n=0) ->int if(card_hand_position(n) = pos, n, position_to_hand_index(pos, n+1))",

	set_card_hand_position: "def(int hand_index, int new_position) ->commands
	[
		set(me._card_hand_positions, remapped_positions),
	] where remapped_positions =
	   map(range(max(hand_index+1, size(_card_hand_positions), new_position+1)),
	       if(index = hand_index, new_position,
			  pos + if(pos < current_position and pos >= new_position, 1,
			           if(pos > current_position and pos <= new_position, -1, 0))
			 )
			 where pos = card_hand_position(index)
		  )
	  where current_position = card_hand_position(hand_index)
	",

	ally_hand_left_side: "0.56",
	ally_hand_area: "0.18",

	enemy_hand_left_side: "0.31",
	enemy_hand_area: "0.33",

	hand_left_side: "if(size(myteam) <= 1, 0.31, 0.22)",
	hand_area: "if(size(myteam) <= 1, 0.33, 0.23)",
	hand_right_side: "hand_left_side + hand_area",
	hand_card_size: "if(size(myteam) <= 1, 1.0, 0.8)",

	//metrics for the crypt/discard/etc display areas.
	left_edge_display_areas: "(hand_left_side-0.03)*level_width",
	right_edge_display_areas: "(hand_right_side+0.07)*level_width",
	display_area_width: "px(if(hand_card_size = 0.8, 138, 170))",

	cards_in_hand_positions: "def([class card_base] hand, decimal left_side, decimal area) ->[{zorder: int, mid_x: int, mid_y: int, rotate: decimal, card_size: decimal}]
	  map(hand,
	   {
		 mid_x: int(if(card_obj != null and card_obj.keep,
		           right_edge_display_areas + display_area_width/2 + px(index_keep*40)
				     where index_keep = count(hand, index < context.index and card != null and card.keep where card = hand_cards[index]),
		           px(20) + level.dimensions[2] * (left_side + ratio*area))),
		 mid_y: int(level_height - py(90)),
		 rotate: int(-5 + ratio*10.0),
		 card_size: me.hand_card_size,
		 zorder: get_zorder('card_in_hand_base') - card_hand_position(index)
	   }
		 where ratio = (card_hand_position(index) + 0.5)/size(hand)
		 where card_obj = null|obj card :: hand_cards[index]
	  )

	  where hand_cards = map(hand, null|obj card :: find(level.chars, (value is obj card) and value.card_type = context.value))
	",

	find_card_obj: "def(class card_base card) ->null|obj card find(level.chars, (value is obj card) and value.card_type = card)",

	update_schedule_objects: "def() -> commands [
	]",
	
	spawn_cards_in_graveyard: "def() ->commands [
	]",

	_selected_creature_avatar: { set: "[if(_data, animate(_data, {alpha: 0}, {duration: 25, on_complete: remove_object(_data)})), set(_data, value)]", type: "null|obj player_avatar" },
	_selected_creature: { set: "[if(value = null, set(_selected_creature_avatar, null)), set(_data, value)]", type: "null|obj creature" },

	_casting_creature: "class creature :: if(_selected_creature != null, _selected_creature.creature_object, myplayer.creature_avatar)",

	_current_hand: "[class card_base] :: if(_selected_creature, _selected_creature.creature_object.activated_abilities, state.players[state.nplayer].hand)",

	spawn_activated_ability_cards: "def(obj creature creature) ->commands
	execute(me, [
		[[animate(c, {mid_y: level_height - py(20), mid_x: int(hand_right_side*level_width + px(120))}, {duration: 20}), set(c.in_hand, false), set(c.hand_card_off_to_side, true)] | c <- level.chars, c is obj card, c.in_hand],

		set(_card_regions, []),

		set(_selected_creature, creature);

		spawn_cards_in_hand(),

		[
			add_object(avatar),
			add(avatar.zorder, 1),
			set(avatar.alpha, 0),
			animate(avatar, {
				alpha: 255,
			}, {
				duration: 25,
			}),
			set(_selected_creature_avatar, avatar),
		] where avatar = create_player_avatar(myplayer, creature.creature_object),
	]
	)
	",

	finish_activated_ability_cards: "def() ->commands [
		[remove_object(c) | c <- level.chars, c is obj card, c.in_hand, c.player_index = myplayer.player_index],
		set(_selected_creature, null),
	]",

	spawn_cards_in_hand: "def() ->commands

	[
	  debug('SPAWN CARDS IN HAND'),
	   set(_card_hand_positions, map(hand, index(hand_sorted, value))),
	   bind_command(_spawn_cards_in_hand_internal),
	]
	    
		where hand_sorted = [class card_base] ::
		if (sort_type and sort_type='by_cost',
		  sort(hand, by_cost(a,b)),
		  sort_type and sort_type='by_school_by_cost',
		  sort(hand, by_school_by_cost(a,b)),
		  // Fall back to default sort
		  sort(hand, by_default(a,b)))

		where hand = _current_hand
		where by_cost = function(class card_base, class card_base) -> bool ::		by_value_or(keep_fn, by_value_or(cost_fn, by_index))
		where by_school_by_cost = function(class card_base, class card_base) -> bool ::	by_value_or(keep_fn, by_value_or(school_fn, by_value_or(cost_fn, by_index)))
		where by_default = function(class card_base, class card_base) -> bool ::		by_value_or(keep_fn, by_value_or(new_fn, by_index))
		// higher order function to simplify the iterated fallback logic
		where by_value_or = def(function(class card_base) -> any val, function(class card_base, class card_base) -> bool fallback) //-> (function(class card a, class card b) -> bool)
			(def(class card_base a, class card_base b)->bool
			if (val_a != val_b,
				val_a < val_b,
				fallback(a,b))
			where val_a = val(a)
			where val_b = val(b))

		where keep_fn = def(class card_base c) -> bool
		(obj_c != null and obj_c.keep where obj_c = find_card_obj(c))
		where new_fn = def(class card_base c) -> bool (index_fn(c) != -1)
		where by_index = def(class card_base a, class card_base b) -> bool index_fn(a) < index_fn(b)
		where index_fn = def(class card_base c) -> int index(_cards_sorted_by_hand_position, c)
		where cost_fn = def(class card_base c) -> int state.players[state.nplayer].calculate_cost(c)
		where school_fn = def(class card_base c) -> int fold(c.school, max(a,b), 0)		
		where sort_type = string|null <- lib.citadel.preferences['sort_type']
	",

	_spawn_cards_in_hand_internal: "def() ->commands
	map(myteam,
		_spawn_cards_in_player_hand_internal(value, if(value = myplayer, _current_hand, value.hand),
		     if(not is_ally, hand_left_side, ally_hand_left_side),
		     if(not is_ally, hand_area, ally_hand_area),
			 is_ally
		)

		where is_ally = (value.player_index != state.nplayer)
	)
	",

	_spawn_cards_in_player_hand_internal: "def(class player player, [class card_base] hand, decimal left_side, decimal area, bool is_ally) ->commands
	[
	  if(is_ally = false, set(_card_regions, [])),
	  map(hand,
	    
	   [
	   if(card_obj != null,
	     [
		   set(card_obj.hand_index, index),
		   set(card_obj.in_hand, true),
		   set(card_obj.hand_card_off_to_side, false),
		   set(card_obj.highlight, highlight_card),

		   set(card_obj.is_castable, is_castable),

		   if(card_obj != card_mouseover and card_obj != _playing_card and card_obj != _pending_card_discard, [
			   animate(card_obj, {
				  mid_x: pos.mid_x,
				  mid_y: pos.mid_y,
				  rotate: positions[index].rotate
				}, {
				  duration: 10,
				  name: 'card_move',
				  replace_existing: true,
				}),

			   set(card_obj.zorder, pos.zorder),
			   set(card_obj.card_size, pos.card_size),
		   ])
		 ],

	     spawn('card', pos.mid_x, int(card_top),
		 {
			facing: 1,
			controller: me,
			in_hand: true,
			player_index: player.player_index,
			hand_index: index,
			zorder: pos.zorder,
			rotate: positions[index].rotate,
			card_size: pos.card_size,
			player: player,
			card_type: value,
			parent_creature: if(_selected_creature, _selected_creature.creature_object),
		 }, 
		 [
		    set(child.mid_x, pos.mid_x),
			set(child.mid_y, pos.mid_y),

			//make the new card animate its way in if it's just been drawn.
			if(suppress_animations = false,
			   fire_event(child, 'animate_draw')),

			set(child.highlight, highlight_card),
			set(child.is_castable, is_castable),
		  ])
		),
		if(is_ally = false, add(_card_regions, [{left: int(pos.mid_x - card_width/2), right: int(pos.mid_x + card_width/2), top: int(card_top), card_num: index}] where card_width = 160))
		]

		 where is_castable = (state.nteam = state.current_player_index and player.can_afford(value) and card_instance.is_usable(state, _casting_creature) and (state.in_response_phase = false or value.is_response) and _tutorial.filter_targets(me, value, value.possible_targets(state, myplayer.creature_avatar, [])) != [])
		 
		 where card_obj = null|obj card :: find_card_obj(card_instance)
		 where pos = positions[index]
		 where highlight_card = (state.nteam = state.current_player_index) and state.in_response_phase and card_instance.is_response and player.can_afford(card_instance)
		 where card_instance = class card_base :: value
	   ) where positions = cards_in_hand_positions(hand, left_side, area),

	   set(me._card_hand_top, card_top),

	   update_archive_count(),
	]
  where card_top = decimal :: top_player_area
  where hand_size = int :: size(hand)
	",
	
	create_player_avatar: "def(class player player, null|class creature creature=null) ->obj player_avatar
		
		object('player_avatar', 200, 200, {
			player_num: index,
			_creature: creature,
			_avatar: player.avatar,
			zorder: get_zorder('avatars'),
			_top: if(player = team[0] and size(team) > 1, level_height/2, 0),
			_width: avatar_width,
			_height: if(size(team) = 1, level_height, level_height/2),
			_edge: if(same_team, avatar_width, level_width - avatar_width),
			_available_space: avatar_width,
			_nick: player.name,
			facing: if(same_team, 1, -1),
			highlight: state.current_player_index = index,
			current_desaturation: if(prev_avatar, prev_avatar.current_desaturation, if(state.current_player_index = index, 0.0, 1.0)),
			target_desaturation: if(state.current_player_index = state.team_index(index) and player.has_ended_turn = false, 0.0, 1.0),
		}
		)
		   where same_team = (state.team_index(index) = state.team_index(state.nplayer))
		   where team = get_player_team(player)
		   where prev_avatar = if(index < size(_avatars), _avatars[index])
		   where index = player.player_index
	",

	create_avatars: "def() ->commands [
		map(_avatars, remove_object(value)),
		set(_avatars, []),

		map(avatar_life, remove_object(value)),
		set(avatar_life, []),

		map(avatar_crypts, remove_object(value)),
		set(avatar_crypts, []),

		map(avatar_decks, remove_object(value)),
		set(avatar_decks, []),

		map(state.players, [add(_avatars, [new_avatar]), add_object(new_avatar)] where new_avatar = create_player_avatar(value)),

		//[debug(['HAVE PLAYER DAMAGE: ', hint.source.loc])  | hint <- state.animation_hints, hint is class animation.player_damage_hint],

		map(state.players[:state.num_teams], spawn('life_bar', 0, 0, {
			x: avatar_stats_left(player.player_index),
			y2: level_height - px(100),
			_width: avatar_stats_width,
			_height: px(90),
			zorder: 1000,
			max_life: 40,
			current_life: player.life,
			_prev_current_life: if(size(avatar_life) > index, avatar_life[index].current_life),
		}, [
			add(me.avatar_life, [child]),
		])
		  where player = value
		),

		map(state.players, spawn('crypt_library_display', 0, 0, {
			_text: 'Crypt',
			items: player.discard_pile,
			_width: avatar_stats_width/2 - 8,
			_height: px(28),
			x: avatar_stats_left(player.player_index),
			y: level_height - px(40),
			zorder: 1000,
			is_crypt: true,
			player_index: player.player_index,
		}, [
			add(me.avatar_crypts, [child]),
		])
		  where team = get_player_team(player)
		  where player = value
		),

		map(state.players, spawn('crypt_library_display', 0, 0, {
			_text: 'Library',
			items: player.deck,
			_width: avatar_stats_width/2 - 8,
			_height: px(28),
			x: avatar_stats_left(player.player_index) + avatar_stats_width - (avatar_stats_width/2 - 8),
			y: if(player = team[0], level_height, level_height/2) - px(40),
			zorder: 1000,
			is_crypt: false,
			player_index: player.player_index,
		}, [
			add(me.avatar_decks, [child]),
		])
		  where team = get_player_team(player)
		  where player = value
		),

		set(_mana_display_adjustment, 0),
		bind_command(display_mana),
		
		//spawn level symbols
		map(state.players,
		
		map(sorted_objects, [
			if(value.order = -1, add_object(value)),
			set(value.order, order),
			set(value.mid_x, if(player_index = state.nplayer, avatar_width + positions[index][0], level_width - avatar_width - positions[index][0])),
			set(value.mid_y, level_height - px(200) + positions[index][1]),

			value.update_object(player.resource_level[value.school]),

			animate(value, {
				alpha: 255,
			}, {
				duration: 20
			}),

		] where positions = map(range(6), [lib.citadel.px(if(value <= 2, -60 - value*80, -60 - 40 - (value-3)*80)), lib.citadel.py(if(value <= 2, 0, 30))])
		  where order = if(value.order = -1, highest_order + index + 1, value.order)
		)
		where sorted_objects = sort(objects, if(a.order=-1, 10000, a.order) < if(b.order=-1, 10000, b.order))
		where highest_order = if(val, val, 0) where val = max(map(objects, value.order))
		where objects = [if(existing, existing,
		   object('level_display', 0, 0, {lvl: 0, school: school, player_num: player_index, alpha: 0, zorder: get_zorder('hud')}))
		     where existing = find(level.chars, value is obj level_display and value.school = school and value.player_num = player_index)
		 | school <- schools]
		where schools = filter(keys(player.resource_level), player.resource_level[value] > 0 or find(level.chars, value is obj level_display and value.school = context.value and value.player_num = player_index) != null)
		where player = value
		where player_index = index),

		[remove_object(c) | c <- level.chars, c is obj creature_in_citadel],

	]",

	_mana_display_adjustment: { default: 0 },

	adjust_mana: "def(int delta) ->commands [
		add(_mana_display_adjustment, delta),
		bind_command(_schedule_display_mana),
	]",

	_last_mana_adjust: { type: "null|int" },
	_schedule_display_mana: "def() ->commands [
		if(_last_mana_adjust = null or _last_mana_adjust <= cycle, [
			execute(me, schedule(5, bind_command(display_mana, 0))),
			set(_last_mana_adjust, cycle + 5),
		]),
	]",

	_set_mana_bar_using: "def(int amount) ->commands 
		if(mana_bar, [
			set(mana_bar.using_mana, amount)
		])
	",

	mana_bar: { type: "obj mana_bar|null" },

	_player_mana_bars: { type: "[obj mana_bar]", default: [] },

	locked_mana: { type: "int|null" },

	display_mana: "def(int delay=50) ->commands [

		map(_player_mana_bars, remove_object(value)),
		set(_player_mana_bars, []),
		set(mana_bar, null),

		map(state.players,

			spawn('mana_bar', 0, 0, {
				x: avatar_stats_left(index),
				y2: level_height - px(50),
				_width: avatar_stats_width,
				_height: px(90),
				zorder: 1000,
				max_mana: player.calculate_income(state),
				current_mana: player.resources,

				_prev_current_mana: if(prev_bar != null, prev_bar.current_mana),
				_prev_max_mana: if(prev_bar != null, prev_bar.max_mana),

				_controller: me,
				_is_player: index = state.nplayer and observer = false,
			}, [
				if(player = myplayer, set(me.mana_bar, child)),
				add(me._player_mana_bars, [child]),
			])
		   where prev_bar = null|obj mana_bar :: if(index < size(_player_mana_bars), _player_mana_bars[index])
		   where team = get_player_team(player)
		   where player = value
		)
	]",

	_chat_area: { type: "null|obj chat_area" },
	_last_chat_area_interact: { default: 0 },

	spawn_chat_widgets: "def(null|{nick: string, text: string} msg=null) ->commands
	if(_state != null, [
		set(_last_chat_area_interact, cycle),
		if(_chat_area = null,
		  spawn('chat_area', 0, 0, { x: level_width-avatar_width, y: level_height/2, zorder: get_zorder('chat_gui'), chat_width: avatar_width },
		        [
				  set(me._chat_area, child),
				  if(msg != null and _state, child.message_received(msg.nick, msg.text)),
				  set(child.has_focus, true),
				]),
				
		 [
		 if(find(level.chars, value = _chat_area) = null, add_object(_chat_area)),
		 if(msg != null, _chat_area.message_received(msg.nick, msg.text)),
		 set(_chat_area.has_focus, true),
		 ]),
	])",

	spawn_opponent_cards: "def() ->commands [
	  debug('DDD: SPAWN OPPONENT'),
	  //get rid of existing opponent cards that should no longer be there.
	  [ if(card.card_type.orphaned_by_update,
	  	   animate(card, {
			mid_x: 60,
			mid_y: 204,
			scale: 0.5,
			rotate: 180,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   }),
		   remove_object(card))

	   | card <- level.chars, card is obj card, card.in_opponent_hand, find(hand, value = card.card_type) = null],

	  //create new card objects and update existing ones.
	  map(pos, if(obj = null or obj.show_back != show_card_back, [
	    remove_object(obj),
	    spawn('card', 0, 0, {
			 zorder: value.zorder,
			 show_back: show_card_back,
			 in_opponent_hand: true,
			 card_type: hand[index],
			 controller: me,
			 card_size: 0.8,
			 mid_x: if(index = _opponent_hand_mouseover and _opponent_card_playing, px(160), value.mid_x),
			 mid_y: if(index = _opponent_hand_mouseover and _opponent_card_playing, py(160),
				          level_height - value.mid_y - py(130) + if(index = _opponent_hand_mouseover, py(20), 0)),
			 rotate: 180 + if(index = _opponent_hand_mouseover, 0, -value.rotate),
			 scale: 1.0,
		},
		[
			if(suppress_animations = false, [
				set(child.mid_x, px(80)),
				set(child.mid_y, py(80)),
				set(child.rotate, 180),
				set(child.scale, 0.4),
				animate(child, {
					mid_x: child.mid_x,
					mid_y: child.mid_y,
					rotate: child.rotate,
					scale: child.scale,
				}, {
					duration: 25,
				}),
			]),
		])
		],

		[
			animate(obj, {	
			 mid_x: if(index = _opponent_hand_mouseover and _opponent_card_playing, px(160), value.mid_x),
			 mid_y: if(index = _opponent_hand_mouseover and _opponent_card_playing, py(160),
				          level_height - value.mid_y - py(130) + if(index = _opponent_hand_mouseover, py(20), 0)),
				rotate: 180 + if(index = _opponent_hand_mouseover, 0, -value.rotate),
			}, {
				duration: 10,
			}),
			set(obj.zorder, value.zorder),
		]

		)
	  where show_card_back = (observer = false and myplayer.can_see_enemy_hand <= 0)
	  where obj = find(level.chars, value is obj card and value.in_opponent_hand and value.card_type = hand[context.index]))
	]
      where pos = cards_in_hand_positions(hand, enemy_hand_left_side, enemy_hand_area)
	  where hand = state.players[(state.nplayer+1)%2].hand
	",

	_calculate_play_card: "def(class game state, class card card, [Loc] targets) ->class game
		get_modified_object(state, def(class game g) ->commands g.resolve_card(construct('message.play_card', {type: 'play_card', player_index: g.nplayer, targets: targets, card: card })))
	",

	_calculate_end_of_turn_state: "def(class game state) ->class game
		if(state.current_choice != null or
		   (not state.in_response_phase) and
		   state.has_unresolved_combat = false,
		   state, _calculate_end_of_turn_state(get_modified_object(state, def(class game g) g.end_turn())))
	",

	_calculate_next_turn_state: "def(class game state, int nturn) ->class game
	    if(state.current_choice != null or
		   state.nturn > nturn,
		   state,
		   _calculate_next_turn_state(get_modified_object(state, def(class game g) g.end_turn()), nturn))
	",

	spawn_game_icons: "def(class game state) ->commands [
		[remove_object(icon) | icon <- level.chars, icon is obj game_icon, icon.user_info = 'status_icon'],
		[spawn('game_icon', pos[0]+70, pos[1] + if(state.nplayer != c.controller, 100, 0), {
			mid_x: pos[0] + tile_width*0.66,
			mid_y: pos[1] + tile_height*0.5*if(state.nteam = c.controller, -1, 1),
			size: 48,
			zorder: get_zorder('status_icon'),
			icon: 'crossed-axes.svg',
			user_info: 'status_icon'
		}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.is_engaged(state)],

		[spawn('game_icon', pos[0]+50, pos[1] + 40, {size: 48, zorder: get_zorder('status_icon'), icon: 'bowman.svg', user_info: 'status_icon'}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.has_action, c.is_engaged(state) = false, c.range > 0, size(c.targets_attacking(state)) > 0],

		[map(filter(map(c.status_effects, icon_info[value]), value != null),
		     spawn('game_icon', pos[0]+90 - index*4 - index*index*2, pos[1] + 50 - 20*index,
			   {size: 24, user_info: 'status_icon', zorder: get_zorder('status_icon')} + value))
		  where pos = get_tile_pos(c.loc) | c <- state.creatures]
		     where icon_info = {string -> map} <-
			     get_document('data/status_effect_icons.cfg'),

	]",
	
	get_tile_pos: "def(Loc pos) ->Loc [
		(level.dimensions[2] - board_width)/2 + pos[0]*tile_x_spacing - tile_x_spacing/4,
		board_ypos + if(state.nteam = 0, (state.columns-1) - pos[1], pos[1]+1)*tile_x_spacing + if(pos[0]%2 = 1, 0, if(state.nteam = 0, 1, -1)*tile_x_spacing/2),
	]",

	_sent_game_result: { default: false },

	_resource_y_pos: "def(bool is_local, int nresource, int max_resource) ->int
	   if(is_local, level_height - 380 - nresource*54,
			        260 + nresource*54)",

	_xp_objects: { type: "[custom_obj]", default: [] },

	_mana_x_pos: "def(int nmana, int max_mana) ->int
	   40 + nmana*spacing where spacing =  int(min(40, (level_width*0.2)/max_mana))",
	
	_processed_animation_hints: { type: "[class animation.gain_mana_hint]", default: [] },

	display_player_mana: "def(class game state) ->commands [

	]",

	count_cards_in_archive: "int :: count(level.chars, value is obj card and value.keep)",
	update_archive_count: "def() ->commands
		null",

	display_game_status: "def(class game state) ->commands [

	]",

	display_free_ability: "def(class game state) ->commands
	if(state.free_ability != null and state.free_ability.nplayer = state.nplayer,
	if(possible_targets != [],
	[
	if(_playing_card != null, [
		remove_object(_playing_card),
		set(_playing_card, null),
	]),

	spawn('card', level_width/2, level_height/2, {
		card_type: state.free_ability.ability,
		mandatory_play: true,
		in_hand: false,
		allow_drag: false,
		controller: me,
		parent_creature: creature,
	}, [
		set(me._playing_card, child)
	]);

	choose_targets_for_card(obj card<- me._playing_card, [])

	])
 	  where possible_targets = state.free_ability.ability.possible_targets(state, creature, [])
	  where creature = state.free_ability.creature
	
	
	)",
	
	display_choice: "def(class game state) ->commands [
	  if(_choice_object, [_choice_object.exit_dialog(), set(_choice_object, null)]),
	  if(state.current_choice and state.current_choice.player_index = state.nplayer,
	  	schedule(30, spawn('choice_controller', 0, 0,
		{
			_mm: me,
			_controller: me,
			game: state,
		}, [
			set(_choice_object, child),
			//debug('spawned choice'),
		 ])))
    ]",

	update_log: "def(class game game) ->commands
	[
	 if(_chat_area, _chat_area.set_game_log([string]<- game.log)),
	 log_controller.set_log([string]<- game.log, if(_state, myplayer, null))
	  asserting log_controller
	  where log_controller = find(level.chars, value is obj log_controller)
	  
	]",

	_submit_deck_time: { type: "int|null" },
	force_submit_deck: "def([string] deck) ->commands [
		execute(me, tbs_send(client, {type: 'submit_deck', deck: deck, force: true})),
		set(_submit_deck_time, level.cycle),
	]",

	top_player_area: "int :: level_height - px(250)",

	bot_opponent_area: "int :: px(50)",
	avatar_width: "w + if(w%2 = 1, 1, 0) where w = int(level_width*0.19)",

	avatar_stats_left: "def(int nplayer) ->int
	  if(state.team_index(nplayer) = state.nteam, 8, level_width - avatar_stats_width - 8)",
	
	avatar_stats_width: "int :: avatar_width - 16",

	_awarding_cards: "bool :: find(level.chars, value is obj card and value.in_victory) != null",

	award_cards: "def([string] card_names) ->commands [
	map(card_names,
	schedule(150 + index*20,
		spawn('card', level_width/2, level_height/2,
		  {
			 card_type: lib.citadel.create_card(value),
			 controller: me,
			 in_hand: false,
			 allow_drag: false,
			 in_victory: true,
			 card_size: 0.6,
			 alpha: 0,
			 zorder: 20000,
		  },
		  [

		  	animate(child, {
				card_size: 1.0,
				alpha: 255,
				mid_x: level_width/2 + xy_target[0]*3,
				mid_y: level_height/2 + xy_target[1]*3,
			}, {
				name: 'present',
				duration: 100,
			}),

		  	animate(child, {
				alpha: 255,
			}, {
				name: 'present',
				duration: 150,
			}),
		  ]
		)
		where xy_target = [
		  [0,-level_height/10], [0,level_height/10], [level_width/12,level_height/12],
		  [-level_width/12,-level_height/12], [-level_width/12,level_height/12], [level_width/12,-level_height/12]][index%6]
	)
	),

	if(card_names,
		spawn('hint_label', level_width/2, level_height/2, {
			zorder: 20000,
			_text: ['You have won new cards!'],
			_delay: 100,
			_fade_duration: 50,
			_font_size: 48,
		}, [
		])
	)
	]",

	generate_tips: "def(class game game) ->[Tip|null]
	if(find(game.players, value.deck_submitted = false) != null,
	   [],
	   _tutorial.override_tips, _tutorial.generate_tips(me, game),
	   game.nplayer = game.current_player_index and game.current_choice = null,
	     lib.tips.generate_tips(me, game), [
	])
	",

	_tooltip: { type: "[custom_obj]", default: [] },

	_current_tip: { type: "null|obj tip_dialog" },
	_current_tip_key: { type: "null|string" },

	_shown_tips: { type: "{string -> bool}", default: {} },

	_create_tip_dialog: "def(Tip|null best_tip) ->commands [
		if(_current_tip, [remove_object(_current_tip), set(_current_tip, null)]),
		set(me._current_tip_key, null),
		if(best_tip != null, [
			set(_shown_tips[best_tip.key], true),

			if(best_tip.clear_key is string,
				add(_shown_tips, {(best_tip.clear_key): false}),
			),

			if(best_tip.key = 'card_anatomy',
				schedule(60, spawn('inspect_card_dialog', 0, 0, { _mm: me, _controller: me, _card: obj card<- best_tip.targets[0], _display_help: true, })) asserting best_tip.targets != null,
			   best_tip.is_modal,
				[
					schedule(5, spawn('modal_tip_dialog', 0, 0, { _mm: me, _controller: me, _tip: best_tip }))
				],

				spawn('tip_dialog', 100, 100, {
					zorder: 10000,
					_tip: best_tip,
					_width: 260,
					_height: 200,
					alpha: 0,
				}, [
					set(me._current_tip, child),
					set(me._current_tip_key, best_tip.key),
					set(child.x, level_width - 200),
					set(child.y2, (bot_opponent_area + top_player_area)/2),
					animate(child, {
						alpha: 255,
					}, {
						duration: 30,
					}),
				])
			)
		]),
	]",

	spawn_tip_object: "def(class game game) ->commands
	[
	if(best_tip != null and best_tip.key = _current_tip_key,
	null, //no-op, keep the current tip showing.
	[
		_create_tip_dialog(best_tip), //show the new tip dialog
	])
	]
	where best_tip = find(tips, value != null and (_shown_tips[value.key] != true or value.key = _current_tip_key) and (lib.citadel.num_times_tip_shown(value.key) < if(value.max_shows = null, 1, value.max_shows) or _tutorial.override_tips))
	where tips = generate_tips(game)",
	
	show_tooltip: "def() ->commands [
		if(obj != null,
			fire_event(obj, 'show_tooltip', {controller: me})
		)
		where obj = choose(filter(level.chars, (value is obj creature and value.has_mouseover or value is obj seal) and mouse_x > value.x and mouse_x < value.x2 and mouse_y > value.y and mouse_y < value.y2), value.zorder)
		
	]",

	set_tooltip: "def(custom_obj obj) ->commands [
		map(_tooltip, remove_object(value)),
		set(_tooltip, [obj])
	]",

	append_tooltip: "def(custom_obj obj) ->commands [
		add(_tooltip, [obj]),
	]",

	clear_tooltips: "def() ->commands [
	 map(_tooltip, remove_object(value)),
	 set(_tooltip, []),
	]",

	show_intro_sequence: "def(string sequence_type) ->commands [
		schedule(2, spawn('intro_animation_controller', 0, 0, {
			sequence_type: sequence_type,
		})),
	]",

	suppress_animations: { default: false },

	_allow_deltas: { default: false },

	get_game_state_from_delta: "def(int delta_basis, any delta) ->class game|null
	if(base_state != null, class game<- apply_delta(base_state, delta))

	where base_state = class game|null ::
	     if(_processed_state_id = delta_basis,
		    _state,
	        if(msg, class game<- msg.state)
			    where msg = find(_game_state_queue, value.state_id = delta_basis)
		 )
	",

	_played_climax: { type: "bool", default: false },
	play_climax_music: "def() -> commands if(_played_climax = false, [
		music_onetime(_music_theme + '_climax_intro.ogg'),
		schedule(100, music_queue(_music_theme + '_climax.ogg', 0)),
		set(_played_climax, true),
	])",

	_music_theme: { type: "string", default: "materia" },
},

on_settings_menu: "if(level.show_builtin_settings_dialog and not paused, [
	set(level.show_builtin_settings_dialog, false),
	spawn('pause_dialog', 0, 0, { _mm: me, _controller: me, }),
])",

on_generate_mouseover_card: "mouse_enter_card(obj card<- arg.card)",

on_construct: "[set(lib.citadel.native_card_sizes, [0.8,1.0,2.0])]",

on_create: "[
	if(is_online_game, [music_onetime('start-game.ogg'), schedule(50, music_queue(_music_theme + '.ogg'))],
	
	music(_music_theme + '.ogg')),

	report({ type: 'start_scenario', scenario: campaign_scenario, location: campaign_location, }),
	lib.citadel.set_screen_dimensions(level),

	add_object(_storyline),

	if(lib.citadel.preferences.disable_animations != true,
		map(_theme.board_shaders,
			add(level.frame_buffer_shaders, [{
				begin_zorder: -1000000,
				end_zorder: get_zorder('board_shader'),
				shader_info: value,
			}])
		)
	),

	fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),
	console_output_to_screen(false),
	
	if(observer,
	[
		set(me._client, cl),
		tbs_send(cl, {type: 'observe_game', user: USERNAME}),
	] where cl = create_tbs_client(),

	if(size(get_module_args()) > 0, 
	[set(me._client, cl),
	tbs_send(cl, {type: 'start_game'}), debug('game created')] where cl = create_tbs_client(),
	if(game_created, 
	[set(me._client, cl), debug('game created')]
		where cl = create_tbs_client()
	)))
]
",

on_update_discard_and_deck: "[
	map(_deck_obj, value.set_label(str(size(state.players[index].deck)), me.font)),
]",

on_update_storyline: "[
	fire_event(_storyline, 'game_updated')
]",

on_window_resize: "[
	[ [add(card_back.x, delta_w)]
	| card_back <- level.chars,
	  card_back is obj citadel_controller.card_back,
	  card_back.player_index = 1],

	[ tile.destroy() | tile <- level.chars, tile is obj tile ],

	set(level.dimensions, [0,0,new_width,new_height]),

	fire_event('dimensions_updated'),

] where delta_w = new_width - level_width
  where delta_h = new_height - level_height
  where card_width = min(135*card_scale, if(hand_size, card_area/hand_size, 100))
  where card_scale = max(1.0, decimal(card_area)/decimal(1024 - 300))
  where card_area = new_width - 300
  where new_width = max(int<- arg.width,800)-1
  where new_height = max(int<- arg.height,600)-1
  where hand_size = count(level.chars, value is obj card and value.in_hand)",

on_dimensions_updated: "[
	lib.citadel.set_screen_dimensions(level),

	if(_chat_area, [
		remove_object(_chat_area),
	//	set(_chat_area, null),
	]),

	if(_background_canvas, remove_object(_background_canvas)),

	[
		set(_theme.left_edge, int(avatar_width*(800.0/level_width))),
		set(_theme.right_edge, int((level_width - avatar_width)*(800.0/level_width))),
		set(_theme.top_edge, int(bot_opponent_area*(600.0/level_height))),
		set(_theme.bottom_edge, int(top_player_area*(600.0/level_height))),
	];

	spawn('canvas', 0, 0, {zorder: -10}, [
		child.draw(bg_width, bg_height, [
			c.scale(bg_width/888.0, bg_height/403.0),
			c.paint_image('images/' + _theme.background_image)
		] where c = canvas()),
		set(child.mid_x, level_width/2),
		set(child.y, bot_opponent_area),
		set(_background_canvas, child),
		if(lib.citadel.preferences.disable_animations != true and (_theme.particle_effects is map), set(child.particles, _theme.particle_effects))
	])
	where bg_width = round_to_even(level_width - avatar_width*2)
	where bg_height = round_to_even(top_player_area - bot_opponent_area),

	;
	set(draw_primitives, [
	{
		type: 'rect',
		area: [0,0,level_width,bot_opponent_area],
		color: map(_theme.play_area_color, int(value*256)),
	},
	{
		type: 'rect',
		area: [0,top_player_area,level_width,level_height],
		color: map(_theme.play_area_color, int(value*256)),
	},
	
	]),

	if(_last_state_message, [
		bind_command(_tutorial.game_updated, me, state),

        display_choice(state),
		set_widgets_for_message(state),
		set_schedule_for_message(state),
		spawn_trophies(state),
		spawn_tiles(state),
		adapt_input_state(),
		display_game_status(state),
		display_player_mana(state),
		update_log(state),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		spawn_opponent_cards(),
		update_schedule_objects(),
		display_free_ability(state),

		fire_event('game_updated'),
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0,
	       { controller: me, game_state: state, facing: 1, creature_object: creature.creature_object, hex_height: tile_width })
	          asserting creature.creature_object]
	| creature <- level.chars,
	  creature is obj creature,
	  creature.creature_object.is_on_board ]
]",

on_update_spells_on_stack: "
 [
  set(_spells_on_stack, survivors),
  map(leaving, execute(value, [
	//if(_spell_windup_sound_being_played, stop_sound(_spell_windup_sound_being_played, 0.5)),
	[schedule(n, [
	  map(value.draw_primitives, set(value.color, [255,0,0,255-n*10]))])
	  | n <- range(25)],
	schedule(100, remove_object(value)),
  ]))
 ]
  where leaving = filter(_spells_on_stack, not card_on_stack(value))
  where survivors = filter(_spells_on_stack, card_on_stack(value))",

on_update_game: "
   if((not force_process) and
      (_game_state_queue != [] or cycle < _animation_end_time or paused),
	 add(_game_state_queue, [message]),
     fire_event('do_update_game', {message: message})
	 )
     where message = map<- arg.message,
         force_process = null|bool<- arg.force_process
",

on_do_update_game: "
     if(state_id > _processed_state_id,
	 [
	 	//add(game_log, [message]),

	    if(_state != null and _state._uuid = game_state._uuid,
		   [update_object(_state, game_state)],
		   set(_state, game_state)
		),

		if(is_new_turn or _state = null, spawn('turn_banner', 0, 0, {
			_text: if(observer, game_state.players[game_state.current_player_turn_index].name + q('s Turn), if(xor, 'Your Turn', q(Opponent's Turn)))
			where xor = if (game_state.in_response_phase, not is_your_turn, is_your_turn),
			zorder: 4000,
		})),

	    set(me._processed_state_id, state_id),

	    set(_last_state_message, message),

		[
			set(end_of_turn_state, state_end_turn),
			set(next_turn_state, state_next_turn),
		] where state_next_turn = _calculate_next_turn_state(state_end_turn, game_state.nturn)
		  where state_end_turn = _calculate_end_of_turn_state(game_state),

		set(force_skip_responses, new_force_skip_responses),

		set(_tutorial, game_tutorial),
		set(_tutorial_init, true),

		// automatically send end turn in response phases.
		if((observer = false) and
			is_your_turn and
			turn_is_not_ended_already and
			game_state.in_response_phase and
			game_state.current_choice = null and
			game_state.free_ability = null and
			skipping_is_allowed and
			should_skip and
			_tutorial.skip_response_phase(me, game_state)
			where turn_is_not_ended_already = (game_state.players[game_state.nplayer].has_ended_turn = false)
			where skipping_is_allowed = (lib.citadel.preferences.hold_responses != true)
			where should_skip = new_force_skip_responses or have_no_possible_response or (game_state.is_final_response and would_win_anyways)
			where have_no_possible_response = (game_state.players[game_state.nplayer].has_possible_response(game_state) = false)
			where would_win_anyways = (future.players[opponent_index].life <= 0)
			where opponent_index = game_state.next_player_index
			where future = get_modified_object(game_state, def(class game g) g.end_turn()),

			end_turn()
		),

		bind_command(game_tutorial.game_updated, me, game_state),
		fire_event('game_updated'),
     ]
	 where game_tutorial = if(_tutorial_init = false, class client_tutorial<- construct(game_state.tutorial.client_tutorial), _tutorial)
	 //we are force skipping responses until the next turn
	 where new_force_skip_responses = force_skip_responses and not (is_new_turn and is_your_turn)
	 where is_your_turn = (game_state.nteam = game_state.current_player_index)
	 where is_new_turn = (_state != null and _state._uuid = game_state._uuid and game_state.nturn != _state.nturn)
     where game_state = class game<- message.state
)
     where state_id = int<- message.state_id
     where message = map<- arg.message",

on_game_updated: "[
  		trigger_garbage_collection(),
	 	adapt_input_state(),


		[
			create_avatars(),

//			debug('game updated'),
//			set(_deck_obj, deck_obj),
			set(_hand_obj, hand_obj),
			set(_level_obj, level_obj),
//			map(display_icons, if(value, set(value.player_index, index))),
//			map(deck_obj, set(value.player_index, index)),
			map(hand_obj, set(value.player_index, index)),
			map(level_obj, set(value.player_index, index)),
			map(hand_obj, set(value.animation, 'hand')),
			map(level_obj, set(value.animation, 'hand')),
//			map(deck_obj, set(value.scale, 1.0)),
//			map(display_icons, if(value, set(value.scale, 1.0))),
			map(hand_obj, set(value.scale, 0.5)),
			map(level_obj, set(value.scale, 0.5)),
//			map(deck_obj, add_object(value)),
			map(hand_obj, add_object(value)),
			map(level_obj, add_object(value)),
		] where deck_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', 84, if(index = game_state.nplayer, top_player_area + 130, -48), 1, {controller: me} ))

		     where positions = [
			   int(left_edge_display_areas - display_area_width*0.5),
			   int(right_edge_display_areas + display_area_width*0.5),
			 ]
		  where hand_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 250, level_width - 250), 450, 1, {controller: me} ))
		  where level_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 250, 1, {controller: me} )),

	 	reserve_animation_time('game_update', 10),
		map(animation_hints, handle_animation_hint(value)),
		set(_animation_hints_id, game_state.animation_hints_id),
		set(_furthest_animation_hint, size(game_state.animation_hints)),
		debug('SET NEW STATE'),


		display_game_status(game_state),
		display_player_mana(game_state),
		display_choice(game_state),
	    [

		//cards to discard.
		[
		   //animate to the discard pile and then disappear.
		   animate(card, {
			mid_x: px(60),
			mid_y: level_height - py(200),
			scale: 0.5,
			rotate: 0,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   })

		| card <- level.chars,
		  card is obj card, card.in_hand,
		  find(state.players[card.player_index asserting card.player_index != null].hand, value = card.card_type) = null
		],
		
		[card.destroy() | card <- level.chars,
		 card is obj card,
		 card.in_hand = false and card.in_opponent_hand = false and
		 card.card_type.orphaned_by_update
		],

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(game_state),
		spawn_trophies(game_state),
	  ],

	  set_widgets_for_message(game_state),
	  set_schedule_for_message(game_state),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(game_state.creatures,
		                     value.summon_id = creature.summon_id) or
							 game_state.graveyard[creature.summon_id] or
							 game_state.exiled_creatures[creature.summon_id]
	    where creature = obj.creature_object
		| obj <- level.chars, obj is obj creature],
		value), 30, 0)), 

	  map(filter(level.chars, value is obj creature and
	          find(game_state.permanents,
			       context.value.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = game_state.graveyard[value.creature_object.summon_id] or
		                      game_state.exiled_creatures[value.creature_object.summon_id]), 
	  [fire_event(card, 'game_updated') | card <- level.chars, card is obj card],
	  [
	    spawn_opponent_cards(),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		update_schedule_objects(),
		if(drawn_cards > 0, reserve_animation_time('draw_cards', 30 + 10*size(game_state.players[game_state.nplayer].hand)))
	  ]
		  where drawn_cards =
		    fold([hint.ncards | hint <- animation_hints,
		                        hint is class animation.draw_cards_hint,
							    hint.player = game_state.nplayer], a+b, 0),
	  

	  map(game_state.permanents,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     [set(obj.game_state, state),
			  set(obj.creature_object, value),
			 if(card_rules, set(value.rules, card_rules))],
	      
		  //create a new object to represent this creature.
		  [//debug('SPAWN CREATURE: ' + value.name),
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: value,
				  game_state: state,
				  controller: me,
				  hex_height: tile_width,
				},
				[
				  if(card_rules, set(value.rules, card_rules))
				] asserting value)])
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value is obj creature and
		                                value.creature_object.summon_id = context.value.summon_id) where card_rules = if(doc and doc.rules, string<- doc.rules, '')
										where doc = map|null<- lib.json.get_document_map('data/cards.cfg')[lib.citadel.actual_card_name(value.name)]),
	
	  spawn_game_icons(state),

										
	  if(game_state.winner, 
			  
	   [
	   if(observer = false and _sent_game_result = false,
		[
		debug(['XXX: SEND', campaign_location, campaign_scenario]),
		set(_sent_game_result, true),
		if(game_state.winner_index = game_state.nplayer and (victory_unlock is string), add(_mm_client_state.account_info.unlocks, [victory_unlock])),
	   	if(mm_client, tbs_send(mm_client, {
			type: 'finish_bot_game',
			user: myplayer.name,
			campaign_location: campaign_location,
			campaign_scenario: campaign_scenario,
			campaign_sets: campaign_sets,
			unlock: if(game_state.winner_index = game_state.nplayer, victory_unlock, null),
			victory: game_state.winner_index = game_state.nplayer,
		   })),
		]),

		map(range(150),
		schedule(value,
		spawn('label', level_width/2, level_height/2, {
			zorder: 20000,
			_text: if(game_state.winner = game_state.players[game_state.team_index(game_state.nplayer)], ['Victory!'], ['Defeat!']),
			_font_size: 86+value,
			alpha: if(value < 125, 255, 255 - (value - 125)*10),
		}, [
			schedule(2, remove_object(child))
		]))
		),

		schedule(300, spawn('victory_dialog', 0, 0, {
			_controller: me,
		})),

	  ]),

	  update_log(game_state),
	  
	  display_free_ability(game_state),


	bind_command(spawn_tip_object, game_state),

    fire_event('update_discard_and_deck'),
	fire_event('update_storyline'),

]
  where animation_hints =
   if(_animation_hints_id != game_state.animation_hints_id,
	  game_state.animation_hints,
	  game_state.animation_hints[_furthest_animation_hint:])
  where game_state = state
",

on_message_received: "[
  if(_disconnection_dialog and _disconnection_dialog.disconnected_server, [
	set(_disconnection_dialog, null),
	remove_object(_disconnection_dialog),
  ]),

  switch(message.type,
		 'bye', return_callback(game_result),

		 'pong_game', pong_game(),

		 'message', [
		 	spawn_chat_widgets({nick: 'server', text: string<- message.message})
		 ], //has message.message with the server message.

		 'confirm_sync',

		  [
		  set(me._remote_state_id_timestamp, cycle),
		  set(me._remote_state_id, int<- message.state_id),
		  ],

		 'player_disconnect',
		 [
			set(_disconnected_players[message.player], level.cycle),
			if(_disconnection_dialog = null,
			   spawn('disconnection_dialog', 0, 0, {
				_controller: me,
			   }, [
			   	set(_disconnection_dialog, child),
			   ])
			)
		 ],

		 'player_reconnect',
		 [
			set(_disconnected_players, remove_from_map(_disconnected_players, message.player)),
			if(size(_disconnected_players) = 1 and message.player in _disconnected_players,
			   [set(_disconnection_dialog, null), remove_object(_disconnection_dialog)])
		 ],

		 'chat_message',
		 if(message.sub_type = 'presence',
		   if(_state != null and message.nick = enemy_player.name and message.info is map,
			_received_presence_state(map<- message.info)
		   ),

		   message.sub_type = 'text',
		   spawn_chat_widgets({nick: string<- message.nick, text: string<- message.text}),
		   [], //has {text: string, nick: string}
		   ),
		 
		 'game_created',
         [set(me._client, cl), debug('DDD: game created')]
		    where cl = create_tbs_client(),

         'game',
		 if(game_state = null,
		 [
		 	debug('ERROR: Could not read game state; bad delta'),
			set(_allow_deltas, false),
		 ],
		    game_state.players[game_state.nplayer].deck_submitted = false,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
			if(selected_deck and user_decks and (_submit_deck_time = null or level.cycle > _submit_deck_time+50), [
				map(user_decks[selected_deck].cards, null asserting lib.json.get_document_map('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
				tbs_send(me.client, {type: 'submit_deck', deck: deck}) asserting deck,
				set(_submit_deck_time, level.cycle),
				] where deck = user_decks[selected_deck].cards,
				null asserting selected_deck | 'must specify a deck')
		  ]
		    where user_decks = account_info.decks,
	
	    [
		debug(['YYY GOT game message state id = ', message.state_id, _sent_move_message]),
		if(message.server_time is int and _sent_move_message != null, create_server_response_label(int<- message.state_id, int<- message.server_time)),
		set(me._state_id_timestamp, cycle),
	    set(me._state_id, max(_state_id, int<- message.state_id)),
		set(me._allow_deltas, true),
		fire_event('update_game', {message: message + {state: game_state}})
		]
	   ) where game_state = null|class game<-
	   if(message.delta,
		  get_game_state_from_delta(int<- message.delta_basis, message.delta),
		  message.state), // end 'game' case.

         //default case.
//         [debug('got message: ', message)]) asserting message.type != 'invalid_session',
         [null]) asserting message.type != 'invalid_session',
		 fire_event('request_updates')]
	 where message = map<- arg.message",

on_request_updates: "if(client.in_flight = 0,
					      [tbs_send(client, { type: 'request_updates', state_id: _state_id, allow_deltas: _allow_deltas })])",
on_connection_error: "[
	debug('message error', string<- arg.error), fire_event('request_updates'),
	if(_disconnection_dialog = null,
	   spawn('disconnection_dialog', 0, 0, {
		_controller: me,
		disconnected_server: true,
	   }, [
	   	set(_disconnection_dialog, child),
	   ]),

	   set(_disconnection_dialog.disconnected_server, true)
	)
]",

on_mouse_wheel: "
	if(card_mouseover != null and card_mouseover.in_hand and yscroll > 0,
		spawn('inspect_card_dialog', 0, 0, { _mm: me, _controller: me, _card: card_mouseover }),
	)
	where yscroll = int<- arg.yscroll
",

on_draw: "
	_tutorial.draw(me)
",

on_process: "
if(in_background,
 [
  process_connection(),
 ],
 [
  
  //remove the opponent's preview card if the card it's based on is no longer around.
  if(_opponent_card_mouseover, if(find(level.chars, value = _opponent_card_mouseover) = null, [
	set(_opponent_card_mouseover, null),
	set(_opponent_preview_card, null),
  ])),

  process_disconnected_label(),

  create_animation_status_label(_animation_end_time - cycle),
  
  refresh_state_id_sync_label(),

  if(_prev_mouse_pos != [mouse_x,mouse_y], [
     set(_last_mouse_move, cycle),
	 map(_tooltip, remove_object(value)),
	 set(_tooltip, []),
  ]),

  set(_prev_mouse_pos, [mouse_x,mouse_y]),

  if(cycle - _last_mouse_move = 20 and _tooltip = [], [
	show_tooltip(),
  ]),

  process_hex_intensity(),

  if(cycle%10 = 0, _process_presence_state()),

  if(_end_turn_pending, end_turn()),

  [

  if(card_mouseover and card_mouseover.in_hand and card_mouseover.hand_index != card_over,
     mouse_leave_card(card_mouseover)),
  if(card_over != -1 and (card_mouseover = null or card_mouseover.hand_index != card_over),
	 if(card_obj, mouse_enter_card(card_obj))
		where card_obj = find(level.chars, value is obj card and value.in_hand and value.player_index = state.nplayer and value.hand_index = card_over)
  )
  ] where card_over = _hand_card_moused_over,

  set(me._prev_ctrl_keys, level.player.ctrl_keys),

  //enter pressed
  if(13 in level.player.ctrl_keys and 13 not in me._prev_ctrl_keys and
     (_chat_area = null or _chat_area.has_focus = false or find(level.chars, value = _chat_area) = null),
     spawn_chat_widgets()
  ),

  //escape pressed
  if(27 in level.player.ctrl_keys and 27 not in me._prev_ctrl_keys and
     _chat_area != null and _chat_area.has_focus,
	 [
	 set(_chat_area.has_focus, false)
	 ]
  ),

  if(_chat_area != null and _chat_area.has_focus, set(_last_chat_area_interact, cycle)),

  if(_chat_area != null and cycle - _last_chat_area_interact > 2500 and find(level.chars, value = _chat_area) != null, [
	remove_object(_chat_area),
	set(_chat_area.has_focus, false),
  ]),

  if(_response_pause_counter > 0, [
	  add(_response_pause_counter, -1),
	  if(' ' in level.player_info.ctrl_keys, [
		set(_response_pause_counter, -1),
	  ])
  ]),
  if(_response_pause_counter = 0, [
	set(_response_pause_counter, -1),
	send_move_message({
	 type: 'moves',
	 state_id: _state_id,
	 moves: [end_turn_message]
	}),
  ]),
  if(_animated_spell_card,
	 if(_spell_animation_time >= 100, [
			 debug('REMOVE SPELL: ' + if(_animated_spell_card in level.chars, true, false)),
		add(_spells_on_stack, [_animated_spell_card]),
		set(_animated_spell_card, null),
		set(_spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(_spell_animation_time = 80 and (level.player_info.ctrl_mod_key in [1,2]),
	     reserve_animation_time('spell_anim', 20),
	 [
	    add(_spell_animation_time, 1),
		if(_spell_animation_time <= 20, [
			set(_animated_spell_card.alpha, new_alpha),
			map(_animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = min(255, if(_spell_animation_time <= 20, _spell_animation_time*22, (100 - _spell_animation_time)*22))
			),
	 ]))), //end animated_spell_card

  if(_game_state_queue != [] and cycle >= _animation_end_time,
	[
	  set(_game_state_queue, _game_state_queue[1:]),
	  fire_event('update_game', {message: _game_state_queue[0], force_process: true})
	]),
	process_connection(),
 ])",

on_end_anim: "animation('normal')",
timer_frequency: 10,
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [

	{
		id: "schedule_canvas",
		animation: [
			{
				id: "day",
				image: "schedule/schedule-afternoon.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "none",
				image: "schedule/schedule-afternoon.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "dawn",
				image: "schedule/schedule-dawn.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "night",
				image: "schedule/schedule-secondwatch.png",
				rect: [0,0,123,38],
				scale: 1,
			},
			{
				id: "dusk",
				image: "schedule/schedule-dusk.png",
				rect: [0,0,123,38],
				scale: 1,
			},
		],
	},

	{
		id: "furnace",
		animation: [{
			id: "normal",
			image: "furnace_ico.png",
			rect: [0,0,88,126],
			scale: 1,
		}],

		properties: {
			controller: { type: "obj citadel_controller" },
			player_index: { default: 0 },
			set_label: "def(string text, string font) ->commands []",
		},
	},

	{
		id: "card_back",
		animation: [
			{
				id: "normal",
				image: "card-back.png",
				rect: [0,0,147,261],
				scale: 1,
			},

			{
				id: "front",
				image: "card-citadel.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "hand",
				image: "card-hand.png",
				rect: [0,0,145,203],
				scale: 1,
			},
		],

		properties: {

			set_label: "def(string text, string font) ->commands execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'black',
				x: 74,
				y: 80,
			}]))",

			set_text: "def([string] text_list, string font) ->commands execute(me, set_widgets(
			  map(text_list, {
			  	type: 'label',
				text: value,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'white',
				x: 74,
				y: 40 + index*26
			  })))",

			set_widgets: "def([map] widgets) ->commands execute(me, set_widgets(widgets))",

			player_index: { default: 0 },
			controller: { type: "obj citadel_controller" },
		},

		on_mouse_enter: "if(controller, controller.mouse_enter_discard(player_index))",
		on_mouse_leave: "if(controller, controller.mouse_leave_discard(player_index))",
		on_click: "if(controller, controller.mouse_click_discard(player_index))",
	},

	{
		id: "status_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			init_label: "def(string text, Color color, int card_top) ->commands
			execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: lib.font.regular_font,
				color: color,
				size: 18,
				x: 100,
				y: card_top - 20,
			}]))",

			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		},
	},

],
}
