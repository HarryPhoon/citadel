{
	"id": "card",

	is_strict: true,
	always_active: true,

	on_mouse_enter: "[
	  if(mouse_enter_handler, mouse_enter_handler()),
	  if(in_opponent_hand and controller is obj citadel_controller, controller.mouse_enter_opponent_card(me)),
	  set(mouse_over, true),
	  if(in_ability, animate(me, { card_size: 1.6 }, { duration: 15 })),
	  if(in_victory and find(animated_movements, value = 'victory_card_move') = null, [
		animate(me, {
			mid_x: mid_x,
			mid_y: (mid_y + screen_height/2)/2,
			card_size: card_size*2,
			zorder: zorder+10,
		}, {
			duration: 10,
			name: 'card_move',
			replace_existing: true,
		}),

		set(_starting_state, {mid_x: mid_x, mid_y: mid_y, card_size: card_size, zorder: zorder})
		]),
	  if(is_choice and animated_movements = [], [
		show_halo(),
		]),
	]",

	on_mouse_leave: "[
	  if(mouse_leave_handler, mouse_leave_handler()),

	  if(in_opponent_hand and controller is obj citadel_controller, controller.mouse_leave_opponent_card(me)),
	  set(mouse_over, false),
	  if(in_ability, animate(me, { card_size: 1.0 }, { duration: 15 })),
	  if(in_victory and _starting_state != null, [
		animate(me, {
			mid_x: _starting_state.mid_x,
			mid_y: _starting_state.mid_y,
			card_size: _starting_state.card_size,
			zorder: _starting_state.zorder,
		}, {
			duration: 10,
			name: 'victory_card_move',
			replace_existing: true,
		}),

		set(_starting_state, null)
	]),
	  if(is_choice, [
	    hide_halo(),
	  ]),
	]",

	on_drag_start: "[
		swallow_mouse_event(),
		if(allow_drag, [
			set(drag_pos, [mouse_x, mouse_y]),
			if('card_move' in animated_movements, animate(me, { mid_y_decimal: mid_y }, { duration: 0, name: 'card_move', replace_existing: true})),
		]),
		controller.mouse_drag_card_start(me),
	]
	 where mouse_x = int<- arg.mouse_x
	 where mouse_y = int<- arg.mouse_y",

	on_drag: "[
	  swallow_mouse_event(),
	  if(drag_pos and allow_drag, [
		set(drag_pos, [mouse_x, mouse_y]),
		add(x, dx),
		add(y, dy),
		map(arrows, [set(value.start_point, [value.start_point[0] + dx, value.start_point[1] + dy]), fire_event(value, 'create')]),

	] where dx = mouse_x - drag_pos[0]
	  where dy = mouse_y - drag_pos[1]),
	  controller.mouse_drag_card(me)
	]
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",

	on_drag_end: "[
	  set(drag_pos, null),
	  controller.mouse_drag_card_end(me),
	]",

	on_click: "[

	if(ignore_clicks, null,
	click_handler != null, [
		swallow_mouse_event(),
		click_handler(),
	],
	hand_card_off_to_side, if(controller is obj citadel_controller, controller.tile_clicked(null)),
	controller.paused = false or is_choice, [
		swallow_mouse_event(),
		if(is_choice and (choice_index is int),
		[
		   hide_halo(),
	       controller.option_clicked(choice_index, choice_value),
		],
	
	       switch(mouse_button, 
				1, controller.card_clicked(me),
				3, controller.card_right_clicked(me),
			null))
	])
			] where mouse_button = int<- arg.mouse_button",

	on_type_updated: "fire_event('render')",

	on_process: "[
	  fire_event('check_needs_render'),
	  set(brightness, if(highlight and level.cycle%50 < 25, 512, 255)),

	 ]",
	
	on_check_needs_render: "
		if(_loading_cycles is int and cycle >= _loading_cycles,
		   [
		   	set(_loading_cycles, null),
			fire_event('render'),
		   ],
		   card_needs_rerender, fire_event('render'))",

	properties: {

		screen_width: "int :: level.dimensions[2] - level.dimensions[0]",
		screen_height: "int :: level.dimensions[3] - level.dimensions[1]",

		_x_fractional: { type: "decimal", default: 0.0 },
		_y_fractional: { type: "decimal", default: 0.0 },

		x_fractional_shader: "decimal :: _x_fractional",
		y_fractional_shader: "decimal :: _y_fractional",

		mid_x_decimal: { variable: false, type: "decimal", get: "mid_x + _x_fractional", set: "[set(mid_x, floor(value)), set(_x_fractional, value - floor(value))]" },
		mid_y_decimal: { variable: false, type: "decimal", get: "mid_y + _y_fractional", set: "[set(mid_y, floor(value)), set(_y_fractional, value - floor(value))]" },

		ignore_clicks: { default: false },

		arrows: { type: "[obj arrow]", default: [], set: "
		if(value != _data, [
			map(_data, remove_object(value)),
			map(value, add_object(value)),
			set(_data, value),
		])" },


		effect_alpha: { type: "decimal", default: 1.0 },

		image_grayscale: { type: "decimal", default: 0.0, set: "[set(_data, value), set(shader.uniform_commands.u_img_grayscale, value)] asserting shader" },

		flip_card: {
			type: "decimal",
			default: 0.0,
			set: "[
				set(_data, value),
				if(val = 0.0, [
					set(uv_array, null),
					set(xy_array, null),
				], [
					set(uv_array, [0,0,1,0,1,1,0,1,0,0]),
					set(xy_array, [val,ypos, inv_value,-ypos, inv_value,1-ypos, val,1+ypos, val,ypos]),
				]),
			] where inv_value = 1.0 - val
			  where val = if(value < 0.5, value, 1.0 - value)
			  where ypos = sin(value*180.0)*0.1*if(value < 0.5, 1.0, -1.0)
			  ",
		},

		mouse_over: { default: false },
		click_handler: { type: "null|function()->commands" },

		mouse_enter_handler: { type: "null|function()->commands" },
		mouse_leave_handler: { type: "null|function()->commands" },

		_card_tips: { type: "[obj tip_dialog]", default: [] },

		_starting_state: { type: "null|{mid_x: int, mid_y: int, card_size: decimal, zorder: int}" },


		_rules_text_width: "0.94",

		calculate_font_size: "def(int cur_size=16) ->int cur_size",

		show_card_tips: "def() ->commands execute(me, [
			clear_card_tips(),

			map([{title: string, text: string }] :: card_type.rules_tips[:size(positions)],
				spawn('tip_dialog', positions[index][0], positions[index][1], {
					zorder: zorder+1,
					_tip: {
						key: 'tip',
						text: info.text,
						targets: [me],
					},
					_title: info.title,
					_has_close: false,
					_width: lib.citadel.py(220),
					_height: lib.citadel.py(120),
				}, [
					add(me._card_tips, [child]),
				])
				where info = {title: string, text: string} <- value
			)
		])
		where positions = filter(all_positions, find(exclusion_zones, xpos > value[0] and xpos < value[2] and ypos > value[1] and ypos < value[3]) = null where xpos = value[0] where ypos = value[1])
		where all_positions = [
			[x2 + lib.citadel.py(180), y + lib.citadel.py(60)],
			[x2 + lib.citadel.py(180), mid_y],
			[x2 + lib.citadel.py(180), y2 - lib.citadel.py(60)],
			[x - lib.citadel.py(180), y + lib.citadel.py(60)],
			[x - lib.citadel.py(180), mid_y],
			[x - lib.citadel.py(180), y2 - lib.citadel.py(60)],
		]
		   where exclusion_zones = map(existing_tips, [value.x-lib.citadel.py(110), value.y-lib.citadel.py(60), value.x2+lib.citadel.py(110), value.y2+lib.citadel.py(60)])
		   where existing_tips = filter(level.chars, value is obj tip_dialog)",

		clear_card_tips: "def() ->commands [
			map(_card_tips, remove_object(value)),
			set(me._card_tips, []),
		]",

		is_burning: { type: "bool", default: false, set: "if(_data != value, [set(me._data, value), fire_event('check_needs_render')])" },

		highlight: { default: false },

		play_sound: "def(string|null fname) ->commands
			if(fname != null, sound(fname, lib.citadel.sound_volume(fname)))",

		//State to let us know if anything about the way the card would be
		//drawn has changed and the card needs re-rendering.
		_calculate_render_key: "{search: null|[string], resources: [int,int,int], card_size: decimal, is_burning: bool} :: {search: search_string, resources: [_actual_cost,_loyalty_cost,_base_cost], card_size: card_size, is_burning: is_burning}",
		_last_render_key: { type: "{search: null|[string], resources: [int,int,int], card_size: decimal, is_burning: bool}|null" },
		card_needs_rerender: "_calculate_render_key != _last_render_key",

		show_back: { type: "bool", default: false },

		search_string: { type: "null|[string]" },
		highlight_search_terms: "def(string type, string text) ->string
			if(search_string = null, text,
				_highlight_search_terms_internal(text, search_string)
			)
		",

		_highlight_search_terms_internal: "def(string text, [string] terms) ->string
			if(terms = [], text,
				_highlight_search_terms_internal(regex_replace(text, '(^|>)([^<>]*)(' + terms[0] + ')([^<>]*)(<|$)', q($1$2<font tag='highlight'>$3</font>$4$5), ['icase']), terms[1:])
			)
		",

		set_show_back: "def(bool new_value) ->commands if(new_value != show_back, [
			set(_last_render_key, null),
			set(show_back, new_value),
			if(new_value, [
				fire_event('render'),
			]),
		])",

		flip_card_over: "def(bool new_value, int duration=20, decimal|null new_card_size=null) ->commands
		execute(me,
		if(new_value != show_back, [
			set(rotate, 0),
			schedule(duration/2, set_show_back(new_value)),
			set(flip_card, 1.0),

			animate(me, {
				flip_card: 0.0,
			}, {
				duration: duration,
				name: 'flip_card',
			}),
		])
		)",

		morph_into_creature: "def(obj creature creature, int ncycles) ->commands execute(me, [
			debug(['MORPH', hud_alpha, translate_img, scale_img]),
			animate(me, {
				hud_alpha: 0.0,
				translate_img: [creature.calculate_image_translate_x, creature.calculate_image_translate_y],
				scale_img: creature.calculate_image_scale,
				card_size: if(controller is obj citadel_controller, card_size*decimal(controller.tile_width)/decimal(x2 - x), card_size),
			}, {
				duration: ncycles,
			})
		])",

		tooltips: { type: "[class tooltip_area]", default: [] },

		noise_texture: { type: "null|object" },

		stack_id: { type: "null|int" },
		stack_info: { type: "null|class message.play_card_base" },

		being_dragged: "bool :: drag_pos != null",
		drag_pos: { type: "null|Loc" },
		choice_index: { type: "null|int" },
		choice_value: { type: "null|int" },
		is_choice: { default: false },
		allow_drag: { default: false },

		tag: { type: "null|string" },
		in_victory: { default: false },
		in_hand: { default: false },
		hand_card_off_to_side: { default: false },
		parent_creature: { type: "null|class creature" },
		in_ability: { default: false },
		mandatory_play: { default: false },
		player_index: { default: null, type: "int|null" },
		in_graveyard: { default: false },
		in_opponent_hand: { default: false },
		hand_index: { type: "null|int" },

		controller: { type: "obj citadel_controller_base" },

		player: { type: "null|class player" },

		clear_widget_tooltips: "def() -> commands set(tooltips, [])",

		add_widget_tooltip: "def(widget w, int x, int y) -> commands [
			if(w.tooltip != null, add(tooltips, [construct('tooltip_area', { area: map([(int<- x) + (int<- (widget<- w).x), y + w.y, w.w, w.h], int(value*size_ratio)), tooltip: w.tooltip})])),
			map(w.children, add_widget_tooltip(value, x + w.x, y + w.y)),
		] where size_ratio = card_size/2.0",

		create_tooltip_widget: "def(class tooltip_area tip) ->object
		widget(me, {
			type: 'dialog',
			id: 'ability_tooltip',
			alpha: 175,
			clear_backround_alpha: 120,
			padding: 0,
			frame_padding: [10,10],
			zorder: 2000,
			cursor:[10, 10],
			x: tip.area[0],
			y: tip.area[1] - 40,
			background_frame: 'empty_window',
			children: [
				{
					type: 'label',
					font: lib.font.regular_font,
					alpha: 255,
					size: 16,
					color: 'light_gray',
					text: tip.tooltip,
				}
			],
		})",

		start_fizzle_animation: "def() ->commands
		execute(me,
		[
			play_sound(card_type.sound_fizzle),
			set(shader.uniform_commands.fizzle_cycle, {value: 1, increment: true}) asserting shader,
			map(arrows, animate(value, {
				arrow_alpha: 0,
			}, {
				duration: 20
			})),

			animate(me, {
				effect_alpha: 0.0,
			}, {
				duration: 30,
			}),

			schedule(50, remove_object(me)),
		])",

		show_shadow: { type: "bool", default: true },

		start_resolve_animation: "def([custom_obj] targets) ->commands
		if(card_type.resolve_effect = 'fire',
		   start_fire_resolve(targets),

		   card_type.creature_object != null and size(targets) = 1,
		   execute(me, [
		   		animate(me, {
					mid_x: targets[0].mid_x,
					alpha: 0,
				}, {
					easing: lib.math.linear,
					duration: lib.animation_timings.card_cast_movement_time,
					on_complete: remove_object(me),
				}),

				animate(me, {
					mid_y: targets[0].mid_y,
				}, {
					easing: lib.math.ease_in_cubic,
					duration: lib.animation_timings.card_cast_movement_time,
				}),

				map(arrows, animate(value, {
					fade_out: 1.0,
				}, {
					duration: lib.animation_timings.card_cast_movement_time,
				})),
		   ]),

		   card_type.resolve_effect = 'popup',

		   execute(me,
			[
				controller.reserve_animation_time('resolve', 10 + card_type.resolve_delay + card_type.resolve_animation_delay),
				if(card_type.resolve_launch, schedule(0, ; spawn(card_type.resolve_launch, me.mid_x, me.mid_y, { zorder: 10000 })))
			];

			schedule(card_type.resolve_delay, ; [
		  		animate(me, {
					hud_alpha: 0.0,
					alpha: 0,
					effect_alpha: 0,
				}, {
					duration: 10,
					on_complete: remove_object(me),
				}),

				map(arrows, animate(value, {
					//fade_out: 1.0,
					arrow_alpha: 0,
				}, {
					duration: 5
				})),

				if(card_type.resolve_impact, schedule(10, spawn(card_type.resolve_impact, targets[0].mid_x, targets[0].mid_y, { zorder: 1000, targets: targets }))),
			])

		   ),

		   card_type.resolve_effect = 'impact' or card_type.resolve_effect = 'impact_no_shake',

		   execute(me,

			[
				controller.reserve_animation_time('resolve', 30 + card_type.resolve_delay),
				if(card_type.resolve_launch, schedule(0, ; spawn(card_type.resolve_launch, me.mid_x, me.mid_y, { zorder: 10000 })))
			];

		   
		   schedule(card_type.resolve_delay, ; [
		  		animate(me, {
					hud_alpha: 0.0,
					alpha: 0,
					effect_alpha: 0,
				}, {
					duration: 10,
				}),


				if(card_type.resolve_projectile, ; spawn(card_type.resolve_projectile, me.mid_x, me.mid_y, { zorder: 10000, _card: me })),

				if(card_type.resolve_num_particles,
					map(range(card_type.resolve_num_particles),
						schedule(floor(t), ; spawn(card_type.resolve_particle, me.mid_x, me.mid_y, {}))
						where t = 30.0*decimal(value)/decimal(card_type.resolve_num_particles)
					)
				),

		   		animate(me, {
					mid_x: targets[0].mid_x,
					card_size: 0.65,
				}, {
					easing: lib.math.linear,
					duration: 30,
					on_complete: remove_object(me),
				}),

				animate(me, {
					mid_y: targets[0].mid_y,
				}, {
					easing: lib.math.ease_in_cubic,
					duration: 30,
				}),

				map(arrows, animate(value, {
					//fade_out: 1.0,
					arrow_alpha: 0,
				}, {
					duration: 5
				})),

				if(card_type.resolve_effect = 'impact', schedule(30, if(controller is obj citadel_controller, controller.screen_shake(20, 30, 5)))),

				schedule(30, remove_object(me)),

				if(card_type.resolve_impact, schedule(card_type.resolve_impact_delay, spawn(card_type.resolve_impact, targets[0].mid_x, targets[0].mid_y, { zorder: 1000, targets: targets }))),
		   ])),
		
			execute(me, [
		   		map(arrows, animate(value, {
					arrow_alpha: 0,
				}, {
					duration: 30
				})),
				play_sound(card_type.sound_resolve),
				spawn('entropia_launch', {
					zorder: me.zorder+10,
					mid_x: me.mid_x,
					mid_y: me.mid_y,
					scale: lib.citadel.dpy(0.8),
				}),
				/*
				schedule(5, [set(shader.uniform_commands.resolve_cycle, {value: 1, increment: true}), set(me.effects[1].enabled, false)]),
				schedule(5, [set(effects[0].uniform_commands.resolve_cycle, {value: 1, increment: true})]),
				set(me.effects[1].enabled, true),
				*/
				schedule(20, remove_object(me)),
				controller.reserve_animation_time('resolve', 50),
			]) asserting shader
		)",

		start_fire_resolve: "def([custom_obj] targets) ->commands execute(me, [
			controller.reserve_card_resolve_time(170),
			controller.reserve_animation_time('card_fire_resolve', 50),
			//removed for now, investigate crashes and wait for
			//new merge of graphics branch from Krista.
			//spawn('card_particle_effect', 0, 0, { _card: me, zorder: zorder+10 }),
			map(range(101), schedule(value, [set(height_reduction_proportion, 1.0 - value/100.0), fire_event('render'), set(y, y)])),

//			map(targets,
//				spawn('fireball_effect', mid_x, mid_y, { zorder: zorder+10, _target: value })
//				),
		])",

		show_halo: "def() ->commands if(not halo_shown, [
			set(me.effects[1].enabled, true),
			set(shader_enabled_at, cycle),
			set(me.halo_shown, true),
		])",
		hide_halo: "def() ->commands if(halo_shown, [
			set(me.effects[1].enabled, is_castable),
			set(me.halo_shown, false),
		])",

		halo_shown: { default: false, type: "bool" },

		shader_enabled_at: { default: -1 },

		translate_img: {
			type: "[decimal,decimal]",
			default: [0.0,0.0],
			set: "[
				set(_data, value),
				set((anura_shader<- shader).uniform_commands.u_translate_img, value),
			]",
		},

		scale_img: {
			type: "decimal",
			default: 1.0,
			set: "[
				set(_data, value),
				set((anura_shader<- shader).uniform_commands.u_scale_img, value),
			]",
		},

		hud_alpha: {
			type: "decimal",
			default: 1.0,
			set: "[
				set(_data, value),
				set((anura_shader<- shader).uniform_commands.u_hud_alpha, value),
			]",
		},

		img_zoom: {
			type: "decimal",
			default: 0.0,
			set: "[
				set(_data, value),
				set((anura_shader<- shader).uniform_commands.u_img_zoom, value),
			]",
		},

		img_target: {
			type: "[decimal,decimal]|null",
			set: "[
				set(_data, value),
				set((anura_shader<- shader).uniform_commands.u_img_zoom, value),
			]",
		},

		is_castable: {
			type: "bool",
			default: false,
			set: "[
				set(_data, value),
				set(me.effects[1].enabled, value or halo_shown),
			]",
		},

		keep: { default: false },

		render_scale: { type: "int", default: 2, variable: true },
		card_size: { type: "decimal", default: 2.0, variable: true },


		destroy: "def() ->commands [remove_object(me)]",

		animate_from: "def(obj card start, int ncycles) ->commands [
			set(mid_x, start.mid_x),
			set(mid_y, start.mid_y),
			set(rotate, start.rotate),
			animate(me, {mid_x: mid_x, mid_y: mid_y, rotate: me.rotate}, {duration: ncycles}),
			
		]",

		//card_type property which can be a card OR an activated_ability.
		card_type: {
		  type: "class card_base",
		  get: "_data", set: "execute(me, [

				set(_data, value), 
				fire_event('init')
			  ]) asserting value != null"
		},

		_actual_cost: "int ::
		  if(player != null,
			 player.calculate_cost(card_type),
			 card_type.cost + card_type.loyalty_cost)",
		
		_loyalty_cost: "int ::
			if(player != null,
			   player.calculate_card_loyalty_cost(card_type),
			   card_type.loyalty_cost)
		",

		_base_cost: "int ::
			if(player != null,
			   player.calculate_card_base_cost(card_type),
			   card_type.cost)
		",
		
		render_size: "def(decimal size) ->[int,int] [round_to_even(lib.hex.width_from_height(height)), round_to_even(height)]
		 where height = size*154*(screen_height/900.0)",

		_native_render_sizes: "[[int,int]] :: map(lib.citadel.native_card_sizes, render_size(value))",

		texture_width: { default: 128 },
		texture_height: { default: 128 },

		image_texture_width: { default: 128 },
		image_texture_height: { default: 128 },

		_has_dynamic_image: "bool :: true or (card_type.animation_sequence != [])",

		animated_card_info: { type: "null|class animated_card" },
		image_texture: { type: "null|texture_object" },

		height_reduction_proportion: { type: "decimal", default: 1.0 },

		//number of cycles to show a 'loading' version of the card
		//to avoid doing renders of all cards at once.
		_loading_cycles: { type: "int|null" },

		render_card: "def(int requested_width, int requested_height) ->frame

		query_cache(global_cache(128), [actual_size, if(draw_back, draw_back, [card_type.internal_id, _actual_cost, _base_cost, _loyalty_cost]), search_string],

		create_animation(
		{
			id: 'fbo',
			image: 'fbo',			
			force_no_alpha: true,
			fbo: if(draw_back, _render_back(c, w, h), _render_internal(c, w, h)) where c = canvas(),
			x: 0, y: 0, w: w+2, h: round_to_even((h+2)*height_reduction_proportion),
			scale: 1,
			frames: 1,
		}
		  where renderable_attr = _renderable_attributes()
		  where w = actual_size[0]
		  where h = actual_size[1]
		)
		)
		  where actual_size = get_native_size(requested_width, requested_height)
		  where draw_back = show_back or (_loading_cycles is int and _loading_cycles > cycle)
		",

		get_native_size: "def(int requested_width, int requested_height) ->[int,int]
		  find_or_die(_native_render_sizes, value[0] >= requested_width and value[1] >= requested_height or index = size(_native_render_sizes)-1)",

		render_card_to_file: "def(decimal size, string fname='card.png') ->commands
			set(x, 0); set(y, level.dimensions[3] - img_h); set(upside_down, 1);
			texture([me], [0,0,img_w,img_h]).save(fname)
		",

		_render_back: "def(cairo_callable c, int w, int h) ->texture_object
			c.render(w+2, h+2, [
			  c.translate(1, 1),
			  c.rectangle(0, 0, w, h),
			  c.clip(),
			  c.new_path(),

			  c.scale(decimal(w)/826.0),
			  c.paint_image('images/card-back.png'),

			])
		",

		_render_loading: "def(cairo_callable c, int w, int h) ->texture_object
			c.render(w+2, h+2, [
			  c.translate(1, 1),
			  c.rectangle(0, 0, w, h),
			  c.set_source_rgba(1,1,1,1),
			  c.fill(),
			])
		",

		_render_internal: "def(cairo_callable c, int w, int h, bool draw_image=false) ->texture_object
		c.render(w+2, h+2, [

			  c.translate(1, 1),

			  c.move_to(w*0.25, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.line_to(w*1.0, h*0.5),
			  c.line_to(w*0.75, h*1.0),
			  c.line_to(w*0.25, h*1.0),
			  c.line_to(w*0.0, h*0.5),
			  c.clip(),
			  c.new_path(),


			  if(card_type.portrait != null and draw_image,
			  [

				c.save(),
				//c.rectangle(w*0.3, 0, w*0.4, h),

			  	c.translate(0.15*w, 0),
				//c.clip(),
				c.scale(w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),
				c.save(),
				c.rectangle(w*0.0, 0, w*0.301, h),

				c.clip(),
				c.scale(2.0*w*0.7/800.0, w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),

				c.save(),
				c.rectangle(w*0.699, 0, w*0.301, h),

				c.clip(),
				c.translate(-w*0.4, 0),
				c.scale(2.0*w*0.7/800.0, w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),

				c.save(),
				c.rectangle(w*0, h*0.7, w, h*0.3),
				c.set_source_rgba(1, 1, 1, 0.5),
				c.fill(),

				c.restore(),
			  ]),

			  //c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
			  school_color_gradient(),

			  //top
			  c.move_to(w*0.25, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.line_to(w*0.75, h*0.03),
			  c.line_to(w*0.25, h*0.03),
			  c.fill(),

			  //bottom
			  c.move_to(w*0.25, h*1.0),
			  c.line_to(w*0.75, h*1.0),
			  c.line_to(w*0.75, h*0.97),
			  c.line_to(w*0.25, h*0.97),
			  c.fill(),

			  //bottom left
			  c.move_to(w*0.0, h*0.50),
			  c.line_to(w*0.03, h*0.50),
			  c.line_to(w*0.28, h*1.0),
			  c.line_to(w*0.25, h*1.0),
			  c.fill(),

			  //top left
			  c.move_to(w*0.0, h*0.50),
			  c.line_to(w*0.03, h*0.50),
			  c.line_to(w*0.28, h*0.0),
			  c.line_to(w*0.25, h*0.0),
			  c.fill(),

			  //bottom right
			  c.move_to(w*1.0, h*0.50),
			  c.line_to(w*0.97, h*0.50),
			  c.line_to(w*0.72, h*1.0),
			  c.line_to(w*0.75, h*1.0),
			  c.fill(),

			  //top right
			  c.move_to(w*1.0, h*0.50),
			  c.line_to(w*0.97, h*0.50),
			  c.line_to(w*0.72, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.fill(),

			  //creature type area.
			  c.move_to(w*0.108, h*0.676),
			  c.line_to(w*0.892, h*0.676),
			  c.line_to(w*0.867, h*0.727),
			  c.line_to(w*0.133, h*0.727),
			  c.fill(),

			  //Name of the card
			  [
			    c.save(),

				//The white area which contains the card name and rarity.
				c.move_to(0.910*w, 0.620*h),
				c.line_to(0.882*w, 0.676*h),
				c.line_to((0.900 - 0.12)*w - name_dim.width, 0.676*h),
				c.line_to((0.900 - 0.08)*w - name_dim.width, 0.620*h),
				c.set_source_rgba(1,1,1,1),
				c.fill(),

				c.restore(),

			  if(card_type is class card and card_type.set != null,
				[
				//Code to draw a little moon to show the rarity of the card.
				c.save(),

				c.translate(w*0.845 - name_dim.width, h*0.648),

				c.set_source_rgba(1, 1, 1, 1),
				c.arc(0, 0, w*0.018, 3.15*0.5, 3.15*1.5),

				c.scale(if(card_type.rarity = 0, -0.6, card_type.rarity = 1, -0.1, 1), 1.0),
				c.arc(0, 0, w*0.018, 3.15*1.5, 3.15*2.5),
			    c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				c.fill(),

				c.restore(),
			  ]),


				map(fragments, [
					c.save(),
			  		c.translate(w*0.87 - rightmost, h*0.618),
					if(value.tag is list and 'highlight' in value.tag,
						c.set_source_rgba(1, 0, 0, 1),
						c.set_source_rgba(0, 0, 0, 1)
					),
					value.path,
					c.fill(),
					c.restore(),
				])
				   where rightmost = max(map(fragments, value.x + value.width)) or 0.0
			       where fragments = c.markup_text(q(<font weight='55' size='18'>) + highlight_search_terms('name', card_type.name) + q(</font>), {width: w*0.84, scale: scaling}),

			  ] where name_dim = c.text_extents(lib.font.bold_font, 18*scaling, card_type.name),

			  c.save(),
			  c.translate(0.740*w, 0.410*h),
			  c.move_to(0.113*w, 0.022*h),
			  c.line_to(0.182*w, 0.022*h),
			  c.line_to(0.214*w, 0.090*h),
			  c.line_to(0.182*w, 0.158*h),
			  c.line_to(0.113*w, 0.158*h),
			  c.line_to(0.081*w, 0.090*h),
			  c.restore(),

			  c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
			  c.fill(),

			  if(_loyalty_cost > 0, [
				c.save(),
				c.translate(0.730*w, 0.28*h),
			  	c.move_to(0.101*w, 0.054*h),
			  	c.line_to(0.144*w, 0.054*h),
			  	c.line_to(0.165*w, 0.097*h),
			  	c.line_to(0.144*w, 0.141*h),
			  	c.line_to(0.101*w, 0.141*h),
			  	c.line_to(0.080*w, 0.097*h),
				c.restore(),
			  ]),

			  c.fill(),

			  //cost
			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.get(67)),

			  if(_actual_cost > _base_cost + _loyalty_cost,
			     c.set_source_rgba(1, 0.8, 0.8, 1),
				 _actual_cost < _base_cost + _loyalty_cost,
			     c.set_source_rgba(0.8, 0.8, 1.0, 1),
			     c.set_source_rgba(1, 1, 1, 1)
			  ),

			  c.set_font_size(36*scaling),
			  c.translate(if(_actual_cost >= 10, 0.846, 0.868)*w, 0.534*h),
			  c.text_path(str(_actual_cost)), 
			  c.fill(),

			  c.restore(),


			  if(_loyalty_cost,
			  [
			  	c.save(),
			  	c.set_font(lib.font.bold_font),
			  	c.set_font_size(22*scaling),
			  	c.set_source_rgba(1, 1, 1, 1),
			  	c.translate(if(_base_cost >= 10, 0.824, 0.838)*w, 0.397*h),
			  	c.text_path(str(_base_cost)), 
			  	c.fill(),
			  	c.restore(),
			  ]),

			  if(card_type.creature_object != null and card_type.creature_object.is_construct = false, [

				c.set_source_rgba(1,1,1,1),
			  	c.rectangle(0.70*w, h*0.676, w*0.055, h*0.051),
				c.fill(),

				c.set_source_rgba(0,0,0,1),
			  	c.rectangle(0.755*w, h*0.676, w*0.055, h*0.051),
				c.fill(),

				c.save(),

				c.set_source_rgba(0, 0, 0, 1),
				c.translate(w*0.68, h*0.718),
				c.set_font(lib.font.bold_font),
				c.set_font_size(18*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.attack), w*0.09, ['center']),
				c.fill(),

				c.translate(w*0.055, 0.0),
				c.set_source_rgba(1, 1, 1, 1),
				c.set_font_size(18*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.life), w*0.09, ['center']),

				c.fill(),

				c.restore(),

			  ]),

			  //artist
			 if(card_type is class card and card_type.artist != null, [
			 	c.save(),
			 	c.translate(w*0.28, h*0.992),
			 	c.set_font(lib.font.get(lib.font.normal)),
			 	c.set_font_size(9*scaling),
			 	c.set_source_rgba(1, 1, 1, 1),
			 	(c.text_path_in_bounds('Art:' + card_type.get_artist.name, w*0.94, ['left']) asserting card_type.get_artist != null | [card_type.name, card_type.artist]),
			 	c.fill(),

			 	c.restore(),
			 ]),

			  [
			    c.save(),
			    c.translate(0.18*w, 0.730*h),
				c.scale(scaling),
			  	map(fragments, [
					if(value.tag is list and 'highlight' in value.tag,
						c.set_source_rgba(1, 0, 0, 1),
						c.set_source_rgba(0, 0, 0, 1)
					),

					if(value.tag is list and 'circle' in value.tag, [
						c.save(),
						c.translate(value.y*0.55, 0.0),
						value.path,
						c.set_source_rgba(0.2, 0.2, 0.2, 1),
						c.arc(value.width*0.56,
						      -value.ascent + value.height/2,
							  value.height*0.45, 0, 3.15*2),
						c.fill(),
						c.restore(),

						c.set_source_rgba(1, 1, 1, 1),
					],
					value.tag is list and 'attack' in value.tag, [
						c.save(),
						c.translate(value.y*0.55, 0.0),
						c.rectangle(value.x, value.y, value.x_advance, value.height),
						c.set_source_rgba(1, 1, 1, 1),
						c.fill(),
						c.restore(),
					],
					value.tag is list and 'life' in value.tag, [
						c.save(),
						c.translate(value.y*0.55, 0.0),
						c.rectangle(value.x, value.y, value.x_advance, value.height),
						c.set_source_rgba(0, 0, 0, 1),
						c.fill(),
						c.restore(),

						c.set_source_rgba(1, 1, 1, 1),
					]),

					c.save(),
					c.translate(value.y*0.55, 0.0),
					value.path,
					c.fill(),
					c.restore(),

				]),
				c.restore(),
			  ]

			  where fragments = c.markup_text(q(<font size=') + rules_font_size + q('>) + highlight_search_terms('rules', card_type.rules_text) + q(</font>), _rules_text_width*300.0, -1.0),

			  //Type of the card
			  map(type_fragments, [
			  	c.save(),
			  	c.translate(w*0.16, h*0.678),
				if(value.tag is list and 'highlight' in value.tag,
					c.set_source_rgba(1, 0, 0, 1),
					c.set_source_rgba(1, 1, 1, 1)
				),
				value.path,
				c.fill(),
			  	c.restore(),
			  ])
			  where type_fragments = c.markup_text(q(<font weight='45' size=') + str(int(calculate_type_font_size()*scaling)) + q('>) + highlight_search_terms('type', _type_text) + q(</font>), w*0.94)

			  //c.clip(),

			  ], { filtering: 'bilinear', mipmaps:4, address_mode: ['clamp', 'clamp'] }

			  
		) where text_color = c.set_source_rgba(card_type.text_color[0], card_type.text_color[1], card_type.text_color[2], 1)
		  where scaling = h/373.0

		  where school_color_gradient = def(decimal begin=0.0, decimal end=1.0) ->cairo_op switch(size(school_info),
				1, c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				2, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.4, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.6, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: end, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				]),
				3, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.25, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.40, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.60, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.75, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: end, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				]),
				4, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.15, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.30, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.45, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.60, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.75, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.90, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: end, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				]),
				5, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.1, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.2, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.3, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.4, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.6, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.7, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: begin + (end-begin)*0.8, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: begin + (end-begin)*0.9, red: school_info[4].color[0], green: school_info[4].color[1], blue: school_info[4].color[2]},
				{offset: end, red: school_info[4].color[0], green: school_info[4].color[1], blue: school_info[4].color[2]},
				]),
			  )
		  where school_info = map(card_type.school_list, lib.citadel.school_info[value])
		  where rules_font_size = calculate_font_size()
		",

		_renderable_attributes: "def() -> [{icon: string, scaling: decimal, text: string, value: int|null, center_x: decimal, center_y: decimal}]
		  map([{icon: string, scaling: decimal, text: string, value: int|null}] <- attributes, value + {
			center_x: if(index < 3, 0.825, 0.64),
			center_y: 0.725 + 0.097*(index%3),
		  })
			where attributes = if(cr = null, [],
			if(cr.range >= 1,
			[{
				text: 'RANGE',
				value: cr.range,
				icon: 'range.svg',
				scaling: 1.2,
			}], []) +
			if(cr.move > 1,
			[{
				text: 'MOVE',
				value: cr.move,
				icon: 'walking-boot.svg',
				scaling: 1.2,
			}], []) +
			if(cr.resistance != 0,
			[{
				text: 'ARMOR',
				value: cr.resistance,
				icon: 'resistance.svg',
				scaling: 1.2,
			}], []) +
		
		[{
			text: ability.text,
			icon: ability.icon,
			scaling: ability.scaling,
		  }
		  asserting ability != null
		  where ability = lib.citadel.ability_info[a] |
		  a <- cr.abilities, a in lib.citadel.ability_info
		])
		where cr = card_type.creature_object
		",

		calculate_type_font_size: "def() ->int
		 find([14,12,11,10,9,8,7,6], extents.width < 192 where extents = c.text_extents(lib.font.regular_font, value, text)) or 5
		  where c = canvas()
		  where text = _type_text
		",

		_type_text: "string :: regex_replace(card_type.type_text, '--', canvas().emdash)",

		  spawn_flare_particles: "def() ->commands
		  	set(me.particles, lib.particles.create(me, {
				position: [0,0],
				particle_quota: 500000,
				texture: 'particles/flare-128x128.png',
				particle_width: lib.citadel.px(128),
				particle_width: lib.citadel.py(128),

				emitters: [{
					type: 'circle',
					position: [0,0,0],
					emission_rate: 1000.0,
					circle_radius: lib.citadel.px(128),
					direction: [0, 1, 0],
					duration: 100.0,
					repeat_delay: 20,
					time_to_live: 0.1,
					velocity: lib.citadel.px(100),
					angle: { type: 'dyn_random', min: 0.0, max: 360.0 },
					color: [1, 1, 1, 1],
				}]
			})
		  )
		  ",

		  render_benchmark: "def() ->texture_object
		  	_render_internal(c, render_dim[0], render_dim[1]) where c = canvas() where render_dim = render_size(card_size)
		  ",

		animate_shard: "def(class animation.shard_damage_hint hint) ->commands
		if(controller is obj citadel_controller,
		;
		if(target != null,
		execute(me,
		[
			controller.reserve_animation_time('shard', 25),

			animate(me, {
				mid_x: target.mid_x,
				mid_y: target.mid_y,
				card_size: 0.7,
			}, {
				duration: 20,
				name: 'shard',
				replace_existing: false,
				on_complete: ; controller.screen_shake(4, 30, 5)
			}),

			animate(me, {
				alpha: 0,
			}, {
				duration: 5,
				name: 'shard',
				replace_existing: false,
			}),

		])) where target = if(hint.target_loc, find(level.chars, value is obj creature and value.creature_object.loc = hint.target_loc), find(level.chars, value is obj player_avatar and value.player_num = hint.target_player))
		)
		",
	},

	on_game_updated: "if(card_needs_rerender, fire_event('init'))",

	on_init: "[
		fire_event('render'),
		set(animated_card_info, if(_has_dynamic_image and card_type.animation_sequence, construct('animated_card', { card: me }))),
	]",

	on_render: "[
		set(animation, tex),
		set(image_texture, image_tex),
		if(image_tex, [
			set(image_texture_width, int<- image_tex.width),
			set(image_texture_height, int<- image_tex.height),
		]),
		set(texture_width, int<- tex.width),
		set(texture_height, int<- tex.height),
		set(_last_render_key, _calculate_render_key),
		set(scale, decimal(render_dim[0])/get_native_size(render_dim[0], render_dim[1])[0]),
		set(translate_img, [translate_x,translate_y]),
		set(me.scale_img, scale_img),
	] where tex = render_card(render_dim[0], render_dim[1])
	  where render_dim = render_size(card_size)
	  where image_tex = if(show_back = false and card_type.portrait and (_loading_cycles = null or cycle >= _loading_cycles), get_texture({ image: 'portraits/card-size/' + card_type.portrait, surface_flags: ['NO_ALPHA_FILTER'] }))

	  where translate_x = adjustments['translate_x'] or 0.0
	  where translate_y = adjustments['translate_y'] or 0.0
	  where scale_img = adjustments['scale'] or 1.0
	  where adjustments = lib.citadel.card_adjustments[card_type.internal_id] or {}
	",

	on_being_added: "[
	]",

	on_being_removed: "[
		clear_card_tips(),
		set(arrows, []),
	]",

	shader: {
		name: "card_render",
		vertex: "
        uniform mat4 u_anura_mvp_matrix;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
		uniform int resolve_cycle;
		uniform int fizzle_cycle;
		uniform vec4 u_fractional_pos;
        varying vec2 v_texcoord;
        void main()
        {
            v_texcoord = a_anura_texcoord;
            gl_Position = u_anura_mvp_matrix * (a_anura_vertex + u_fractional_pos);
			if(resolve_cycle > 0) {
				if(v_texcoord[0] > 0.05) {
					gl_Position[0] += float(resolve_cycle)/400.0;
				} else {
					gl_Position[0] -= float(resolve_cycle)/400.0;
				}

				if(v_texcoord[1] > 0.05) {
					gl_Position[1] -= float(resolve_cycle)/200.0;
				} else {
					gl_Position[1] += float(resolve_cycle)/200.0;
				}
			}
        }
		",

		fragment: "
        uniform sampler2D u_anura_tex_map;
        uniform sampler2D u_tex_noise;
        uniform sampler2D u_tex_image;
		uniform vec2 u_translate_img;
		uniform float u_scale_img;
		uniform vec4 u_color;
		uniform float u_alpha;
		uniform float u_img_grayscale;
		uniform float u_img_aspect;
		varying vec2 v_texcoord;
		uniform int resolve_cycle;
		uniform int fizzle_cycle;
		uniform vec4 u_anura_sprite_area;
		uniform float u_texture_width;
		uniform float u_texture_height;
		uniform float u_sin_rotate;
		uniform float u_cos_rotate;

		uniform float u_hud_alpha;

		uniform bool u_has_img;
		uniform float u_img_zoom;
		uniform vec2 u_img_target;
		uniform float u_alt_zoom;
		uniform vec2 u_alt_target;
		uniform float u_crossfade_ratio;
        void main()
        {

			float sprite_area_width = u_anura_sprite_area[2] - u_anura_sprite_area[0];
			float sprite_area_height = u_anura_sprite_area[3] - u_anura_sprite_area[1];
			vec4 col = u_color;
			
			gl_FragColor = vec4(0, 0, 0, 0);
			float count = 0.0;
			for(float ypos = -2.0; ypos <= 2.0; ypos += 1.0) {
				for(float xpos = -2.0; xpos <= 2.0; xpos += 1.0) {
					float x = xpos*u_cos_rotate - ypos*u_sin_rotate;
					float y = xpos*u_sin_rotate + ypos*u_cos_rotate;
        			gl_FragColor += texture2D(u_anura_tex_map, v_texcoord + vec2(0.16*x*sprite_area_width/u_texture_width, 0.16*y*sprite_area_height/u_texture_height)) * col;
					count += 1.0;
				}
			}

			gl_FragColor = gl_FragColor/count;

			gl_FragColor[3] *= u_hud_alpha;

			float u = v_texcoord[0] / sprite_area_width;
			float v = v_texcoord[1] / sprite_area_height;

			float h_dist_center = abs(u - 0.5);
			float v_dist_center = abs(v - 0.5);

			float left_edge = abs(v - 0.5)*0.5 + 0.02;
			float right_edge = 1.0 - left_edge;
			bool in_area = u > left_edge && u < right_edge;

			if(u_has_img && gl_FragColor[3] < 1.0 && v_texcoord[1] >= 0.02 && v_texcoord[1] <= 0.98 && in_area) {

				vec2 img_uv = v_texcoord*u_scale_img + vec2(u_translate_img[0]*sprite_area_width, u_translate_img[1]*sprite_area_height);

				vec2 main_uv = mix(img_uv, u_img_target, u_img_zoom);

				if(main_uv[1] > 0.995) {
					main_uv[1] = 0.995 - (main_uv[1] - 0.995)*0.5;
				}

				vec4 result = vec4(0, 0, 0, 0);
				float count = 0.0;
				float blur_factor = 0.5;
				if(v_texcoord[1] > 0.7) {
					blur_factor += 2.5*u_hud_alpha;
				}

				for(float ypos = -2.0; ypos <= 2.0; ypos += 1.0) {
					for(float xpos = -2.0; xpos <= 2.0; xpos += 1.0) {
						vec2 uv_pos = main_uv + vec2(blur_factor*xpos/800.0, blur_factor*ypos/996.0);
						uv_pos[0] = (uv_pos[0] - 0.15) / ((234.0/268.0)*u_img_aspect);
						if(uv_pos[0] < 0.2) {
							uv_pos[0] += (0.2 - uv_pos[0])*0.3;
						} else if(uv_pos[0] > 0.8) {
							uv_pos[0] -= (uv_pos[0] - 0.8)*0.3;
						}

						if(uv_pos[0] < 0.0) {
							uv_pos[0] = -uv_pos[0];
						} else if(uv_pos[0] > 1.0) {
							uv_pos[0] = 2.0 - uv_pos[0];
						}
						result += texture2D(u_tex_image, uv_pos) * col;

						//hack to provide a nice smooth edge to the card.
            			//result[3] += texture2D(u_anura_tex_map, vec2(v_texcoord[0], 0.9) + vec2(0.16*x*sprite_area_width/u_texture_width, 0.16*y*sprite_area_height/u_texture_height))[3] * col[3] - 1.0;
						
						count += 1.0;
					}
				}

				result = result/count;

				if(u_img_grayscale > 0.0) {
					float avg = (result[0] + result[1] + result[2])/3.0;
					result[0] = mix(result[0], avg, u_img_grayscale);
					result[1] = mix(result[1], avg, u_img_grayscale);
					result[2] = mix(result[2], avg, u_img_grayscale);
				}

				if(v > 0.7) {
					result = mix(result, vec4(1,1,1,1), 0.5*u_hud_alpha);
				}

            	gl_FragColor = mix(result, gl_FragColor, gl_FragColor[3]);
				gl_FragColor[3] = 1.0;
			}

			if(resolve_cycle > 0) {
				gl_FragColor[3] *= 1.0 - float(resolve_cycle)/50.0;
			} else if(fizzle_cycle > 0) {
				if(float(fizzle_cycle)/25.0 > texture2D(u_tex_noise, v_texcoord)[0]) {
					gl_FragColor[3] = 0.0;
				}
			}

			gl_FragColor[3] *= u_alpha;
		}
		",

		create: "[
			set(uniform_commands.u_tex_noise, 1),
			set(uniform_commands.u_tex_image, 2),
			set(uniform_commands.fizzle_cycle, 0),
			set(uniform_commands.resolve_cycle, 0),
			set(uniform_commands.u_hud_alpha, parent.hud_alpha),
			set(uniform_commands.u_img_zoom, parent.img_zoom),
			set(uniform_commands.u_alpha, 1.0),
			set(uniform_commands.u_img_grayscale, parent.image_grayscale),
			set(parent.noise_texture, tex),
			set(textures, [tex, tex]),
			set(tex.binding_point, 1),
			set(uniform_commands.u_has_img, 0),

			if(parent.img_target,
			   set(uniform_commands.u_img_target, parent.img_target),
			   parent.card_type.portrait_focus,
			   set(uniform_commands.u_img_target, [parent.card_type.portrait_focus[0]/800.0, parent.card_type.portrait_focus[1]/996.0]),
			   set(uniform_commands.u_img_target, [0.5,0.5])
			),

		] where tex = load_texture('noise.png')",

		draw: "[
			set(uniform_commands.u_color, color),
			set(uniform_commands.u_texture_width, parent.texture_width),
			set(uniform_commands.u_texture_height, parent.texture_height),
			set(uniform_commands.u_sin_rotate, sin(-parent.rotate)),
			set(uniform_commands.u_cos_rotate, cos(-parent.rotate)),
			set(uniform_commands.u_alpha, parent.alpha/255.0),

			set(uniform_commands.u_fractional_pos, [parent.x_fractional_shader, parent.y_fractional_shader, 0, 0]),

			if(image_texture, [
				set(uniform_commands.u_has_img, 1),
				set(uniform_commands.u_img_aspect, decimal(parent.image_texture_width)/decimal(parent.image_texture_height)),
				set(textures, [textures[0], image_texture]),
				set(image_texture.binding_point, 2),

				if(animated_card_info != null, [
					set(uniform_commands.u_img_zoom, anim_info.zoom),
					set(uniform_commands.u_img_target, anim_info.focus),

					if(anim_info.cross_fade != null, [
						set(uniform_commands.u_alt_zoom, anim_info.cross_fade.zoom),
						set(uniform_commands.u_alt_target, anim_info.cross_fade.focus),
						set(uniform_commands.u_crossfade_ratio, anim_info.cross_fade.ratio),
					], [
						set(uniform_commands.u_crossfade_ratio, 0.0),
					])
				] where anim_info = animated_card_info.calculate_anim(parent.cycle),
				[
					set(uniform_commands.u_crossfade_ratio, 0.0),
				]
				) where animated_card_info = parent.animated_card_info
				
			]),
		] where image_texture = parent.image_texture",
	},

	effects: [
	
	{
		name: "card_shadow",
		create: "[
			set(uniform_commands.resolve_cycle, 0),
			set(enabled, parent.show_shadow),
			set(attributes, [{name: 'a_texcoord'}, {name: 'a_position'}]),
			set(draw_mode, 'triangle_strip'),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			])),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			uniform float u_alpha;
			uniform int resolve_cycle;
			varying vec2 v_texcoord;
			void main()
			{
				gl_FragColor[0] = 0.0;
				gl_FragColor[1] = 0.0;
				gl_FragColor[2] = 0.0;
				gl_FragColor[3] = 0.5 - float(resolve_cycle)/100.0;

				float u = v_texcoord[0];
				float v = v_texcoord[1];

				float left_edge = abs(v - 0.5)*0.5;
				float right_edge = 1.0 - left_edge;

				float edge = 0.1;

				if(u < left_edge + edge) {
					float ratio = max(0, (u - left_edge)/edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(u > right_edge - edge) {
					float ratio = max(0, (right_edge - u)/edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v < edge) {
					float ratio = v/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v > 1.0 - edge) {
					float ratio = (1.0 - v)/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				gl_FragColor[3] *= u_alpha;
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		draw: "[
			set(uniform_commands.u_alpha, parent.effect_alpha),
			set(attribute_commands.a_position, float_array(
			rotate_rect(parent.mid_x, parent.mid_y, parent.rotate,
			[
				x1, y1, x2, y1, x1, y2, x2, y2
			])))
			   where x1 = parent.mid_x - img_w*0.4
			   where x2 = parent.mid_x + img_w*0.6
			   where y1 = parent.mid_y - img_h*0.4
			   where y2 = parent.mid_y + img_h*0.6
			   where img_w = parent.img_w*parent.scale
			   where img_h = parent.img_h*parent.scale,
		]",
	},

	{
		name: "card_halo",
		create: "[
			set(enabled, false),
			set(attributes, [{name: 'a_texcoord'}, {name: 'a_position'}]),
			set(draw_mode, 'triangle_strip'),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			])),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			uniform vec4 u_fractional_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x + u_fractional_pos[0], a_position.y + u_fractional_pos[1], 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			varying vec2 v_texcoord;
			uniform vec4 u_color;
			uniform float u_edge;
			uniform float u_alpha;
			void main()
			{
				gl_FragColor = u_color;

				float u = v_texcoord[0];
				float v = v_texcoord[1];

				float left_edge = abs(v - 0.5)*0.5;
				float right_edge = 1.0 - left_edge;

				if(u < left_edge + u_edge) {
					float ratio = max(0, (u - left_edge)/u_edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(u > right_edge - u_edge) {
					float ratio = max(0, (right_edge - u)/u_edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v < u_edge) {
					float ratio = v/u_edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
					} else if(v > 1.0 - u_edge) {
					float ratio = (1.0 - v)/u_edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				gl_FragColor[3] *= u_alpha;
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		//TODO: There seems to be a one-frame lag between when the
		//a_position is updated and when it takes effect. Work out
		//why this is instead of using shader_enabled_at to delay
		//drawing by a frame.
		draw: "[
			set(uniform_commands.u_fractional_pos, [parent.x_fractional_shader, parent.y_fractional_shader, 0, 0]),

			set(uniform_commands.u_alpha, parent.effect_alpha),
			set(uniform_commands.u_edge, if(parent.halo_shown, 0.02, 0.02)),

			set(uniform_commands.u_color, if(parent.card_type.shadow, [0.0,0.0,0.0,1.0], [1.0,1.0,1.0,1.0])),

			set(attribute_commands.a_position, float_array(
			rotate_rect(
			parent.mid_x, parent.mid_y, parent.rotate,
			[
			   parent_x-border_size, parent_y-border_size,
			   parent_x2+border_size, parent_y-border_size,
			   parent_x-border_size, parent_y2+border_size,
			   parent_x2+border_size, parent_y2+border_size,
			]))) where parent_x = parent.mid_x - (parent.x2 - parent.x)*0.5*parent.scale
			     where parent_y = parent.mid_y - (parent.y2 - parent.y)*0.5*parent.scale
			     where parent_x2 = parent.mid_x + (parent.x2 - parent.x)*0.5*parent.scale
			     where parent_y2 = parent.mid_y + (parent.y2 - parent.y)*0.5*parent.scale
			     where border_size = if(parent.halo_shown, parent.img_w/50.0, parent.img_w/50.0),
		]",
	},

	],
}

