{
	is_strict: true,
	"animation": [

		{
			"id": "main",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

		{
			"id": "big",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

	],
	"id": "card",

	always_active: true,

	on_drag_start: "[
		swallow_mouse_event(),
		if(allow_drag, set(drag_pos, [mouse_x, mouse_y]))
	]
	 where mouse_x = int<- arg.mouse_x
	 where mouse_y = int<- arg.mouse_y",

	on_drag: "if(can_click, [
	  swallow_mouse_event(),
	  if(drag_pos and allow_drag, [
		set(drag_pos, [mouse_x, mouse_y]),
		add(x, dx),
		add(y, dy),
		map(draw_primitives, set(value.points,
		       [[points[0][0] + dx, points[0][1] + dy]] +
			   points[1:] where points = [[int]]<- value.points)),
	] where dx = mouse_x - drag_pos[0]
	  where dy = mouse_y - drag_pos[1])
	])
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",
	on_drag_end: "if(can_click, [swallow_mouse_event(), if(allow_drag, set(drag_pos, null))])",

	on_click: "if(can_click, [
		debug('click card: ' + hand_index),
		swallow_mouse_event(),
		if(is_choice,
	       controller.option_clicked(choice_value),
	[
	 switch(mouse_button,
	  1, controller.card_clicked(me),
	  3, controller.card_right_clicked(me))
	])
	]) where mouse_button = int<- arg.mouse_button",

	//mouseover_delay: 20,
	on_mouse_enter: "if(not in_hand, controller.mouse_enter_card(me))",
	on_mouse_leave: "if(not in_hand, [
		controller.mouse_leave_card(me),
		if(me.widgets.ability_tooltip, [set(me.widgets.ability_tooltip, null)]),
	])",

/*
	on_mouse_move: "if(in_hand and tip != null, [
		set(me.widgets.child, create_tooltip_widget(tip)),
	],
	if(me.widgets.ability_tooltip, [set(me.widgets.ability_tooltip, null)])
	)
	  where tip = class tooltip_area|null<-
	    find(tooltips, value.point_in_area(xpos, ypos))
	  where xpos = mouse_x - x
	  where ypos = mouse_y - y
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",
*/
	on_animate_draw: "if(hand_index != null, animate_draw(hand_index*10))",

	on_process: "[
	 if(animation_target != null,
	  if(animation_target.cycles <= 0,
		[
			set(mid_x, animation_target.mid_x),
			set(mid_y, animation_target.mid_y),
			set(rotate, animation_target.rotate),
			set(card_size, animation_target.card_size),
			set(animation_target, null),
		],
		[
			add(animation_target.cycles, -1),
			set(mid_x, int(ratio*animation_target.start_mid_x + (1.0-ratio)*animation_target.mid_x)),
			set(mid_y, int(ratio*animation_target.start_mid_y + (1.0-ratio)*animation_target.mid_y)),
			set(card_size, ratio*animation_target.start_card_size + (1.0-ratio)*animation_target.card_size),
			set(rotate, ratio*animation_target.start_rotate + (1.0-ratio)*animation_target.rotate),
		] where ratio = animation_target.cycles/decimal(animation_target.total_cycles)
		)
	  ),
	  fire_event('check_needs_render'),
	  
	 ]",
	
	on_check_needs_render: "if(card_needs_rerender, fire_event('render'))",

	properties: {

		can_click: { default: true },

		animation_target: {
			type: "null|{start_rotate: decimal, start_mid_x: int, start_mid_y: int, start_card_size: decimal, total_cycles: int, cycles: int, rotate: decimal, mid_x: int, mid_y: int, card_size: decimal }",
			set_type: "null|{total_cycles: int, cycles: int, rotate: decimal, mid_x: int, mid_y: int, card_size: decimal }",
			set: "if(value = null, set(_data, null),
			      set(_data, value + {start_rotate: rotate, start_mid_x: mid_x, start_mid_y: mid_y, start_card_size: card_size}))"
		},

		play_sound: "def(string|null fname) ->commands
			if(fname != null, sound(fname, lib.citadel.sound_volume(fname)))",

		//State to let us know if anything about the way the card would be
		//drawn has changed and the card needs re-rendering.
		_calculate_render_key: "{resources: {int -> int}, card_size: decimal} :: {resources: if(player, player.resource_level, {}), card_size: card_size}",
		_last_render_key: { type: "{resources: {int -> int}, card_size: decimal}|null" },
		card_needs_rerender: "_calculate_render_key != _last_render_key",


		tooltips: { type: "[class tooltip_area]", default: [] },

		noise_texture: { type: "null|object" },

		buttons_widget: { type: "null|obj card.keep_button" },

		stack_id: { type: "null|int" },

		drag_pos: { type: "null|Loc" },
		choice_value: { type: "null|int|string" },
		is_choice: { default: false },
		sent_discard_msg: { default: false },
		allow_drag: { default: false },

		creature: { type: "null|obj creature" },
		
		in_hand: { default: false },
		discarded: { default: false },
		hand_index: { type: "null|int" },
		_keep_label: { type: "null|obj card.keep_label" },

		controller: { type: "obj citadel_controller_base" },

		player: { type: "null|class player" },

		clear_widget_tooltips: "def() -> commands set(tooltips, [])",

		add_widget_tooltip: "def(widget w, int x, int y) -> commands [
			if(w.tooltip != null, add(tooltips, [construct('tooltip_area', { area: map([(int<- x) + (int<- (widget<- w).x), y + w.y, w.w, w.h], int(value*size_ratio)), tooltip: w.tooltip})])),
			map(w.children, add_widget_tooltip(value, x + w.x, y + w.y)),
		] where size_ratio = card_size/2.0",

		create_tooltip_widget: "def(class tooltip_area tip) ->object
		widget(me, {
			type: 'dialog',
			id: 'ability_tooltip',
			alpha: 175,
			clear_backround_alpha: 120,
			padding: 0,
			frame_padding: [10,10],
			zorder: 2000,
			cursor:[10, 10],
			x: tip.area[0],
			y: tip.area[1] - 40,
			background_frame: 'empty_window',
			children: [
				{
					type: 'label',
					font: 'RobotoCondensed-Regular',
					alpha: 255,
					size: 16,
					color: 'light_gray',
					text: tip.tooltip,
				}
			],
		})",

		start_fizzle_animation: "def() ->commands
		[
			play_sound(card_type.sound_fizzle),
			set(shader.uniform_commands.fizzle_cycle, {value: 1, increment: true}) asserting shader
		]",
		start_resolve_animation: "def() ->commands execute(me, [
			play_sound(card_type.sound_resolve),
			schedule(5, [set(shader.uniform_commands.resolve_cycle, {value: 1, increment: true}), set(me.effects[0].enabled, false)]),
			set(me.effects[0].enabled, true),
		]) asserting shader",

		show_halo: "def() ->commands if(not effects[0].enabled, [
			set(me.effects[0].enabled, true),
			set(shader_enabled_at, cycle),
		])",
		hide_halo: "def() ->commands if(effects[0].enabled, [
			set(me.effects[0].enabled, false),
		])",

		shader_enabled_at: { default: -1 },

		show_keep_button: "def() ->commands execute(me, [hide_keep_button(),  spawn('card.keep_button', mid_x-24, int(mid_y+80*card_size), { facing: facing, parent_card: me }, [set(buttons_widget, child)])])",
		hide_keep_button: "def() ->commands [execute(me, if(buttons_widget, [remove_object(buttons_widget), set(buttons_widget, null)])), hide_halo()]",

		toggle_keep: "def() ->commands if(me._keep_label, [set(me._keep_label, null), remove_object(me._keep_label)], spawn('card.keep_label', mid_x+30, mid_y, {_parent_card: me}, [set(me._keep_label, child)]))",

		marked_as_keep: "bool<- me._keep_label != null",

		render_scale: { type: "int", default: 2, variable: true },
		card_size: { type: "decimal", default: 2.0, variable: true },

		destroy: "def() ->commands [if(me._keep_label, remove_object(me._keep_label)), set(me._keep_label, null), if(buttons_widget, remove_object(buttons_widget)), if(creature, creature.destroy()), set(buttons_widget, null), set(creature, null), remove_object(me)]",
		animate_draw: "def(int nstagger) ->commands execute(me, [
			set(me.x, -1000), //hack hack! Take it off screen until schedule starts
			set(me.y, -1000),
			map(range(26), schedule(nstagger + value, [
				set(me.x, x + index*(nstagger/10 - 2)),
				set(me.y, y - index*10),
				set(me.alpha, min(255, value*20)),
			] where index = 25 - value)),
		])",

		set_discarded: "def(bool val) ->commands [if(val,
		  execute(me, [set(discarded, true)]),
		  execute(me, [set(discarded, false)])),
		  debug('SET DISCARDED ' + val),
		  set(me.red, col),
		  set(me.green, col),
		  set(me.blue, col),
		] where col = if(val, 32, 255)
		  ",


		//card_type property which can be a card OR an activated_ability.
		card_type: {
		  type: "class card_base",
		  get: "_data", set: "execute(me, [
			if(creature_obj, [
					set(creature, child), 
				]
				where child = object('creature', if(creature_obj.sprite_sheet = 'creature_large', 125, 80)*render_scale, 52*render_scale, 1,
				  {
					zorder: zorder+5,
					controller: controller,
					creature_object: creature_obj
				  })
				) where creature_obj = if(value._class != 'activated_ability', value.creature_object),
				set(_data, value), 
				fire_event('init')
			  ]) asserting value != null"
		},

		_render_size: "def(decimal size) ->[int,int] [int(size*0.8*209), int(size*0.8*373)]",

		_native_render_sizes: "[[int,int]] :: map([0.8,1.0,2.0], _render_size(value))",

		render_card: "def(int requested_width, int requested_height) ->map {
			id: 'fbo',
			image: 'fbo',
			fbo:  query_cache(global_cache(), [card_type.name, w, h],
			 c.render(w, h, [
			  c.set_font('Roboto_Condensed/RobotoCondensed-Regular.ttf'),

			  c.save(),

			  c.set_source_rgba(1, 1, 0.5, 1),
			  c.set_linear_pattern(0, 0, 200, 0,
			  
			  switch(card_type.first_school,
					  
			  FOOD, [
			  { offset: 0, red: 0.25, green: 0.25, blue: 0.15 },
			  { offset: 1, red: 0.45, green: 0.45, blue: 0.4 },
			  ],

			  GOLD, [
			  { offset: 0, red: 0.2, green: 0.2, blue: 0.2 },
			  { offset: 1, red: 0.4, green: 0.4, blue: 0.5 },
			  ],

			  BLOOD, [
			  { offset: 0, red: 0.3, green: 0.15, blue: 0.15 },
			  { offset: 1, red: 0.5, green: 0.35, blue: 0.45 },
			  ],

			  FAITH, [
			  { offset: 0, red: 0.8, green: 0.8, blue: 0.8 },
			  { offset: 1, red: 0.9, green: 0.9, blue: 1.0 },
			  ],

			  SCROLLS, [
			  { offset: 0, red: 0.15, green: 0.15, blue: 0.3 },
			  { offset: 1, red: 0.35, green: 0.35, blue: 0.6 },
			  ],

			  [
			  { offset: 0, red: 0.2, green: 0.2, blue: 0.2 },
			  { offset: 1, red: 0.4, green: 0.4, blue: 0.5 },
			  ],
			  
			  )),
			  c.rectangle(0, 0, w, h*0.05),
			  c.fill(),

			  c.set_radial_pattern(100*scaling, 0*scaling, 120*scaling, 100*scaling, 300*scaling, 120*scaling, [
			  { offset: 0, red: 0.25, green: 0.32, blue: 0.44 },
			  { offset: 1, red: 0.05, green: 0.05, blue: 0.1 },
			  ]),
			  c.rectangle(0, h*0.05, w, h*0.7),
			  c.fill(),
			  
			  c.set_source_rgba(1, 1, 1, 1),
			  c.rectangle(0, h*0.7, w*(1.0 - attr_area + 0.01), h*0.3),
			  c.fill(),


			  c.set_source_rgba(0.7, 0.7, 0.7, 1),
			  c.rectangle(w*(1.0 - attr_area), h*0.7, w*attr_area, h*0.3),
			  c.fill(),

			  c.save(),
			  c.set_source_rgba(0, 0, 0, 1),
			  c.set_font_size(12*scaling),
			  c.translate(0.04*w, 0.75*h),
			  c.show_rich_text_multiline(lib.citadel.process_markup(card_type.rules_text), (0.96 - attr_area)*w, 0.3*h, {svg_scale: 0.025*h/512.0, svg_width: (10.0*h)/512.0}),
			  c.restore(),

			  ] +

			  //the portrait
			  if(card_type.portrait != null, [
			  c.save(),
			  c.translate((w - (dim[0]*(h*0.7)/dim[1]))/2.0, h*0.05),
			  c.scale((h*0.65)/dim[1]),
			  c.paint_image('images/portraits/' + card_type.portrait),
			  c.restore(),

			  ] where dim = c.image_dim('images/portraits/' + card_type.portrait), []) +

			  [

			  //the area showing the type of the card.
			  c.set_source_rgba(1.0, 1.0, 1.0, 0.2),
			  c.rectangle(0, (h*0.66), w, (h*0.04)),
			  c.fill(),

			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.translate(w*0.03, h*0.69),
			  c.set_font_size(12*scaling),
			  c.text_path_in_bounds(_type_text, w*0.94, ['right']),
			  c.fill(),

			  c.restore(),

			  c.set_source_rgba(1, 1, 1, 1),

			  c.set_font('Roboto_Condensed/RobotoCondensed-Bold.ttf'),

			  //The cost of the card.
			  c.set_source_rgba(0.25, 0.25, 0.30, 1),
			  c.arc(0.9*w, 0.1*h, 0.04*h, 0.0, 3.15*2),
			  c.fill(),
			] +

			fold(map(card_type.school_list, fold(
			  map(range(card_type.loyalty_cost),
			  [
			  c.arc(center_x, center_y, 0.02*h, 0.0, 3.15*2),
			  c.fill(),

			  c.save(),
			  c.translate(center_x - 0.022*w, center_y - 0.012*h),
			  c.scale(0.025*h/512.0),
			  c.draw_svg('images/icons/' + icon_name),
			  c.restore(),
			  ] where center_x = (0.9 + 0.045 - school_num*0.05)*w
			    where center_y = (0.1 + 0.045 + index*0.035)*h),
			a+b) where icon_name = lib.citadel.school_info[school].icon
			     where school_num = index where school = value), a+b) +

			[

			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font_size(20*scaling),
			  c.translate(0.878*w, 0.118*h),
			  c.text_path(str(card_type.cost)), 
			  c.fill(),

			  c.restore(),


			  //Name of the card
			  c.save(),

			  c.translate(w*0.03, h*0.035),

			  if(card_type.first_school = FAITH, c.set_source_rgba(0, 0, 0, 1), c.set_source_rgba(1, 1, 1, 1)),
			  c.set_font_size(12*scaling),
			  c.text_path_in_bounds(card_type.name, w*0.94, ['right']),
			  c.fill(),
			  c.close_path(),

			  c.restore(),


			  ] +

			  fold([
			   [
			    c.set_source_rgba(0.25, 0.25, 0.30, 1),
			    c.arc(attr.center_x*w, attr.center_y*h, 0.04*h, 0.0, 3.15*2),
			    c.arc((attr.center_x - 0.045)*w, (attr.center_y-0.025)*h, 0.02*h, 0.0, 3.15*2),
			    c.fill(),

				c.save(),
				c.set_font_size(20*scaling),
				c.translate((attr.center_x - 0.025)*w, (attr.center_y + 0.02)*h),
				c.text_path(str(attr.value)),
				c.restore(),

				c.save(),
				c.translate((attr.center_x - 0.064 - (attr.scaling-1.0)*0.015)*w, (attr.center_y-0.036 - (attr.scaling-1.0)*0.01)*h),
				c.scale(attr.scaling*0.02*h/512.0),
				c.draw_svg('images/icons/' + attr.icon),
				c.restore(),
			   ]
			  | attr <- renderable_attr], a+b) +

			  [
			  	c.restore(),
			  ]
			  )) where scaling = h/373.0,
			x: 0, y: 0, w: w, h: h,
			scale: requested_width/decimal(w),
			frames: 1,
		} where attr_area = if(renderable_attr = [], 0.0, if(size(renderable_attr) > 3, 0.36, 0.18))
		  where c = canvas()
		  where renderable_attr = _renderable_attributes()
		  where w = actual_size[0]
		  where h = actual_size[1]
		  where actual_size = find_or_die(_native_render_sizes, value[0] >= requested_width and value[1] >= requested_height or index = size(_native_render_sizes)-1)",

		_renderable_attributes: "def() -> [{icon: string, scaling: decimal, value: int, center_x: decimal, center_y: decimal}]
		  map(attributes, value + {
			center_x: if(index < 3, 0.91, 0.73),
			center_y: 0.759 + 0.093*(index%3),
		  })
			where attributes = if(cr = null, [],
			[
			{
				value: cr.life,
				icon: 'heart-bottle.svg',
				scaling: 1.4,
			},
			{
				value: cr.attack,
				icon: 'crossed-swords.svg',
				scaling: 1.1,
			},
			] +
			if(cr.range > 1,
			[{
				value: cr.range,
				icon: 'lob-arrow.svg',
				scaling: 1.0,
			}], []) +
			if(cr.move != 0,
			[{
				value: cr.move,
				icon: 'walking-boot.svg',
				scaling: 1.2,
			}], []) +
			if(cr.resistance != 0,
			[{
				value: cr.resistance,
				icon: 'shield.svg',
				scaling: 1.4,
			}], [])
		) where cr = card_type.creature_object
		",

		_type_text: "string ::
		  if(card_type.creature_object != null,
			if(card_type.hero, 'Hero' + canvas().emdash, if(card_type.creature_object.is_construct, 'Construct' + canvas().emdash, 'Creature' + canvas().emdash)) + fold(card_type.creature_object.tags, a + ' ' + b, ''),
			if(card_type._class = 'card', 'Spell', 'Ability') + if(card_type.is_response, canvas().emdash + 'Response', '')
		  )
		  ",

	},

	on_toggle_keep: "toggle_keep()",

	on_game_updated: "if(card_needs_rerender, fire_event('init'))",

	on_init: "[
		if(marked_as_keep, [fire_event('toggle_keep'), fire_event('toggle_keep')]),

		fire_event('render')
	]",

	on_render: "[
		set(animation, render_card(_render_size(card_size)[0], _render_size(card_size)[1])),
		set(_last_render_key, _calculate_render_key),
	]",

	object_type: [
	{
		id: "keep_button",
		hidden_in_game: true,

		properties: {
			parent_card: { type: "obj card" }
		},

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			frames: 1,
		},

		on_spawned: "[set(zorder, spawner.zorder+10), set(parent_card, obj card<- spawner)] where spawner = custom_obj <- arg.spawner",

		on_create: "set_widgets([{
			type: 'grid',
			columns: 2,
			children: [
			{
				type: 'button',
				resolution: 'normal',
				label: {type: 'label', text: 'Keep', font: 'RobotoCondensed-Bold', color: 'antique_white'},
				on_click: def() [if(parent_card.discarded, parent_card.controller.card_clicked(parent_card)), parent_card.toggle_keep()],
			},
			{
				type: 'button',
				resolution: 'normal',
				label: {type: 'label', text: 'Discard', font: 'RobotoCondensed-Bold', color: 'antique_white'},
				on_click: def() parent_card.controller.card_right_clicked(parent_card),
			}
			]
		}])",
	},

	{
		id: "keep_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			frames: 1,
		},

		properties: {
			_xpos: 0,
			_ypos: 0,
			_parent_card: { type: "obj card" },
		},

		on_spawned: "[
		  set(_xpos, x - _parent_card.x),
		  set(_ypos, y - _parent_card.y),
		  set(zorder, _parent_card.zorder+100)
		]",

		on_process: "if(_parent_card, [
			set(x, _parent_card.x + _xpos),
			set(y, _parent_card.y + _ypos),
		])",

		on_create: "set_widgets([{
			type: 'label',
			text: 'Keep',
			font: 'RobotoCondensed-Bold',
			align_h: 'center',
			color: 'antique_white',
			size: 42
		}])",
	},
	],

	shader: {
		program: "card",
		create: "[
			set(uniform_commands.u_tex_map, 0),
			set(uniform_commands.u_tex_noise, 1),
			set(uniform_commands.fizzle_cycle, 0),
			set(uniform_commands.resolve_cycle, 0),
			set(parent.noise_texture, load_texture('images/noise.png')),
		]",

		draw: "[
			set(uniform_commands.u_color, color),
			bind_texture(current_texture, 0),
			bind_texture(parent.noise_texture.id, 1),
		]",
	},

	effects: [{
		name: "card_halo",
		create: "[
			set(enabled, false),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			], 2)),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			varying vec2 v_texcoord;
			void main()
			{
				gl_FragColor[0] = 1.0;
				gl_FragColor[1] = 1.0;
				gl_FragColor[2] = 1.0;
				gl_FragColor[3] = 1.0;

				float edge = 0.1;

				if(v_texcoord[0] < edge) {
					float ratio = v_texcoord[0]/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v_texcoord[0] > 1.0 - edge) {
					float ratio = (1.0 - v_texcoord[0])/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v_texcoord[1] < edge) {
					float ratio = v_texcoord[1]/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v_texcoord[1] > 1.0 - edge) {
					float ratio = (1.0 - v_texcoord[1])/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		//TODO: There seems to be a one-frame lag between when the
		//a_position is updated and when it takes effect. Work out
		//why this is instead of using shader_enabled_at to delay
		//drawing by a frame.
		draw: "[
			set(attribute_commands.a_position, float_array([
			   parent.x-border_size, parent.y-border_size,
			   parent.x2+border_size, parent.y-border_size,
			   parent.x-border_size, parent.y2+border_size,
			   parent.x2+border_size, parent.y2+border_size,
			], 2)) where border_size = parent.img_w/10.0,
			if(parent.cycle > parent.shader_enabled_at,
			   draw_arrays('triangle_strip', 0, 4)),
		]",
	}],
}
