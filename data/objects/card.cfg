{
	is_strict: true,
	"animation": [

		{
			"id": "main",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

		{
			"id": "big",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

		{
			"id": "back",
			"image": { image:"card-back.png", border_color:[255, 255, 255, 1], address_mode:['border', 'border'], mipmaps:4, filtering:'bilinear'},
			"rect": [0,0,147,261],
			scale: 1
		},


	],
	"id": "card",

	always_active: true,

	on_mouse_enter: "[
	  if(in_opponent_hand and controller is obj citadel_controller, controller.mouse_enter_opponent_card(me)),
	  set(mouse_over, true),
	  if(in_ability, animate(me, { card_size: 1.6 }, { duration: 15 })),
	  if(in_victory and find(animated_movements, value = 'victory_card_move') = null, [
		animate(me, {
			mid_x: mid_x,
			mid_y: (mid_y + screen_height/2)/2,
			card_size: card_size*2,
			zorder: zorder+10,
		}, {
			duration: 10,
			name: 'card_move',
			replace_existing: true,
		}),

		set(_starting_state, {mid_x: mid_x, mid_y: mid_y, card_size: card_size, zorder: zorder})
		]),
	  if(is_choice, [
		show_halo(),
		animate(me, {
			mid_x: mid_x,
			mid_y: (mid_y + screen_height/2)/2,
			card_size: card_size*1.6,
		}, {
			duration: 10,
			name: 'choice_card_move',
			replace_existing: true,
		}),
		set(_starting_state, {mid_x: mid_x, mid_y: mid_y, card_size: card_size, zorder: zorder})
		]),
	]",

	on_mouse_leave: "[

	  if(in_opponent_hand and controller is obj citadel_controller, controller.mouse_leave_opponent_card(me)),
	  set(mouse_over, false),
	  if(in_ability, animate(me, { card_size: 1.0 }, { duration: 15 })),
	  if(in_victory and _starting_state != null, [
		animate(me, {
			mid_x: _starting_state.mid_x,
			mid_y: _starting_state.mid_y,
			card_size: _starting_state.card_size,
			zorder: _starting_state.zorder,
		}, {
			duration: 10,
			name: 'victory_card_move',
			replace_existing: true,
		}),

		set(_starting_state, null)
	]),
	  if(is_choice and _starting_state != null, [
	    hide_halo(),
		animate(me,{
			mid_x: _starting_state.mid_x,
			mid_y: _starting_state.mid_y,
			card_size: _starting_state.card_size,
		}, {
			duration: 10,
			name: 'choice_card_move_back',
			replace_existing: true,
		})
	]),
	]",

	on_drag_start: "[
		swallow_mouse_event(),
		if(allow_drag, set(drag_pos, [mouse_x, mouse_y])),
		controller.mouse_drag_card_start(me),
	]
	 where mouse_x = int<- arg.mouse_x
	 where mouse_y = int<- arg.mouse_y",

	on_drag: "[
	  swallow_mouse_event(),
	  if(drag_pos and allow_drag, [
		set(drag_pos, [mouse_x, mouse_y]),
		add(x, dx),
		add(y, dy),
		map(draw_primitives, set(value.points,
		       [[points[0][0] + dx, points[0][1] + dy]] +
			   points[1:] where points = [[int]]<- value.points)),

		controller.mouse_drag_card(me),
	] where dx = mouse_x - drag_pos[0]
	  where dy = mouse_y - drag_pos[1])
	]
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",

	on_drag_end: "[
	  set(drag_pos, null),
	  controller.mouse_drag_card_end(me),
	]",

	on_click: "[

	if(
	click_handler != null, [
		swallow_mouse_event(),
		click_handler(),
	],
	hand_card_off_to_side, if(controller is obj citadel_controller, controller.tile_clicked(null)),
	controller.paused = false or is_choice, [
		swallow_mouse_event(),
		if(is_choice and (choice_index is int),
		[
		   hide_halo(),
	       controller.option_clicked(choice_index, choice_value),
		],
	
	       switch(mouse_button, 
				1, controller.card_clicked(me),
				3, controller.card_right_clicked(me),
			null))
	])
			] where mouse_button = int<- arg.mouse_button",

	on_animate_draw: "if(hand_index != null, animate_draw(hand_index*10))",

	on_type_updated: "if(not show_back, fire_event('render'))",

	on_process: "[
	  fire_event('check_needs_render'),
	  set(brightness, if(highlight and level.cycle%50 < 25, 512, 255)),

	 ]",
	
	on_check_needs_render: "if(card_needs_rerender, fire_event('render'))",

	properties: {

		screen_width: "int :: level.dimensions[2] - level.dimensions[0]",
		screen_height: "int :: level.dimensions[3] - level.dimensions[1]",

		flip_card: {
			type: "decimal",
			default: 0.0,
			set: "[
				set(_data, value),
				if(val = 0.0, [
					set(uv_array, null),
					set(xy_array, null),
				], [
					set(uv_array, [0,0,1,0,1,1,0,1,0,0]),
					set(xy_array, [val,ypos, inv_value,-ypos, inv_value,1-ypos, val,1+ypos, val,ypos]),
				]),
			] where inv_value = 1.0 - val
			  where val = if(value < 0.5, value, 1.0 - value)
			  where ypos = sin(value*180.0)*0.1*if(value < 0.5, 1.0, -1.0)
			  ",
		},

		mouse_over: { default: false },
		click_handler: { type: "null|function()->commands" },

		_card_tips: { type: "[obj tip_dialog]", default: [] },

		_starting_state: { type: "null|{mid_x: int, mid_y: int, card_size: decimal, zorder: int}" },


		_rules_text_width: "0.94",

		calculate_font_size: "def(int cur_size=12) ->int cur_size",
		/*
		  if(cur_size > 4 and flavor_height + rules_height + 10 > 420*0.18, calculate_font_size(cur_size-1), cur_size)
			where flavor_height = max(map(flavor_fragments, value.y + value.height)) or 0
			where rules_height = max(map(fragments, value.y + value.height)) or 0
			where flavor_fragments = if(card_type.flavor_text, c.markup_text(q(<font size=') + cur_size + q('><i>) + card_type.flavor_text + q(</i></font>), _rules_text_width*210.0), [])
			where fragments = c.markup_text(q(<font size=') + cur_size + q('>) + card_type.rules_text + q(</font>), _rules_text_width*210.0)
			
			where c = canvas()
		",*/



		show_card_tips: "def() ->commands execute(me, [
			clear_card_tips(),

			map([{title: string, text: string }] :: card_type.rules_tips,
				spawn('tip_dialog', positions[index][0], positions[index][1], {
					zorder: zorder+1,
					_tip: {
						key: 'tip',
						text: info.text,
						targets: [me],
					},
					_title: info.title,
					_has_close: false,
					_width: 220,
					_height: 120,
				}, [
					add(me._card_tips, [child]),
				])
				where info = {title: string, text: string} <- value
			)
		]) where positions = [
			[x2 + 180, y + 60],
			[x2 + 180, mid_y],
			[x2 + 180, y2 - 60],
			[x - 180, y + 60],
			[x - 180, mid_y],
			[x - 180, y2 - 60],
		]",

		clear_card_tips: "def() ->commands [
			map(_card_tips, remove_object(value)),
			set(me._card_tips, []),
		]",

		is_burning: { type: "bool", default: false, set: "if(_data != value, [set(me._data, value), fire_event('check_needs_render')])" },

		highlight: { default: false },

		play_sound: "def(string|null fname) ->commands
			if(fname != null, sound(fname, lib.citadel.sound_volume(fname)))",

		//State to let us know if anything about the way the card would be
		//drawn has changed and the card needs re-rendering.
		_calculate_render_key: "{resources: int, card_size: decimal, is_burning: bool} :: {resources: _actual_cost, card_size: card_size, is_burning: is_burning}",
		_last_render_key: { type: "{resources: int, card_size: decimal, is_burning: bool}|null" },
		card_needs_rerender: "show_back = false and _calculate_render_key != _last_render_key",

		show_back: { type: "bool", default: false },

		set_show_back: "def(bool new_value) ->commands if(new_value != show_back, [
			set(_last_render_key, null),
			set(show_back, new_value),
			if(new_value, [
				set(animation, 'back')
			]),
		])",

		flip_card_over: "def(bool new_value, int duration=20, decimal|null new_card_size=null) ->commands
		execute(me,
		if(new_value != show_back, [
			set(rotate, 0),
			schedule(duration/2, set_show_back(new_value)),
			set(flip_card, 1.0),

			if(new_value,
				animate(me, {
					card_size: 147.0/render_size(1.0)[0]
				}, {
					duration: duration/2,
					on_complete: schedule(2, set(card_size, card_size))
				}),

				schedule(duration/2, [
					set(card_size, 147.0/render_size(1.0)[0]),
					animate(me, {
						card_size: if(new_card_size != null, new_card_size, card_size)
					}, {
						duration: duration/2,
					})
				]),
			),

			animate(me, {
				flip_card: 0.0,
			}, {
				duration: duration,
				name: 'flip_card',
			}),
		])
		)",

		tooltips: { type: "[class tooltip_area]", default: [] },

		noise_texture: { type: "null|object" },

		stack_id: { type: "null|int" },
		stack_info: { type: "null|class message.play_card_base" },

		being_dragged: "bool :: drag_pos != null",
		drag_pos: { type: "null|Loc" },
		choice_index: { type: "null|int" },
		choice_value: { type: "null|int" },
		is_choice: { default: false },
		allow_drag: { default: false },

		in_victory: { default: false },
		in_hand: { default: false },
		hand_card_off_to_side: { default: false },
		parent_creature: { type: "null|class creature" },
		in_ability: { default: false },
		mandatory_play: { default: false },
		player_index: { default: null, type: "int|null" },
		in_graveyard: { default: false },
		in_opponent_hand: { default: false },
		hand_index: { type: "null|int" },

		controller: { type: "obj citadel_controller_base" },

		player: { type: "null|class player" },

		clear_widget_tooltips: "def() -> commands set(tooltips, [])",

		add_widget_tooltip: "def(widget w, int x, int y) -> commands [
			if(w.tooltip != null, add(tooltips, [construct('tooltip_area', { area: map([(int<- x) + (int<- (widget<- w).x), y + w.y, w.w, w.h], int(value*size_ratio)), tooltip: w.tooltip})])),
			map(w.children, add_widget_tooltip(value, x + w.x, y + w.y)),
		] where size_ratio = card_size/2.0",

		create_tooltip_widget: "def(class tooltip_area tip) ->object
		widget(me, {
			type: 'dialog',
			id: 'ability_tooltip',
			alpha: 175,
			clear_backround_alpha: 120,
			padding: 0,
			frame_padding: [10,10],
			zorder: 2000,
			cursor:[10, 10],
			x: tip.area[0],
			y: tip.area[1] - 40,
			background_frame: 'empty_window',
			children: [
				{
					type: 'label',
					font: lib.font.regular_font,
					alpha: 255,
					size: 16,
					color: 'light_gray',
					text: tip.tooltip,
				}
			],
		})",

		start_fizzle_animation: "def() ->commands
		[
			play_sound(card_type.sound_fizzle),
			set(shader.uniform_commands.fizzle_cycle, {value: 1, increment: true}) asserting shader
		]",

		show_shadow: { type: "bool", default: true },

		start_resolve_animation: "def([custom_obj] targets) ->commands
		if(card_type.resolve_effect = 'fire',
		   start_fire_resolve(targets),
		
			execute(me, [
				play_sound(card_type.sound_resolve),
				schedule(5, [set(shader.uniform_commands.resolve_cycle, {value: 1, increment: true}), set(me.effects[1].enabled, false)]),
				schedule(5, [set(effects[0].uniform_commands.resolve_cycle, {value: 1, increment: true})]),
				set(me.effects[1].enabled, true),
				schedule(50, remove_object(me)),
			]) asserting shader
		)",

		start_fire_resolve: "def([custom_obj] targets) ->commands execute(me, [
			controller.reserve_card_resolve_time(170),
			controller.reserve_animation_time('card_fire_resolve', 50),
			//removed for now, investigate crashes and wait for
			//new merge of graphics branch from Krista.
			//spawn('card_particle_effect', 0, 0, { _card: me, zorder: zorder+10 }),
			map(range(101), schedule(value, [set(height_reduction_proportion, 1.0 - value/100.0), fire_event('render'), set(y, y)])),

//			map(targets,
//				spawn('fireball_effect', mid_x, mid_y, { zorder: zorder+10, _target: value })
//				),
		])",

		show_halo: "def() ->commands if(not halo_shown, [
			set(me.effects[1].enabled, true),
			set(shader_enabled_at, cycle),
			set(me.halo_shown, true),
		])",
		hide_halo: "def() ->commands if(halo_shown, [
			set(me.effects[1].enabled, is_castable),
			set(me.halo_shown, false),
		])",

		halo_shown: { default: false, type: "bool" },

		shader_enabled_at: { default: -1 },

		is_castable: {
			type: "bool",
			default: false,
			set: "[
				set(_data, value),
				set(me.effects[1].enabled, value or halo_shown),
			]",
		},

		keep: { default: false },

		render_scale: { type: "int", default: 2, variable: true },
		card_size: { type: "decimal", default: 2.0, variable: true },


		destroy: "def() ->commands [remove_object(me)]",
		animate_draw: "def(int nstagger) ->commands execute(me, [
			schedule(nstagger, play_sound('interface/card-draw'+1d8+'.wav')),

			set(me.mid_x, start_x),
			set(me.mid_y, start_y),
			schedule(nstagger, [
				set(me.mid_x, start_x),
				set(me.mid_y, start_y),
				animate(me, {
					mid_x: mid_x,
					mid_y: mid_y,
				}, {
					duration: 25
				})
			]),

			set(me.mid_x, -1000), //hack hack! Take it off screen until schedule starts
			set(me.mid_y, -1000),
		])
		where start_x = if(parent_creature_obj, parent_creature_obj.mid_x, mid_x + 25*(nstagger/10 - 2))
		where start_y = if(parent_creature_obj, parent_creature_obj.mid_y, mid_y - 250)
		where parent_creature_obj = if(parent_creature, find(level.chars, value is obj creature and value.creature_object = parent_creature))
		",

		animate_movement: "def({stagger: int|null, cycles: int|null, scale: [decimal,decimal]|null, mid_x: [int,int], mid_y: [int,int], rotate: [decimal,decimal]|null, at_end: commands|null} anim) ->commands [

			schedule(nstagger, animate(me, {
				mid_x: anim.mid_x[1],
				mid_y: anim.mid_y[1],
				scale: nscale[1],
				rotate: rotate[1],
			}, {
				duration: ncycles
			}))

			where cmd = 
			map(range(ncycles+1), schedule(value + nstagger, [
				set(me.mid_x, int(interp(anim.mid_x))),
				set(me.mid_y, int(interp(anim.mid_y))),
				set(me.scale, interp(nscale)),
				set(me.rotate, interp(nrotate)),
				if(index = ncycles, anim.at_end),
			]) where interp = def([decimal,decimal] a) ->decimal
			       a[0]*neg_ratio + a[1]*ratio
			    where neg_ratio = 1.0 - ratio
			    where ratio = decimal(index)/decimal(ncycles))
			
		] where ncycles = if(anim.cycles = null, 10, anim.cycles)
		  where nrotate = if(anim.rotate = null, [rotate,rotate], anim.rotate)
		  where nstagger = if(anim.stagger = null, 0, anim.stagger)
		  where nscale = if(anim.scale = null, [scale,scale], anim.scale)",
		
		animate_from: "def(obj card start, int ncycles) ->commands [
			set(scale, start.scale),
			set(mid_x, start.mid_x),
			set(mid_y, start.mid_y),
			set(rotate, start.rotate),
			animate(me, {scale: scale, mid_x: mid_x, mid_y: mid_y, rotate: me.rotate}, {duration: ncycles}),
			
		]",

		//card_type property which can be a card OR an activated_ability.
		card_type: {
		  type: "class card_base",
		  get: "_data", set: "execute(me, [

				set(_data, value), 
				fire_event('init')
			  ]) asserting value != null"
		},

		_actual_cost: "int ::
		  if(player != null,
			 player.calculate_cost(card_type),
			 card_type.cost + card_type.loyalty_cost)",
		
		render_size: "def(decimal size) ->[int,int] [round_to_even(size*0.4*826*(screen_height/900.0)), round_to_even(size*0.4*714*(screen_height/900.0))]",

		_native_render_sizes: "[[int,int]] :: map(lib.citadel.native_card_sizes, render_size(value))",

		texture_width: { default: 128 },
		texture_height: { default: 128 },

		_has_dynamic_image: "bool :: true or (card_type.animation_sequence != [])",

		animated_card_info: { type: "null|class animated_card" },
		image_texture: { type: "null|texture_object" },

		height_reduction_proportion: { type: "decimal", default: 1.0 },

		_render_image: "def(int w, int h) ->texture_object
			c.render(w, h,
				//new style portrait.
			  [
			  c.scale(decimal(w)/800.0),
			  if(card_type.portrait is string, c.paint_image('images/portraits/' + card_type.portrait)),
			  ]
			
			)
			where c = canvas()
		",

		render_card: "def(int requested_width, int requested_height) ->map dump(['RENDERING CARD', w, h, level.cycle], {
			id: 'fbo',
			image: 'fbo',			
			force_no_alpha: true,
			fbo:  query_cache(global_cache(1024), [card_type.internal_id, w, h, _actual_cost, is_burning],
			 dump(['RENDER CARD CACHE MISS'], _render_internal(c, w, h))
			),
			x: 0, y: 0, w: w+2, h: round_to_even((h+2)*height_reduction_proportion),
			scale: requested_width/decimal(w),
			frames: 1,
		}) 
		  where c = canvas()
		  where renderable_attr = _renderable_attributes()
		  where w = actual_size[0]
		  where h = actual_size[1]
		  where actual_size = find_or_die(_native_render_sizes, value[0] >= requested_width and value[1] >= requested_height or index = size(_native_render_sizes)-1)",

		render_card_to_file: "def(decimal size, string fname='card.png') ->commands
			_render_internal(c, sz[0], sz[1], true).save(fname) where c = canvas()
			where sz = render_size(size)
		",

		_render_internal: "def(cairo_callable c, int w, int h, bool draw_image=false) ->texture_object
		c.render(w+2, h+2, [

			  c.translate(1, 1),

			  c.move_to(w*0.25, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.line_to(w*1.0, h*0.5),
			  c.line_to(w*0.75, h*1.0),
			  c.line_to(w*0.25, h*1.0),
			  c.line_to(w*0.0, h*0.5),
			  c.clip(),
			  c.new_path(),


			  if(card_type.portrait != null and draw_image,
			  [

				c.save(),
				//c.rectangle(w*0.3, 0, w*0.4, h),

			  	c.translate(0.15*w, 0),
				//c.clip(),
				c.scale(w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),
				c.save(),
				c.rectangle(w*0.0, 0, w*0.301, h),

				c.clip(),
				c.scale(2.0*w*0.7/800.0, w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),

				c.save(),
				c.rectangle(w*0.699, 0, w*0.301, h),

				c.clip(),
				c.translate(-w*0.4, 0),
				c.scale(2.0*w*0.7/800.0, w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),

				c.save(),
				c.rectangle(w*0, h*0.7, w, h*0.3),
				c.set_source_rgba(1, 1, 1, 0.5),
				c.fill(),

				c.restore(),
			  ]),

			  c.move_to(w*0.25, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.line_to(w*1.0, h*0.5),
			  c.line_to(w*0.75, h*1.0),
			  c.line_to(w*0.25, h*1.0),
			  c.line_to(w*0.0, h*0.5),

			  c.move_to(w*0.03, h*0.50),
			  c.line_to(w*0.28, h*0.97),
			  c.line_to(w*0.73, h*0.97),
			  c.line_to(w*0.97, h*0.50),
			  c.line_to(w*0.73, h*0.03),
			  c.line_to(w*0.27, h*0.03),

			  c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
			  c.fill(),

			  c.move_to(w*0.108, h*0.676),
			  c.line_to(w*0.892, h*0.676),
			  c.line_to(w*0.867, h*0.727),
			  c.line_to(w*0.133, h*0.727),
			  c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
			  c.fill(),

			  //Name of the card
			  [
			    c.save(),

				c.move_to(0.909*w, 0.620*h),
				c.line_to(0.878*w, 0.680*h),
				c.line_to((0.900 - 0.12)*w - name_dim.width, 0.680*h),
				c.line_to((0.900 - 0.08)*w - name_dim.width, 0.620*h),
				c.set_source_rgba(1,1,1,1),
				c.fill(),

				c.restore(),

			  if(card_type is class card and card_type.set != null,
				[
				c.save(),

				c.translate(w*0.845 - name_dim.width, h*0.648),

				c.set_source_rgba(1, 1, 1, 1),
				c.arc(0, 0, w*0.018, 3.15*0.5, 3.15*1.5),

				c.scale(if(card_type.rarity = 0, -0.6, card_type.rarity = 1, -0.1, 1), 1.0),
				c.arc(0, 0, w*0.018, 3.15*1.5, 3.15*2.5),
			    c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				c.fill(),

				c.restore(),
			  ]),


			  	c.save(),

			  	c.translate(w*0.03, h*0.665),

			  	c.set_source_rgba(0, 0, 0, 1),
			  	c.set_font(lib.font.bold_font),
			  	c.set_font_size(18*scaling),
			  	c.text_path_in_bounds(card_type.name, w*0.84, ['right']),
			  	c.fill(),
			  	c.close_path(),

			  	c.restore(),
			  ] where name_dim = c.text_extents(lib.font.bold_font, 18*scaling, card_type.name),

			  c.save(),
			  c.translate(0.740*w, 0.410*h),
			  c.move_to(0.113*w, 0.022*h),
			  c.line_to(0.182*w, 0.022*h),
			  c.line_to(0.214*w, 0.090*h),
			  c.line_to(0.182*w, 0.158*h),
			  c.line_to(0.113*w, 0.158*h),
			  c.line_to(0.081*w, 0.090*h),
			  c.restore(),

			  c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
			  c.fill(),

			  if(card_type.loyalty_cost > 0, [
				c.save(),
				c.translate(0.730*w, 0.28*h),
			  	c.move_to(0.101*w, 0.054*h),
			  	c.line_to(0.144*w, 0.054*h),
			  	c.line_to(0.165*w, 0.097*h),
			  	c.line_to(0.144*w, 0.141*h),
			  	c.line_to(0.101*w, 0.141*h),
			  	c.line_to(0.080*w, 0.097*h),
				c.restore(),
			  ]),

			  c.fill(),

			  //cost
			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.get(67)),

			  if(_actual_cost > card_type.cost + card_type.loyalty_cost,
			     c.set_source_rgba(1, 0.8, 0.8, 1),
				 _actual_cost < card_type.cost + card_type.loyalty_cost,
			     c.set_source_rgba(0.8, 0.8, 1.0, 1),
			     c.set_source_rgba(1, 1, 1, 1)
			  ),

			  c.set_font_size(36*scaling),
			  c.translate(if(_actual_cost >= 10, 0.842, 0.870)*w, 0.530*h),
			  c.text_path(str(_actual_cost)), 
			  c.fill(),

			  c.restore(),


			  if(card_type.loyalty_cost,
			  [
			  	c.save(),
			  	c.set_font(lib.font.bold_font),
			  	c.set_font_size(22*scaling),
			  	c.set_source_rgba(1, 1, 1, 1),
			  	c.translate(if(card_type.cost >= 10, 0.822, 0.840)*w, 0.395*h),
			  	c.text_path(str(card_type.cost)), 
			  	c.fill(),
			  	c.restore(),
			  ]),

			  if(card_type.creature_object != null and card_type.creature_object.is_construct = false, [

				c.set_source_rgba(1,1,1,1),
			  	c.rectangle(0.70*w, h*0.676, w*0.055, h*0.050),
				c.fill(),

				c.set_source_rgba(0,0,0,1),
			  	c.rectangle(0.755*w, h*0.676, w*0.055, h*0.050),
				c.fill(),

				c.save(),

				c.set_source_rgba(0, 0, 0, 1),
				c.translate(w*0.68, h*0.720),
				c.set_font(lib.font.bold_font),
				c.set_font_size(18*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.attack), w*0.09, ['center']),
				c.fill(),

				c.translate(w*0.055, 0.0),
				c.set_source_rgba(1, 1, 1, 1),
				c.set_font_size(18*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.life), w*0.09, ['center']),

				c.fill(),

				c.restore(),

			  ]),

			  //artist
			 if(card_type is class card and card_type.artist != null, [
			 	c.save(),
			 	c.translate(w*0.28, h*0.994),
			 	c.set_font(lib.font.get(lib.font.normal)),
			 	c.set_font_size(9*scaling),
			 	c.set_source_rgba(1, 1, 1, 1),
			 	c.text_path_in_bounds('Art:' + card_type.get_artist.name, w*0.94, ['left']) asserting card_type.get_artist != null,
			 	c.fill(),

			 	c.restore(),
			 ]),

			  [
			    c.save(),
			    c.translate(0.18*w, 0.730*h),
				c.scale(scaling),
			  	map(fragments, [
					c.set_source_rgba(0, 0, 0, 1),

					if(value.tag is list and 'circle' in value.tag, [
						c.save(),
						c.translate(value.y*1.0, 0.0),
						value.path,
						c.set_source_rgba(0.2, 0.2, 0.2, 1),
						c.arc(value.width*0.56,
						      -value.ascent + value.height/2,
							  value.height*0.45, 0, 3.15*2),
						c.fill(),
						c.restore(),

						c.set_source_rgba(1, 1, 1, 1),
					]),

					c.save(),
					c.translate(value.y*1.0, 0.0),
					value.path,
					c.fill(),
					c.restore(),

				]),
				c.restore(),
			  ]

			  where fragments = c.markup_text(q(<font size=') + rules_font_size + q('>) + card_type.rules_text + q(</font>), _rules_text_width*300.0, -2.0),

			  if(card_type.flavor_text = null, [], [
				c.save(),
				c.new_path(),
				c.set_source_rgba(0, 0, 0, 1),
				c.translate(0.28*w, h - flavor_height*scaling - 0.035*h),
				c.scale(scaling),

				map(flavor_fragments, [
					c.save(),
					value.path,
					c.fill(),
					c.restore(),
				]),
				c.restore(),
			  ] 
			    where flavor_height = max(map(flavor_fragments, value.y + value.height)) or 0
			    where flavor_fragments = c.markup_text(q(<font size=') + rules_font_size + q('><i>) + card_type.flavor_text + q(</i></font>), _rules_text_width*210.0)
			  ),

			  //Type of the card
			  c.save(),

			  c.translate(w*0.14, h*0.715),
			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.get(lib.font.normal)),
			  c.set_font_size(calculate_type_font_size()*scaling),
			  c.text_path_in_bounds(_type_text, w*0.94, ['left']),
			  c.fill(),

			  c.restore(),

			  //c.clip(),

/*
			  c.rectangle(0, 0, w, h),
			  c.clip(),
			  c.new_path(),

			  c.set_font(lib.font.regular_font),

			  c.save(),

			  if(_has_dynamic_image = false, [

			  c.set_radial_pattern(100*scaling, 0*scaling, 120*scaling, 100*scaling, 300*scaling, 120*scaling, [
			  { offset: 0 } + card_type.background_color_top,
			  { offset: 1 } + card_type.background_color_bot,
			  ]),
			  c.rectangle(0, h*0.05, w, h*0.75),
			  c.fill(),
			  ]), //end _has_dynamic_image = false
			  
			  c.set_source_rgba(1, 1, 1, 1),
			  c.rectangle(0, h*0.781, w, h*0.199),
			  c.fill(),

			  school_color_gradient(),
			  c.rectangle(0, h*0.98, w, h*0.02),
			  c.fill(),


			  if(card_type is class card and card_type.artist != null, [
				c.save(),
				c.translate(w*0.02, h*0.996),
				c.set_font(lib.font.get(lib.font.normal)),
				c.set_font_size(7*scaling),
				c.set_source_rgba(1, 1, 1, 1),
			    c.text_path_in_bounds('Art:' + card_type.get_artist.name, w*0.94, ['left']) asserting card_type.get_artist != null,
				c.fill(),

				c.restore(),
			  ]),

			  c.set_source_rgba(0, 0, 0, 1),
			  c.set_font_size(card_type.rules_text_font_size),
			  c.translate(0.02*w, 0.790*h),

			  [
			    c.save(),
				c.scale(scaling),
			  	map(fragments, [
					c.set_source_rgba(0, 0, 0, 1),

					if(value.tag is list and 'circle' in value.tag, [
						c.save(),
						value.path,
						c.set_source_rgba(0.2, 0.2, 0.2, 1),
						c.arc(value.width*0.56,
						      -value.ascent + value.height/2,
							  value.height*0.45, 0, 3.15*2),
						c.fill(),
						c.restore(),

						c.set_source_rgba(1, 1, 1, 1),
					]),

					c.save(),
					value.path,
					c.fill(),
					c.restore(),

				]),
				c.restore(),
			  ]

			  where fragments = c.markup_text(q(<font size=') + rules_font_size + q('>) + card_type.rules_text + q(</font>), _rules_text_width*210.0),

			  c.restore(),

			  ] +

			  if(card_type.flavor_text = null, [], [
				c.save(),
				c.new_path(),
				c.set_source_rgba(0, 0, 0, 1),
				c.translate(0.02*w, h - flavor_height*scaling - 0.025*h),
				c.scale(scaling),

				map(flavor_fragments, [
					c.save(),
					value.path,
					c.fill(),
					c.restore(),
				]),
				c.restore(),
			  ] 
			    where flavor_height = max(map(flavor_fragments, value.y + value.height)) or 0
			    where flavor_fragments = c.markup_text(q(<font size=') + rules_font_size + q('><i>) + card_type.flavor_text + q(</i></font>), _rules_text_width*210.0)
			  ) +

			  //the portrait
			  if(card_type.portrait != null and _has_dynamic_image = false,
			  if(dim[0] = 800, 
			  //new style portrait.
			  [
			  c.save(),
			  c.move_to(0, h*0.0),
			  c.line_to(w, h*0.0),
			  c.line_to(w, h*0.741),
			  c.line_to(0, h*0.741),
			  c.clip(),

			  c.new_path(),

			  c.translate(0, h*0.06),
			  c.scale(decimal(w)/dim[0]),
			  c.paint_image('images/portraits/' + card_type.portrait),
			  c.restore(),
			  ],
					  
			  [
			  c.save(),
			  c.translate((w - (dim[0]*(h*0.7)/dim[1]))/2.0, h*0.06),
			  c.scale((h*0.68)/dim[1]),
			  c.paint_image('images/portraits/' + card_type.portrait),
			  c.restore(),

			  ]) where dim = c.image_dim('images/portraits/' + card_type.portrait), []) +

			  //the title area.
			  [

			  school_color_gradient(),

			  c.rectangle(0, 0, w, h*0.06),
			  c.fill(),

			  //Name of the card
			  c.save(),

			  c.translate(w*0.03, h*0.04),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.bold_font),
			  c.set_font_size(14*scaling),
			  c.text_path_in_bounds(card_type.name, w*0.94, ['right']),
			  c.fill(),
			  c.close_path(),

			  c.restore(),

			  //Type of the card
			  c.save(),

			  school_color_gradient(),
			  c.rectangle(0.0*w, h*0.740, w*1.0, h*0.045),
			  c.fill(),

			  if(card_type.creature_object != null and card_type.creature_object.is_construct = false, [

				c.set_source_rgba(1,1,1,1),
			  	c.rectangle(0.79*w, h*0.740, h*0.055, h*0.045),

				c.fill(),

				c.save(),

				c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1),
				c.translate(w*0.79, h*0.776),
				c.set_font(lib.font.bold_font),
				c.set_font_size(16*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.attack), w*0.09, ['center']),
				c.fill(),

				c.set_source_rgba(1, 1, 1, 1),
				c.translate(w*0.1, h*0.0),
				c.set_font_size(16*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.life), w*0.09, ['center']),

				c.fill(),

				c.restore(),
			  ]),

			  c.translate(w*0.02, h*0.775),
			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.get(lib.font.normal)),
			  c.set_font_size(calculate_type_font_size()*scaling),
			  c.text_path_in_bounds(_type_text, w*0.94, ['left']),
			  c.fill(),

			  c.restore(),

			  //rarity.

			  if(card_type is class card and card_type.set != null,
				[
				c.save(),

				c.translate(w*0.05, w*0.055),

				c.set_source_rgba(1, 1, 1, 1),
				c.arc(0, 0, w*0.035, 3.15*0.5, 3.15*1.5),

				c.scale(if(card_type.rarity = 0, -0.6, card_type.rarity = 1, -0.1, 1), 1.0),
				c.arc(0, 0, w*0.035, 3.15*1.5, 3.15*2.5),
				c.fill(),

				c.restore(),
			  ]),

			  school_color_gradient(0.760, 0.978),

			  c.move_to(0.760*w, 0.184*h),
			  c.line_to(0.760*w, 0.116*h),
			  c.line_to(0.869*w, 0.082*h),
			  c.line_to(0.978*w, 0.116*h),
			  c.line_to(0.978*w, 0.184*h),
			  c.line_to(0.869*w, 0.221*h),

			  //c.clip(),

			  //c.new_path(),

			  //c.rectangle(0.760*w, 0.082*h, (0.978-0.760)*w, (0.221-0.082)*h),

			  c.fill(),

			  //c.draw_svg('images/icons/' + icon_name, 0.12*h, 0.12*h) where icon_name = lib.citadel.school_info[value].icon,

			  if(card_type.loyalty_cost, [
			  	c.set_source_rgba(school_info[0].secondary_color[0], school_info[0].secondary_color[1], school_info[0].secondary_color[2], 1.0),
			    c.move_to(0.925*w, 0.211*h),
			    c.line_to(0.979*w, 0.227*h),
			    c.line_to(0.979*w, 0.261*h),
			    c.line_to(0.925*w, 0.277*h),
			    c.line_to(0.871*w, 0.261*h),
			    c.line_to(0.871*w, 0.227*h),
				c.fill(),
			  ]),

			  ] +

			[
			  //The cost of the card.

			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.get(67)),

			  if(_actual_cost > card_type.cost + card_type.loyalty_cost,
			     c.set_source_rgba(1, 0.8, 0.8, 1),
				 _actual_cost < card_type.cost + card_type.loyalty_cost,
			     c.set_source_rgba(0.8, 0.8, 1.0, 1),
			     c.set_source_rgba(1, 1, 1, 1)
			  ),

			  c.set_font_size(36*scaling),
			  c.translate(if(_actual_cost >= 10, 0.782, 0.820)*w, 0.189*h),
			  c.text_path(str(_actual_cost)), 
			  c.fill(),

			  c.restore(),

			  ] +

			  if(card_type.loyalty_cost,
			  [

			  c.save(),
			  c.set_font(lib.font.bold_font),
			  c.set_font_size(22*scaling),
			  c.set_source_rgba(1, 1, 1, 1),
			  c.translate(if(card_type.cost >= 10, 0.862, 0.895)*w, 0.265*h),
			  c.text_path(str(card_type.cost)), 
			  c.fill(),
			  c.restore(),


			  ],

			  []) +
			  
			  //border
			  [
			  	c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				c.rectangle(0, 0, w*0.012, h),
				c.fill(),

				switch(size(school_info),
				1, [c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				c.rectangle(w - w*0.012, 0, w*0.012, h),
				c.fill()],
				2, [c.set_source_rgba(school_info[1].color[0], school_info[1].color[1], school_info[1].color[2], 1.0),
				c.rectangle(w - w*0.012, 0, w*0.012, h),
				c.fill()],
				3, [c.set_source_rgba(school_info[2].color[0], school_info[2].color[1], school_info[2].color[2], 1.0),
				c.rectangle(w - w*0.012, 0, w*0.012, h),
				c.fill()],
				4, [c.set_source_rgba(school_info[3].color[0], school_info[3].color[1], school_info[3].color[2], 1.0),
				c.rectangle(w - w*0.012, 0, w*0.012, h),
				c.fill()],
				5, [c.set_source_rgba(school_info[4].color[0], school_info[4].color[1], school_info[4].color[2], 1.0),
				c.rectangle(w - w*0.012, 0, w*0.012, h),
				c.fill()],
				)
			*/
			  ], { filtering: 'bilinear', mipmaps:4, address_mode: ['clamp', 'clamp'] }

			  
		) where text_color = c.set_source_rgba(card_type.text_color[0], card_type.text_color[1], card_type.text_color[2], 1)
		  where scaling = h/373.0

		  where school_color_gradient = def(decimal begin=0.0, decimal end=1.0) ->cairo_op switch(size(school_info),
				1, c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				2, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.4, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.6, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: end, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				]),
				3, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.25, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.40, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.60, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.75, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: end, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				]),
				4, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.15, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.30, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.45, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.60, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.75, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.90, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: end, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				]),
				5, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.1, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.2, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.3, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.4, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.6, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.7, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: begin + (end-begin)*0.8, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: begin + (end-begin)*0.9, red: school_info[4].color[0], green: school_info[4].color[1], blue: school_info[4].color[2]},
				{offset: end, red: school_info[4].color[0], green: school_info[4].color[1], blue: school_info[4].color[2]},
				]),
			  )
		  where school_info = map(card_type.school_list, lib.citadel.school_info[value])
		  where rules_font_size = calculate_font_size()
		",

		_renderable_attributes: "def() -> [{icon: string, scaling: decimal, text: string, value: int|null, center_x: decimal, center_y: decimal}]
		  map([{icon: string, scaling: decimal, text: string, value: int|null}] <- attributes, value + {
			center_x: if(index < 3, 0.825, 0.64),
			center_y: 0.725 + 0.097*(index%3),
		  })
			where attributes = if(cr = null, [],
			if(cr.range >= 1,
			[{
				text: 'RANGE',
				value: cr.range,
				icon: 'range.svg',
				scaling: 1.2,
			}], []) +
			if(cr.move > 1,
			[{
				text: 'MOVE',
				value: cr.move,
				icon: 'walking-boot.svg',
				scaling: 1.2,
			}], []) +
			if(cr.resistance != 0,
			[{
				text: 'ARMOR',
				value: cr.resistance,
				icon: 'resistance.svg',
				scaling: 1.2,
			}], []) +
		
		[{
			text: ability.text,
			icon: ability.icon,
			scaling: ability.scaling,
		  }
		  asserting ability != null
		  where ability = lib.citadel.ability_info[a] |
		  a <- cr.abilities, a in lib.citadel.ability_info
		])
		where cr = card_type.creature_object
		",

		calculate_type_font_size: "def() ->int
		 find([14,12,11,10,9,8,7,6], extents.width < 192 where extents = c.text_extents(lib.font.regular_font, value, text)) or 5
		  where c = canvas()
		  where text = _type_text
		",

		_type_text: "string ::
		  if(card_type.creature_object != null,
			if(card_type.hero, 'Heroic ', '') + if(card_type.creature_object.is_construct, 'Land', card_type.creature_object.is_building, 'Fortification', 'Creature'),

			if(card_type._class = 'card', 'Invocation', 'Ability')
		  )
			+ if(tags_str, canvas().emdash + tags_str, '')
			 where tags_str = fold(tags, a + ' ' + b, ''),
			 where tags = card_type.tags + if(card_type.is_instant, ['Instant'], []) + if(card_type.is_response, ['Response'], [])

		  ",

		  spawn_flare_particles: "def() ->commands
		  	set(me.particles, lib.particles.create(me, {
				position: [0,0],
				particle_quota: 500000,
				texture: 'particles/flare-128x128.png',
				particle_width: lib.citadel.px(128),
				particle_width: lib.citadel.py(128),

				emitters: [{
					type: 'circle',
					position: [0,0,0],
					emission_rate: 1000.0,
					circle_radius: lib.citadel.px(128),
					direction: [0, 1, 0],
					duration: 100.0,
					repeat_delay: 20,
					time_to_live: 0.1,
					velocity: lib.citadel.px(100),
					angle: { type: 'dyn_random', min: 0.0, max: 360.0 },
					color: [1, 1, 1, 1],
				}]
			})
		  )
		  ",

	},

	on_game_updated: "if(card_needs_rerender, fire_event('init'))",

	on_init: "[
		if(show_back, set(scale, screen_width/1600.0), fire_event('render')),
		set(animated_card_info, if(_has_dynamic_image and card_type.animation_sequence, construct('animated_card', { card: me }))),
	]",

	on_render: "[
		set(animation, tex),
		set(image_texture, image_tex),
		set(texture_width, int<- tex.w),
		set(texture_height, int<- tex.h),
		set(_last_render_key, _calculate_render_key),
	] where tex = query_cache(global_cache(1024), [card_type.internal_id, render_dim, _actual_cost, is_burning], render_card(render_dim[0], render_dim[1]))
	  where render_dim = render_size(card_size)
	  where image_tex = if(card_type.portrait, query_cache(global_cache(256), [card_type.portrait], get_texture('portraits/' + card_type.portrait)))",

	on_being_added: "[
	]",

	on_being_removed: "[
		clear_card_tips()
	]",

	shader: {
		name: "card_render",
		vertex: "
        uniform mat4 u_anura_mvp_matrix;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
		uniform int resolve_cycle;
		uniform int fizzle_cycle;
        varying vec2 v_texcoord;
        void main()
        {
            v_texcoord = a_anura_texcoord;
            gl_Position = u_anura_mvp_matrix * a_anura_vertex;
			if(resolve_cycle > 0) {
				if(v_texcoord[0] > 0.05) {
					gl_Position[0] += float(resolve_cycle)/400.0;
				} else {
					gl_Position[0] -= float(resolve_cycle)/400.0;
				}

				if(v_texcoord[1] > 0.05) {
					gl_Position[1] -= float(resolve_cycle)/200.0;
				} else {
					gl_Position[1] += float(resolve_cycle)/200.0;
				}
			}
        }
		",

		fragment: "
        uniform sampler2D u_anura_tex_map;
        uniform sampler2D u_tex_noise;
        uniform sampler2D u_tex_image;
		uniform vec4 u_color;
		varying vec2 v_texcoord;
		uniform int resolve_cycle;
		uniform int fizzle_cycle;
		uniform vec4 u_anura_sprite_area;
		uniform float u_texture_width;
		uniform float u_texture_height;
		uniform float u_sin_rotate;
		uniform float u_cos_rotate;

		uniform bool u_has_img;
		uniform float u_img_zoom;
		uniform vec2 u_img_target;
		uniform float u_alt_zoom;
		uniform vec2 u_alt_target;
		uniform float u_crossfade_ratio;
        void main()
        {

			float sprite_area_width = u_anura_sprite_area[2] - u_anura_sprite_area[0];
			float sprite_area_height = u_anura_sprite_area[3] - u_anura_sprite_area[1];
			vec4 col = u_color;
			
			gl_FragColor = vec4(0, 0, 0, 0);
			float count = 0.0;
			for(float ypos = -2.0; ypos <= 2.0; ypos += 1.0) {
				for(float xpos = -2.0; xpos <= 2.0; xpos += 1.0) {
					float x = xpos*u_cos_rotate - ypos*u_sin_rotate;
					float y = xpos*u_sin_rotate + ypos*u_cos_rotate;
        			gl_FragColor += texture2D(u_anura_tex_map, v_texcoord + vec2(0.16*x*sprite_area_width/u_texture_width, 0.16*y*sprite_area_height/u_texture_height)) * col;
					count += 1.0;
				}
			}

			gl_FragColor = gl_FragColor/count;

			float u = v_texcoord[0] / sprite_area_width;
			float v = v_texcoord[1] / sprite_area_height;

			float h_dist_center = abs(u - 0.5);
			float v_dist_center = abs(v - 0.5);

			float left_edge = abs(v - 0.5)*0.5 + 0.02;
			float right_edge = 1.0 - left_edge;
			bool in_area = u > left_edge && u < right_edge;

			if(u_has_img && gl_FragColor[3] < 1.0 && v_texcoord[1] >= 0.02 && v_texcoord[1] <= 0.98 && in_area) {

				vec2 img_uv;
				img_uv[0] = v_texcoord[0];
				img_uv[1] = v_texcoord[1];

				vec2 main_uv = mix(img_uv, u_img_target, u_img_zoom);

				vec4 result = vec4(0, 0, 0, 0);
				float count = 0.0;
				float blur_factor = 1.0;
				if(main_uv[1] > 0.7) {
					blur_factor = 3.0;
				}

				for(float ypos = -2.0; ypos <= 2.0; ypos += 1.0) {
					for(float xpos = -2.0; xpos <= 2.0; xpos += 1.0) {
						vec2 uv_pos = main_uv + vec2(blur_factor*xpos/800.0, blur_factor*ypos/996.0);
						uv_pos[0] = (uv_pos[0] - 0.15) / 0.7;
						if(uv_pos[0] < 0.2) {
							uv_pos[0] += (0.2 - uv_pos[0])*0.3;
						} else if(uv_pos[0] > 0.8) {
							uv_pos[0] -= (uv_pos[0] - 0.8)*0.3;
						}

						if(uv_pos[0] < 0.0) {
							uv_pos[0] = -uv_pos[0];
						} else if(uv_pos[0] > 1.0) {
							uv_pos[0] = 2.0 - uv_pos[0];
						}
						result += texture2D(u_tex_image, uv_pos) * col;

						//hack to provide a nice smooth edge to the card.
            			//result[3] += texture2D(u_anura_tex_map, vec2(v_texcoord[0], 0.9) + vec2(0.16*x*sprite_area_width/u_texture_width, 0.16*y*sprite_area_height/u_texture_height))[3] * col[3] - 1.0;
						
						count += 1.0;
					}
				}

				result = result/count;

				if(main_uv[1] > 0.7) {
					result = mix(result, vec4(1,1,1,1), 0.5);
				}

            	gl_FragColor = mix(result, gl_FragColor, gl_FragColor[3]);
				gl_FragColor[3] = 1.0;
			}

			if(resolve_cycle > 0) {
				gl_FragColor[3] *= 1.0 - float(resolve_cycle)/50.0;
			} else if(fizzle_cycle > 0) {
				if(float(fizzle_cycle)/25.0 > texture2D(u_tex_noise, v_texcoord)[0]) {
					gl_FragColor[3] = 0.0;
				}
			}
		}
		",

		create: "[
			set(uniform_commands.u_tex_noise, 1),
			set(uniform_commands.u_tex_image, 2),
			set(uniform_commands.fizzle_cycle, 0),
			set(uniform_commands.resolve_cycle, 0),
			set(parent.noise_texture, tex),
			set(textures, [tex, tex]),
			set(tex.binding_point, 1),
			set(uniform_commands.u_has_img, 0),
		] where tex = load_texture('noise.png')",

		draw: "[
			set(uniform_commands.u_color, color),
			set(uniform_commands.u_texture_width, parent.texture_width),
			set(uniform_commands.u_texture_height, parent.texture_height),
			set(uniform_commands.u_sin_rotate, sin(-parent.rotate)),
			set(uniform_commands.u_cos_rotate, cos(-parent.rotate)),


			if(image_texture, [
				set(uniform_commands.u_has_img, 1),
				set(textures, [textures[0], image_texture]),
				set(image_texture.binding_point, 2),

				if(animated_card_info is class animated_card, [
					set(uniform_commands.u_img_zoom, anim_info.zoom),
					set(uniform_commands.u_img_target, anim_info.focus),

					if(anim_info.cross_fade != null, [
						set(uniform_commands.u_alt_zoom, anim_info.cross_fade.zoom),
						set(uniform_commands.u_alt_target, anim_info.cross_fade.focus),
						set(uniform_commands.u_crossfade_ratio, anim_info.cross_fade.ratio),
					], [
						set(uniform_commands.u_crossfade_ratio, 0.0),
					])
				] where anim_info = animated_card_info.calculate_anim(parent.cycle)
				) where animated_card_info = parent.animated_card_info
				
			]),
		] where image_texture = parent.image_texture",
	},

	effects: [
	
	{
		name: "card_shadow",
		create: "[
			set(uniform_commands.resolve_cycle, 0),
			set(enabled, parent.show_shadow),
			set(attributes, [{name: 'a_texcoord'}, {name: 'a_position'}]),
			set(draw_mode, 'triangle_strip'),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			])),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			uniform int resolve_cycle;
			varying vec2 v_texcoord;
			void main()
			{
				gl_FragColor[0] = 0.0;
				gl_FragColor[1] = 0.0;
				gl_FragColor[2] = 0.0;
				gl_FragColor[3] = 0.5 - float(resolve_cycle)/100.0;

				float u = v_texcoord[0];
				float v = v_texcoord[1];

				float left_edge = abs(v - 0.5)*0.5;
				float right_edge = 1.0 - left_edge;

				float edge = 0.1;

				if(u < left_edge + edge) {
					float ratio = max(0, (u - left_edge)/edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(u > right_edge - edge) {
					float ratio = max(0, (right_edge - u)/edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v < edge) {
					float ratio = v/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v > 1.0 - edge) {
					float ratio = (1.0 - v)/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		draw: "[
			set(attribute_commands.a_position, float_array(
			rotate_rect(parent.mid_x, parent.mid_y, parent.rotate,
			[
				x1, y1, x2, y1, x1, y2, x2, y2
			])))
			   where x1 = parent.mid_x - img_w*0.4
			   where x2 = parent.mid_x + img_w*0.6
			   where y1 = parent.mid_y - img_h*0.4
			   where y2 = parent.mid_y + img_h*0.6
			   where img_w = parent.img_w*parent.scale
			   where img_h = parent.img_h*parent.scale,
		]",
	},

	{
		name: "card_halo",
		create: "[
			set(enabled, false),
			set(attributes, [{name: 'a_texcoord'}, {name: 'a_position'}]),
			set(draw_mode, 'triangle_strip'),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			])),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			varying vec2 v_texcoord;
			uniform float u_edge;
			void main()
			{
				gl_FragColor[0] = 1.0;
				gl_FragColor[1] = 1.0;
				gl_FragColor[2] = 1.0;
				gl_FragColor[3] = 1.0;

				float u = v_texcoord[0];
				float v = v_texcoord[1];

				float left_edge = abs(v - 0.5)*0.5;
				float right_edge = 1.0 - left_edge;

				if(u < left_edge + u_edge) {
					float ratio = max(0, (u - left_edge)/u_edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(u > right_edge - u_edge) {
					float ratio = max(0, (right_edge - u)/u_edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v < u_edge) {
					float ratio = v/u_edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
					} else if(v > 1.0 - u_edge) {
					float ratio = (1.0 - v)/u_edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		//TODO: There seems to be a one-frame lag between when the
		//a_position is updated and when it takes effect. Work out
		//why this is instead of using shader_enabled_at to delay
		//drawing by a frame.
		draw: "[
			set(uniform_commands.u_edge, if(parent.halo_shown, 0.1, 0.02)),

			set(attribute_commands.a_position, float_array(
			rotate_rect(
			parent.mid_x, parent.mid_y, parent.rotate,
			[
			   parent.x-border_size, parent.y-border_size,
			   parent.x2+border_size, parent.y-border_size,
			   parent.x-border_size, parent.y2+border_size,
			   parent.x2+border_size, parent.y2+border_size,
			]))) where border_size = if(parent.halo_shown, parent.img_w/10.0, parent.img_w/50.0),
		]",
	},

	],
}

