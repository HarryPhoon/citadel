{
	is_strict: true,
	"animation": [

		{
			"id": "main",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

		{
			"id": "big",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

		{
			"id": "back",
			"image": "card-back.png",
			"rect": [0,0,145,203],
			scale: 1
		},


	],
	"id": "card",

	always_active: true,

	on_drag_start: "[
		swallow_mouse_event(),
		if(allow_drag, set(drag_pos, [mouse_x, mouse_y])),
		controller.mouse_drag_card_start(me),
	]
	 where mouse_x = int<- arg.mouse_x
	 where mouse_y = int<- arg.mouse_y",

	on_drag: "[
	  swallow_mouse_event(),
	  if(drag_pos and allow_drag, [
		set(drag_pos, [mouse_x, mouse_y]),
		add(x, dx),
		add(y, dy),
		map(draw_primitives, set(value.points,
		       [[points[0][0] + dx, points[0][1] + dy]] +
			   points[1:] where points = [[int]]<- value.points)),

		controller.mouse_drag_card(me),
	] where dx = mouse_x - drag_pos[0]
	  where dy = mouse_y - drag_pos[1])
	]
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",

	on_drag_end: "[
	  set(drag_pos, null),
	  controller.mouse_drag_card_end(me),
	]",

	on_click: "[
		debug('click card: ' + hand_index),
		swallow_mouse_event(),
		if(is_choice,
	       controller.option_clicked(choice_value),
	[
	 switch(mouse_button,
	  1, controller.card_clicked(me),
	  3, controller.card_right_clicked(me))
	])
	] where mouse_button = int<- arg.mouse_button",
/*
	//mouseover_delay: 20,
	on_mouse_enter: "if(not in_hand, controller.mouse_enter_card(me))",
	on_mouse_leave: "if(not in_hand, [
		controller.mouse_leave_card(me),
		if(me.widgets.ability_tooltip, [set(me.widgets.ability_tooltip, null)]),
	])",
	*/

/*
	on_mouse_move: "if(in_hand and tip != null, [
		set(me.widgets.child, create_tooltip_widget(tip)),
	],
	if(me.widgets.ability_tooltip, [set(me.widgets.ability_tooltip, null)])
	)
	  where tip = class tooltip_area|null<-
	    find(tooltips, value.point_in_area(xpos, ypos))
	  where xpos = mouse_x - x
	  where ypos = mouse_y - y
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",
*/
	on_animate_draw: "if(hand_index != null, animate_draw(hand_index*10))",

	on_process: "[
	 if(animation_target != null,
	  if(animation_target.cycles <= 0,
		[
			set(mid_x, animation_target.mid_x),
			set(mid_y, animation_target.mid_y),
			set(rotate, animation_target.rotate),
			set(card_size, animation_target.card_size),
			set(animation_target, null),
		],
		[
			add(animation_target.cycles, -1),
			set(mid_x, int(ratio*animation_target.start_mid_x + (1.0-ratio)*animation_target.mid_x)),
			set(mid_y, int(ratio*animation_target.start_mid_y + (1.0-ratio)*animation_target.mid_y)),
			set(card_size, ratio*animation_target.start_card_size + (1.0-ratio)*animation_target.card_size),
			set(rotate, ratio*animation_target.start_rotate + (1.0-ratio)*animation_target.rotate),
		] where ratio = animation_target.cycles/decimal(animation_target.total_cycles)
		)
	  ),
	  fire_event('check_needs_render'),
	  
	 ]",
	
	on_check_needs_render: "if(card_needs_rerender, fire_event('render'))",

	properties: {

		animation_target: {
			type: "null|{start_rotate: decimal, start_mid_x: int, start_mid_y: int, start_card_size: decimal, total_cycles: int, cycles: int, rotate: decimal, mid_x: int, mid_y: int, card_size: decimal }",
			set_type: "null|{total_cycles: int, cycles: int, rotate: decimal, mid_x: int, mid_y: int, card_size: decimal }",
			set: "if(value = null, set(_data, null),
			      set(_data, value + {start_rotate: rotate, start_mid_x: mid_x, start_mid_y: mid_y, start_card_size: card_size}))"
		},

		play_sound: "def(string|null fname) ->commands
			if(fname != null, sound(fname, lib.citadel.sound_volume(fname)))",

		//State to let us know if anything about the way the card would be
		//drawn has changed and the card needs re-rendering.
		_calculate_render_key: "{resources: [int], card_size: decimal} :: {resources: _loyalty_cost_mask, card_size: card_size}",
		_last_render_key: { type: "{resources: [int], card_size: decimal}|null" },
		card_needs_rerender: "show_back = false and _calculate_render_key != _last_render_key",

		show_back: { type: "bool", default: false },


		tooltips: { type: "[class tooltip_area]", default: [] },

		noise_texture: { type: "null|object" },

		stack_id: { type: "null|int" },

		being_dragged: "bool :: drag_pos != null",
		drag_pos: { type: "null|Loc" },
		choice_value: { type: "null|int|string" },
		is_choice: { default: false },
		sent_discard_msg: { default: false },
		allow_drag: { default: false },

		in_hand: { default: false },
		in_graveyard: { default: false },
		in_opponent_hand: { default: false, set: "[set(_data, value), set(animation, 'back')]" },
		discarded: { default: false },
		hand_index: { type: "null|int" },

		controller: { type: "obj citadel_controller_base" },

		player: { type: "null|class player" },

		clear_widget_tooltips: "def() -> commands set(tooltips, [])",

		add_widget_tooltip: "def(widget w, int x, int y) -> commands [
			if(w.tooltip != null, add(tooltips, [construct('tooltip_area', { area: map([(int<- x) + (int<- (widget<- w).x), y + w.y, w.w, w.h], int(value*size_ratio)), tooltip: w.tooltip})])),
			map(w.children, add_widget_tooltip(value, x + w.x, y + w.y)),
		] where size_ratio = card_size/2.0",

		create_tooltip_widget: "def(class tooltip_area tip) ->object
		widget(me, {
			type: 'dialog',
			id: 'ability_tooltip',
			alpha: 175,
			clear_backround_alpha: 120,
			padding: 0,
			frame_padding: [10,10],
			zorder: 2000,
			cursor:[10, 10],
			x: tip.area[0],
			y: tip.area[1] - 40,
			background_frame: 'empty_window',
			children: [
				{
					type: 'label',
					font: 'RobotoCondensed-Regular',
					alpha: 255,
					size: 16,
					color: 'light_gray',
					text: tip.tooltip,
				}
			],
		})",

		start_fizzle_animation: "def() ->commands
		[
			play_sound(card_type.sound_fizzle),
			set(shader.uniform_commands.fizzle_cycle, {value: 1, increment: true}) asserting shader
		]",
		start_resolve_animation: "def() ->commands execute(me, [
			play_sound(card_type.sound_resolve),
			schedule(5, [set(shader.uniform_commands.resolve_cycle, {value: 1, increment: true}), set(me.effects[0].enabled, false)]),
			set(me.effects[0].enabled, true),
		]) asserting shader",

		show_halo: "def() ->commands if(not effects[0].enabled, [
			set(me.effects[0].enabled, true),
			set(shader_enabled_at, cycle),
		])",
		hide_halo: "def() ->commands if(effects[0].enabled, [
			set(me.effects[0].enabled, false),
		])",

		shader_enabled_at: { default: -1 },

		keep: { default: false },

		render_scale: { type: "int", default: 2, variable: true },
		card_size: { type: "decimal", default: 2.0, variable: true },


		destroy: "def() ->commands [remove_object(me)]",
		animate_draw: "def(int nstagger) ->commands execute(me, [
			set(me.x, -1000), //hack hack! Take it off screen until schedule starts
			set(me.y, -1000),
			map(range(26), schedule(nstagger + value, [
				set(me.x, x + index*(nstagger/10 - 2)),
				set(me.y, y - index*10),
				set(me.alpha, min(255, value*20)),
			] where index = 25 - value)),
		])",

		animate_movement: "def({stagger: int|null, cycles: int|null, scale: [decimal,decimal]|null, mid_x: [int,int], mid_y: [int,int], rotate: [decimal,decimal]|null, at_end: commands|null} anim) ->commands [
			map(range(ncycles+1), schedule(value + nstagger, [
				set(me.mid_x, int(interp(anim.mid_x))),
				set(me.mid_y, int(interp(anim.mid_y))),
				set(me.scale, interp(nscale)),
				set(me.rotate, interp(nrotate)),
				if(index = ncycles, anim.at_end),
			]) where interp = def([decimal,decimal] a) ->decimal
			       a[0]*neg_ratio + a[1]*ratio
			    where neg_ratio = 1.0 - ratio
			    where ratio = decimal(index)/decimal(ncycles))
			
		] where ncycles = if(anim.cycles = null, 10, anim.cycles)
		  where nrotate = if(anim.rotate = null, [rotate,rotate], anim.rotate)
		  where nstagger = if(anim.stagger = null, 0, anim.stagger)
		  where nscale = if(anim.scale = null, [scale,scale], anim.scale)",
		
		animate_from: "def(obj card start, int ncycles) ->commands [
			set(scale, start.scale),
			set(mid_x, start.mid_x),
			set(mid_y, start.mid_y),
			set(rotate, start.rotate),
			me.animate_movement({cycles: ncycles, scale: [start.scale, scale], mid_x: [start.mid_x, mid_x], mid_y: [start.mid_y, mid_y], rotate: [start.rotate, rotate]}),
			
		]",

		set_discarded: "def(bool val) ->commands [if(val,
		  execute(me, [set(discarded, true)]),
		  execute(me, [set(discarded, false)])),
		  debug('SET DISCARDED ' + val),
		  set(me.red, col),
		  set(me.green, col),
		  set(me.blue, col),
		] where col = if(val, 32, 255)
		  ",


		//card_type property which can be a card OR an activated_ability.
		card_type: {
		  type: "class card_base",
		  get: "_data", set: "execute(me, [

				set(_data, value), 
				fire_event('init')
			  ]) asserting value != null"
		},

		_loyalty_cost_mask: "[int] :: map(card_type.school_list, if(player = null, 0, min(player.resource_level[value], card_type.loyalty_cost)))",

		_render_size: "def(decimal size) ->[int,int] [int(size*0.8*209), int(size*0.8*373)]",

		_native_render_sizes: "[[int,int]] :: map([0.8,1.0,2.0], _render_size(value))",

		render_card: "def(int requested_width, int requested_height) ->map {
			id: 'fbo',
			image: 'fbo',
			fbo:  query_cache(global_cache(1024), [card_type.name, w, h, _loyalty_cost_mask],
			 c.render(w, h, [
			  c.set_font('Roboto_Condensed/RobotoCondensed-Regular.ttf'),

			  c.save(),

			  c.set_source_rgba(1, 1, 0.5, 1),
			  c.set_linear_pattern(0, 0, 200, 0,
			  
			  switch(card_type.first_school,
					  
			  FOOD, [
			  { offset: 0, red: 0.25, green: 0.25, blue: 0.15 },
			  { offset: 1, red: 0.45, green: 0.45, blue: 0.4 },
			  ],

			  GOLD, [
			  { offset: 0, red: 0.2, green: 0.2, blue: 0.2 },
			  { offset: 1, red: 0.4, green: 0.4, blue: 0.5 },
			  ],

			  BLOOD, [
			  { offset: 0, red: 0.3, green: 0.15, blue: 0.15 },
			  { offset: 1, red: 0.5, green: 0.35, blue: 0.45 },
			  ],

			  FAITH, [
			  { offset: 0, red: 0.8, green: 0.8, blue: 0.8 },
			  { offset: 1, red: 0.9, green: 0.9, blue: 1.0 },
			  ],

			  SCROLLS, [
			  { offset: 0, red: 0.15, green: 0.15, blue: 0.3 },
			  { offset: 1, red: 0.35, green: 0.35, blue: 0.6 },
			  ],

			  [
			  { offset: 0, red: 0.2, green: 0.2, blue: 0.2 },
			  { offset: 1, red: 0.4, green: 0.4, blue: 0.5 },
			  ],
			  
			  )),
			  c.rectangle(0, 0, w, h*0.05),
			  c.fill(),

			  c.set_radial_pattern(100*scaling, 0*scaling, 120*scaling, 100*scaling, 300*scaling, 120*scaling, [
			  { offset: 0, red: 0.25, green: 0.32, blue: 0.44 },
			  { offset: 1, red: 0.05, green: 0.05, blue: 0.1 },
			  ]),
			  c.rectangle(0, h*0.05, w, h*0.7),
			  c.fill(),
			  
			  c.set_source_rgba(1, 1, 1, 1),
			  c.rectangle(0, h*0.7, w*(1.0 - attr_area + 0.01), h*0.3),
			  c.fill(),


			  c.set_source_rgba(0.7, 0.7, 0.7, 1),
			  c.rectangle(w*(1.0 - attr_area), h*0.7, w*attr_area, h*0.3),
			  c.fill(),

			  c.save(),
			  c.set_source_rgba(0, 0, 0, 1),
			  c.set_font_size(12*scaling),
			  c.translate(0.04*w, 0.75*h),
			  c.show_rich_text_multiline(lib.citadel.process_markup(card_type.rules_text), (0.96 - attr_area)*w, 0.3*h, {svg_scale: 0.025*h/512.0, svg_width: (10.0*h)/512.0}),
			  c.restore(),

			  ] +

			  //the portrait
			  if(card_type.portrait != null, [
			  c.save(),
			  c.translate((w - (dim[0]*(h*0.7)/dim[1]))/2.0, h*0.05),
			  c.scale((h*0.65)/dim[1]),
			  c.paint_image('images/portraits/' + card_type.portrait),
			  c.restore(),

			  ] where dim = c.image_dim('images/portraits/' + card_type.portrait), []) +

			  [

			  //the area showing the type of the card.
			  c.set_source_rgba(1.0, 1.0, 1.0, 0.2),
			  c.rectangle(0, (h*0.66), w, (h*0.04)),
			  c.fill(),

			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.translate(w*0.03, h*0.69),
			  c.set_font_size(12*scaling),
			  c.text_path_in_bounds(_type_text, w*0.94, ['right']),
			  c.fill(),

			  c.restore(),

			  c.set_source_rgba(1, 1, 1, 1),

			  c.set_font('Roboto_Condensed/RobotoCondensed-Bold.ttf'),

			  //The cost of the card.
			  c.set_source_rgba(0.25, 0.25, 0.30, 1),
			  c.arc(0.9*w, 0.1*h, 0.04*h, 0.0, 3.15*2),
			  c.fill(),
			] +

			(fold(map(card_type.school_list, fold(
			  map(range(card_type.loyalty_cost),
			  [
			  c.arc(center_x, center_y, 0.02*h, 0.0, 3.15*2),
			  c.fill(),

			  c.save(),
			  c.translate(center_x - 0.022*w, center_y - 0.012*h),
			  c.scale(0.025*h/512.0),
			  c.draw_svg('images/icons/' + icon_name),
			  c.restore(),
			  ] +
			  
			  if(mask[school_num] > index, [
			    c.set_source_rgba(0.25, 0.25, 0.30, 0.75),
			    c.arc(center_x, center_y, 0.02*h, 0.0, 3.15*2),
			    c.fill(),
			    c.set_source_rgba(0.25, 0.25, 0.30, 1),
			  ], [])
			  
			    where center_x = (0.9 + 0.045 - school_num*0.05)*w
			    where center_y = (0.1 + 0.045 + index*0.035)*h),
			a+b) where icon_name = lib.citadel.school_info[school].icon
			     where school_num = index where school = value), a+b)
			     where mask = _loyalty_cost_mask) +

			[

			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font_size(20*scaling),
			  c.translate(0.878*w, 0.118*h),
			  c.text_path(str(card_type.cost)), 
			  c.fill(),

			  c.restore(),


			  //Name of the card
			  c.save(),

			  c.translate(w*0.03, h*0.035),

			  if(card_type.first_school = FAITH, c.set_source_rgba(0, 0, 0, 1), c.set_source_rgba(1, 1, 1, 1)),
			  c.set_font_size(12*scaling),
			  c.text_path_in_bounds(card_type.name, w*0.94, ['right']),
			  c.fill(),
			  c.close_path(),

			  c.restore(),


			  ] +

			  fold([
			   [
			    c.set_source_rgba(0.25, 0.25, 0.30, 1),
			    c.arc(attr.center_x*w, attr.center_y*h, 0.04*h, 0.0, 3.15*2),
			    c.arc((attr.center_x - 0.045)*w, (attr.center_y-0.025)*h, 0.02*h, 0.0, 3.15*2),
			    c.fill(),

				c.save(),
				c.set_font_size(20*scaling),
				c.translate((attr.center_x - 0.025)*w, (attr.center_y + 0.02)*h),
				c.text_path(str(attr.value)),

			    c.set_source_rgba(1, 1, 1, 1),
				c.fill(),
				c.restore(),

				c.save(),
				c.translate((attr.center_x - 0.064 - (attr.scaling-1.0)*0.015)*w, (attr.center_y-0.036 - (attr.scaling-1.0)*0.01)*h),
				c.scale(attr.scaling*0.02*h/512.0),
				c.draw_svg('images/icons/' + attr.icon),
				c.restore(),
			   ]
			  | attr <- renderable_attr], a+b) +

			  [
			  	c.restore(),
			  ]
			  )) where scaling = h/373.0,
			x: 0, y: 0, w: w, h: h,
			scale: requested_width/decimal(w),
			frames: 1,
		} where attr_area = if(renderable_attr = [], 0.0, if(size(renderable_attr) > 3, 0.36, 0.18))
		  where c = canvas()
		  where renderable_attr = _renderable_attributes()
		  where w = actual_size[0]
		  where h = actual_size[1]
		  where actual_size = find_or_die(_native_render_sizes, value[0] >= requested_width and value[1] >= requested_height or index = size(_native_render_sizes)-1)",

		_renderable_attributes: "def() -> [{icon: string, scaling: decimal, value: int, center_x: decimal, center_y: decimal}]
		  map(attributes, value + {
			center_x: if(index < 3, 0.91, 0.73),
			center_y: 0.759 + 0.093*(index%3),
		  })
			where attributes = if(cr = null, [],
			[
			{
				value: cr.life,
				icon: 'life.svg',
				scaling: 1.4,
			},
			{
				value: cr.attack,
				icon: 'crossed-swords.svg',
				scaling: 1.1,
			},
			] +
			if(cr.range > 1,
			[{
				value: cr.range,
				icon: 'lob-arrow.svg',
				scaling: 1.0,
			}], []) +
			if(cr.move != 0,
			[{
				value: cr.move,
				icon: 'walking-boot.svg',
				scaling: 1.2,
			}], []) +
			if(cr.resistance != 0,
			[{
				value: cr.resistance,
				icon: 'shield.svg',
				scaling: 1.4,
			}], [])
		) where cr = card_type.creature_object
		",

		_type_text: "string ::
		  if(card_type.creature_object != null,
			if(card_type.hero, 'Hero' + canvas().emdash, if(card_type.creature_object.is_construct, 'Construct' + canvas().emdash, 'Creature' + canvas().emdash)) + fold(card_type.creature_object.tags, a + ' ' + b, ''),
			if(card_type._class = 'card', 'Spell', 'Ability') + if(card_type.is_response, canvas().emdash + 'Response', '')
		  )
		  ",

	},

	on_game_updated: "if(card_needs_rerender, fire_event('init'))",

	on_init: "[

		if(not show_back, fire_event('render'))
	]",

	on_render: "[
		set(animation, render_card(_render_size(card_size)[0], _render_size(card_size)[1])),
		set(_last_render_key, _calculate_render_key),
	]",

	shader: {
		program: "card",
		create: "[
			set(uniform_commands.u_tex_map, 0),
			set(uniform_commands.u_tex_noise, 1),
			set(uniform_commands.fizzle_cycle, 0),
			set(uniform_commands.resolve_cycle, 0),
			set(parent.noise_texture, load_texture('images/noise.png')),
		]",

		draw: "[
			set(uniform_commands.u_color, color),
			bind_texture(current_texture, 0),
			bind_texture(parent.noise_texture.id, 1),
		]",
	},

	effects: [{
		name: "card_halo",
		create: "[
			set(enabled, false),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			], 2)),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			varying vec2 v_texcoord;
			void main()
			{
				gl_FragColor[0] = 1.0;
				gl_FragColor[1] = 1.0;
				gl_FragColor[2] = 1.0;
				gl_FragColor[3] = 1.0;

				float edge = 0.1;

				if(v_texcoord[0] < edge) {
					float ratio = v_texcoord[0]/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v_texcoord[0] > 1.0 - edge) {
					float ratio = (1.0 - v_texcoord[0])/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v_texcoord[1] < edge) {
					float ratio = v_texcoord[1]/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v_texcoord[1] > 1.0 - edge) {
					float ratio = (1.0 - v_texcoord[1])/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		//TODO: There seems to be a one-frame lag between when the
		//a_position is updated and when it takes effect. Work out
		//why this is instead of using shader_enabled_at to delay
		//drawing by a frame.
		draw: "[
			set(attribute_commands.a_position, float_array([
			   parent.x-border_size, parent.y-border_size,
			   parent.x2+border_size, parent.y-border_size,
			   parent.x-border_size, parent.y2+border_size,
			   parent.x2+border_size, parent.y2+border_size,
			], 2)) where border_size = parent.img_w/10.0,
			if(parent.cycle > parent.shader_enabled_at,
			   draw_arrays('triangle_strip', 0, 4)),
		]",
	}],

/*
	object_type: [
		{
			id: "loyalty_cost_mask",
			animation: [
				{
					id: "normal",
					"image": "citadel-creatures.png",
					"rect": [0,0,1,1],
					"duration": 50,
					velocity_y: -100,
				}
			],

			zorder: 1000,

			properties: {
				_mask: { type: "[int]" },
				_render_size: { type: "[int,int]" },
				_scale_to: { type: "[int,int]" },
			},

			on_create: "set(animation, {
			id: 'fbo',
			image: 'fbo',
			fbo:  query_cache(global_cache(16), [_render_size, _mask],
			 c.render(w, h,
			 map(_mask,

			 	map(range(value),[
					
				]
			 	) where center_x = (0.9 + 0.045 - school_num*0.05)*w
				  where center_y = (0.1 + 0.045 + index*0.035)*h)

			 where school_num = index)
			 
			 [

			 ]) where c = canvas()),
			x: 0, y: 0, w: w, h: h,
			scale: requested_width/decimal(w),
			frames: 1,
			}) where w = _render_size[0] where h = _render_size[1]"

			fold(map(card_type.school_list, fold(
			  map(range(card_type.loyalty_cost),
			  [
			  c.arc(center_x, center_y, 0.02*h, 0.0, 3.15*2),
			  c.fill(),

			  c.save(),
			  c.translate(center_x - 0.022*w, center_y - 0.012*h),
			  c.scale(0.025*h/512.0),
			  c.draw_svg('images/icons/' + icon_name),
			  c.restore(),
			  ] where center_x = (0.9 + 0.045 - school_num*0.05)*w
			    where center_y = (0.1 + 0.045 + index*0.035)*h),
			a+b) where icon_name = lib.citadel.school_info[school].icon
			     where school_num = index where school = value), a+b) +
		}
	]*/
}
