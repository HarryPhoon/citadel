{
	constructor: "[
		set(me.creature_avatar, construct('creature', {
			name: 'Avatar',
			controller: me.player_index,
			summon_id: 1000000+me.player_index,
			life: 1,
			loc: [-1,-1],
		}))
	]",

	properties: {
		name: "'Player ' + (player_index+1)",
		player_index: { variable: true },
		deck: { variable: true },
		discard_pile: { variable: true, default: [] },

		creature_avatar: { variable: true, default: null },

		//hand can be set as actual card objects, or as strings, which
		//will result in card objects being built.
		hand: { set: "
		  set(private.hand, map(value, if(is_string(value),
		   construct('card', get_document('data/cards.cfg')[value]), value)))",
				variable: true },

		life: { variable: true, default: 3 },

		begin_turn: "def(game) set(me.resources, count(game.villages, value.owner = player_index))",
		end_turn: "def(game) [
			{ execute: q(p.discard_cards(indexes)), arg: { p: me, game: game, indexes: range(size(hand))} },
			{ execute: q(p.draw_cards(game, 5)), arg: { p: me, game: game } }
		]",

		draw_cards: "def(game, ncards) if(num_cards > 0,
		[
		  if(num_cards > size(me.deck),
		  [
			  add(me.hand, deck + new_deck[:nfrom_discard]),
			  set(me.deck, new_deck[nfrom_discard:]),
			  set(me.discard_pile, [])
		  ] where new_deck = shuffle(discard_pile)
		    where nfrom_discard = num_cards - size(deck),
		  [
			add(me.hand, deck[:num_cards]),
			set(me.deck, deck[num_cards:])
		  ]),
		

		  add(game.animation_hints, [{type: 'draw_cards', player_index: player_index, ncards: ncards}])
		]) where num_cards = min(ncards, size(deck) + size(discard_pile))",
		
		discard_cards: "def(card_indexes) if(not is_list(card_indexes),
		me.discard([card_indexes]),
		[
		  map(card_indexes, add(me.discard_pile, [hand[value].name])),
		  set(me.hand, filter(me.hand, not (index in card_indexes))),
		  add(me.resources, size(card_indexes))
		])",

		level_up: "def(school) if(school != 0, add(me.resource_level, {(school): resource_level[school]+1}))",

		resource_level: { variable: true, default: {}, type: 'map' },
		resources: { variable: true, default: 0, type: 'int' },

		calculate_cost: "def(card) actual_cost(card.school, card.cost, card.loyalty_cost)",

		actual_cost: "def(resource_type, cost, loyalty_cost)
		    cost + max(0, loyalty_cost - resource_level[resource_type])",

		can_afford: "def(resource_type, cost, loyalty_cost)
		    resources >= actual_cost(resource_type, cost, loyalty_cost)",

		spend: "def(resource_type, cost, loyalty_cost)
		  add(me.resources, -actual_cost(resource_type, cost, loyalty_cost))",

		summoning_loc_in_row: "def(game, row, nmove=0) 
		  if(creature = null or creature.controller != player_index or
		     (not creature.is_building) or (not creature.summoned),
			 [row, column],
			 summoning_loc_in_row(game, row, nmove+1))
		  where creature = game.creature_at_loc([row,column])
		  where column = if(player_index = 0, nmove, (game.columns-1)-nmove)",

		summoning_locs: "def(game)
		  fold([creature.allows_summoning(game) |
		        creature <- game.creatures, creature.controller = player_index],
				a+b) +
		  filter(map(range(game.rows), summoning_loc_in_row(game, value)), game.creature_at_loc(value) = null)",

		has_possible_response: "def(game) true or //for now always allow responses.
		  //do we have a response card we can play?
		  find(hand, value.is_response and can_afford(value.school, value.cost, value.loyalty_cost)) != null or

		  //do we have a response ability we can play?
		  find(game.creatures,
		       value.controller = player_index and
		       find(value.activated_abilities,
			        value.is_response and can_afford(value.school, value.cost, value.loyalty_cost)) != null) != null
		",

		//suggest which cards to discard so we can play the given card
		suggest_discards: "def(cost, exclude=[]) 
		  if(need <= 0, [], if(need > size(available), null,
		   map(
		     sort(available,
			     actual_cost(a.school, a.cost, a.loyalty_cost) >
			     actual_cost(b.school, b.cost, b.loyalty_cost))[:need],
				index(hand, value))))
			where available = filter(hand, (not value.hero) and
			                               (not (index in exclude)))
		    where need = cost - resources",
	},

	test: [
		{ command: "set(vars.player, construct('player', {}))" },
		{ command: "add(vars.player.resources, 5)",
		  assert: "vars.player.resources = 5" },
		{ assert: "vars.player.can_afford(1, 3, 2)" },
		{ assert: "not vars.player.can_afford(1, 3, 3)" },

		{ command: "vars.player.spend(1, 1, 2)",
		  assert: "vars.player.resources = 2",
		  message: "vars.player.resources" },

		{ assert: "not vars.player.can_afford(1, 1, 2)" },

		{ command: "vars.player.level_up(1)",
		  assert: "vars.player.can_afford(1, 1, 2)" }
	]
}
