{
	private: {
		static_effects: []
	},

	constructor: "[
		set(me.creature_avatar, construct('creature', {
			name: 'Avatar',
			controller: me.player_index,
			summon_id: 1000000+me.player_index,
			life: 1,
			loc: [-1,-1],
		}))
	]",

	properties: {
		name: "'Player ' + (player_index+1)",
		player_index: { variable: true, default: 0 },
		deck: { variable: true },
		discard_pile: { variable: true, default: [] },

		creature_avatar: { variable: true, default: null },

		next_draw_id: { variable: true, default: 1 },

		//hand can be set as actual card objects, or as strings, which
		//will result in card objects being built.
		hand: { variable: true, set: "[
		  add(me.next_draw_id, size(value)),
		  set(private.hand, map(value, if(is_string(value),
		   construct('card', get_document('data/cards.cfg')[value] + {draw_id: next_draw_id + index}), value)))
		] asserting value != null"
		},

		life: { variable: true, default: 3 },

		begin_turn: "def(game) set(me.resources, count(game.villages, value.owner = player_index))",
		end_turn: "def(game, keep_cards) [
			{ execute: q(p.discard_cards(indexes)), arg: { p: me, game: game, indexes: filter(range(size(hand)), not (value in keep_cards))} },
			{ execute: q(p.draw_cards(game, ncards)), arg: { p: me, game: game, ncards: 5 - size(keep_cards) } }
		]",

		no_cards_to_draw: "size(deck) + size(discard_pile) = 0",

		guarantee_deck_size: "def(game, ncards)
			if(size(deck) >= ncards, {deck: deck, discard_pile: discard_pile},
				{
					deck: deck + shuffle(discard_pile),
					discard_pile: []
				}
			)
		",

		draw_cards: "def(game, ncards) if(num_cards > 0,
		[
		  if(num_cards > size(me.deck),
		  [
			  add(me.hand, deck + new_deck[:nfrom_discard]),
			  set(me.deck, new_deck[nfrom_discard:]),
			  set(me.discard_pile, [])
		  ] where new_deck = shuffle(discard_pile)
		    where nfrom_discard = num_cards - size(deck),
		  [
			add(me.hand, deck[:num_cards]),
			set(me.deck, deck[num_cards:])
		  ]),
		

		  add(game.animation_hints, [{type: 'draw_cards', player_index: player_index, ncards: ncards}])
		]) where num_cards = min(ncards, size(deck) + size(discard_pile))",
		
		discard_cards: "def(card_indexes) if(not is_list(card_indexes),
		me.discard([card_indexes]),
		[
		  map(card_indexes, add(me.discard_pile, [hand[value].name])),
		  set(me.hand, filter(me.hand, not (index in card_indexes))),
		  add(me.resources, size(card_indexes))
		])",

		add_static_level_up: "def(school, levels=1) [add(me.resource_level[school], levels), add(private.static_effects, [{fn: def() add(me.resource_level[school], -levels)}])]",
		remove_static_effects: "def() [map(private.static_effects, value.fn()), set(private.static_effects, [])]",

		level_up: "def(school) if(is_list(school), map(school, level_up(value)),
		if(school != 0,
		  if((not resource_level[school]) or xp_level[school]+1 > xp_needed[school],
			[
				add(me.resource_level, {(school): resource_level[school]+1}),
				add(me.xp_needed[school], 1),
				set(me.xp_level[school], 0),
			],
			[
				add(me.xp_level, {(school): xp_level[school]+1})
			])))",

		xp_level: { variable: true, default: {}, type: 'map' },
		xp_needed: { variable: true, default: {}, type: 'map' },
		resource_level: { variable: true, default: {}, type: 'map' },
		resources: { variable: true, default: 0, type: 'int' },

		calculate_cost: "def(card) actual_cost(card.school, card.cost, card.loyalty_cost)",

		actual_cost: "def(resource_types, cost, loyalty_cost)
		    cost + fold(map(resource_types, max(0, loyalty_cost - resource_level[value])), a+b)
			asserting is_list(resource_types), is_int(cost), is_int(loyalty_cost) | [resource_types, cost, loyalty_cost]",

		can_afford: "def(resource_types, cost, loyalty_cost)
		    resources >= actual_cost(resource_types, cost, loyalty_cost)
			  asserting is_list(resource_types), is_int(cost), is_int(loyalty_cost)",

		spend: "def(resource_types, cost, loyalty_cost)
		  add(me.resources, -actual_cost(resource_types, cost, loyalty_cost))",

		summoning_loc_in_row: "def(game, row, nmove=0) 
		  if(creature = null or creature.controller != player_index or
		     (not creature.summoned),
			 [row, column],
			 summoning_loc_in_row(game, row, nmove+1))
		  where creature = game.creature_at_loc([row,column])
		  where column = if(player_index = 0, nmove, (game.columns-1)-nmove)",

		construct_loc_in_row: "def(game, row, nmove=0) 
		  if(creature = null or creature.controller != player_index or
		     (not creature.summoned),
			 [row, column],
			 construct_loc_in_row(game, row, nmove+1))
		  where creature = game.construct_at_loc([row,column])
		  where column = if(player_index = 0, nmove, (game.columns-1)-nmove)",

		summoning_locs: "def(game, target)
		  fold([creature.allows_summoning(game, target) |
		        creature <- game.permanents, creature.controller = player_index],
				a+b) +
		  filter(map(range(game.rows), if(target.is_construct, construct_loc_in_row(game, value), summoning_loc_in_row(game, value))),
		    if(target.is_construct, game.construct_at_loc(value),
					                game.creature_at_loc(value)) = null)",

		has_possible_response: "def(game)
		  //do we have a response card we can play?
		  find(hand, value.is_response and suggest_discards(actual_cost(value.school, value.cost, value.loyalty_cost), [index])) != null or

		  //do we have a response ability we can play?
		  find(game.creatures,
		       value.controller = player_index and
		       find(value.activated_abilities,
			        value.is_response and can_afford(value.school, value.cost, value.loyalty_cost)) != null) != null
		",

		//suggest which cards to discard so we can play the given card
		suggest_discards: "def(cost, exclude=[]) 
		  if(need <= 0, [], if(need > size(available), null,
		   map(
		     sort(available,
			     actual_cost(a.school, a.cost, a.loyalty_cost) >
			     actual_cost(b.school, b.cost, b.loyalty_cost))[:need],
				index(hand, value))))
			where available = filter(hand, (not value.hero) and
			                               (not (index in exclude)))
		    where need = cost - resources",
	},

	test: [
		{ command: "set(vars.player, construct('player', {}))" },
		{ command: "add(vars.player.resources, 5)",
		  assert: "vars.player.resources = 5" },
		{ assert: "vars.player.can_afford([1], 3, 2)" },
		{ assert: "not vars.player.can_afford([1], 3, 3)" },

		{ command: "vars.player.spend([1], 1, 2)",
		  assert: "vars.player.resources = 2",
		  message: "vars.player.resources" },

		{ assert: "not vars.player.can_afford([1], 1, 2)" },

		{ command: "vars.player.level_up(1)",
		  assert: "vars.player.can_afford([1], 1, 2)" }
	]
}
