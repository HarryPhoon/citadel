{
	constructor: "[
		set(me.creature_avatar, construct('creature', {
			name: 'Avatar',
			controller: me.player_index,
			summon_id: 1000000+me.player_index,
			life: 1,
			loc: [-1,-1],
		}))
	]",

	properties: {
		name: { type: "string" },
		player_index: { variable: true, default: 0 },
		team_index: "int :: player_index%2",
		deck: { variable: true, default: [], type: '[string]' },
		deck_submitted: { default: false, type: 'bool' },
		has_ended_turn: { type: 'bool', default: false },
		player_abilities: { variable: true, default: [], type: '[string]' },
		discard_pile: { variable: true, default: [], type: '[string]',
		                set: "[set(me._data, value), if(value = [], set(me.visible_discard_pile, []))]" },

		//subset of cards in the discard pile that are visible.
		visible_discard_pile: { variable: true, default: [], type: '[class card]' },

		creature_avatar: { variable: true, default: null, type: 'class creature' },
		avatar: { type: "string", default: "nyx.png" },

		next_draw_id: { variable: true, default: 1 },

		can_see_enemy_hand: { variable: true, default: 0 },

		_ability_cost_increase: { default: 0, type: "int" },

		//hand can be set as actual card objects, or as strings, which
		//will result in card objects being built.
		hand: { variable: true, default: [], type: '[class card]',
		        set_type: '[class card|string]', set: "[
		  [add(_ability_cost_increase, 1) | c <- value, c is string, c in player_abilities, c != 'Study'],
		  add(me.next_draw_id, size(value)),
		  set(me._data, sort(map(value, if(value is string,
		   construct('card', (map<- (doc[card_name] asserting doc[card_name] | card_name)) + {draw_id: next_draw_id + index} + if(card_name in player_abilities and card_name != 'Study', {cost: (int<- (map<- doc[card_name])['cost']) + _ability_cost_increase}, {}) where doc = lib.json.get_document_map('data/cards.cfg')) where card_name = lib.citadel.actual_card_name(value),
		   value)), (a.is_player_ability and not b.is_player_ability) or a.is_player_ability and b.is_player_ability and a.name < b.name))
		] asserting value != null"
		},

		life: { variable: true, default: 40 },
		creatures_in_citadel: { type: "[class creature]", default: [] },

		hand_size: { variable: true, default: 3 },
		card_draw: { variable: true, default: 4 },

		//if the player has the 'hoard' ability which makes resources not
		//drain at end of turn.
		hoard: { variable: true, default: 0 },

		gain_mana_hint: "def(class game game, Loc src) ->commands [
			add(game.animation_hints, [construct('animation.gain_mana_hint', {type: 'gain_mana', player: player_index, move_from: src})]),
		]",

		gain_mana_with_hint: "def(class game game, Loc src) ->commands [
			gain_mana_hint(game, src),
			add(me.resources, 1),
		]",

		gain_mana_from_card: "def(class game game, class card_base src) ->commands [
			add(game.animation_hints, [construct('animation.gain_mana_hint', {type: 'gain_mana', player: player_index, card_from: src.draw_id})]),
			add(me.resources, 1),
		]",

		base_income: { type: "int", default: 3 },

		calculate_income: "def(class game game) -> int base_income + sum(map(filter(game.permanents, value.controller = player_index), value.income(game)))",
		calculate_card_draw: "def(class game game) -> int card_draw + sum(map(filter(game.permanents, value.controller = player_index), value.card_draw(game)))",

		begin_turn: "def(class game game) ->commands [
			set(has_ended_turn, false),

			//add(me.life, -size(creatures_in_citadel)),
			bind_command(remove_static_effects, DURATION_BEGINNING_NEXT_TURN),

			if(game.nturn != 0 or player_index != 0, bind_command(draw_cards, game, calculate_card_draw(game) - size(hand))),
			bind_command(restore_ability_cards, game),
			bind_command(remove_static_effects, DURATION_END_OF_TURN),
			if(hoard = 0, set(me.resources, 0)),

			//gain income.
			add(me.resources, calculate_income(game)),

			map(filter(game.permanents, value.controller = player_index and value.income > 0), gain_mana_hint(game, value.loc)),
		]",
		end_turn: "def(class game game) ->commands [
			add(base_income, 1),
		]",

		no_cards_to_draw: "size(deck) + size(discard_pile) = 0",

		guarantee_deck_size: "def(class game game, int ncards) ->class util.deck_state
			if(size(deck) >= ncards,
				construct('util.deck_state', {
					deck: deck,
					discard_pile: discard_pile,
				}),
				construct('util.deck_state', {
					deck: deck + shuffle(discard_pile),
					discard_pile: [],
				})
			)
		",

		restore_ability_cards: "def(class game game) ->commands
		[
		if(find(hand, value.name = ability) = null,
		[
			set(hand, [ability] + hand)
		]) | ability <- player_abilities]",

		draw_cards: "def(class game game, int ncards) ->commands
		if(num_cards > 0,
		[
		  if(num_cards > size(me.deck),
		  [
			  add(me.hand, game.tutorial.modify_card_draw(game, me, deck)),
			  set(me.deck, []),
		  ],

		  [
			add(me.hand, game.tutorial.modify_card_draw(game, me, deck[:num_cards])),
			set(me.deck, deck[num_cards:])
		  ]),
		

		  add(game.animation_hints, [construct('animation.draw_cards_hint', {type: 'draw_cards', player: player_index, ncards: ncards})])
		], if(game.tutorial,
		    add(me.hand, game.tutorial.modify_card_draw(game, me, []))
		   )
		) where num_cards = min(ncards, size(deck) + size(discard_pile))",
		
		discard_cards: "def(class game game, [int] card_indexes) ->commands
		[
		  map(card_indexes, add(me.discard_pile, [hand[value].name])),
		  set(me.hand, filter(me.hand, not (index in card_indexes))),

		  map(card_indexes, gain_mana_from_card(game, hand[value])),
		]",

		discard_visible: "def(class card card) ->commands
		[
			add(me.discard_pile, [card.name]),
			add(me.visible_discard_pile, [card]),
		]",

		add_static_level_up: "def(int school, int levels=1) ->commands [
			add_static_effect(
			    construct('static_effect', {
					apply_fn:  (def(class player p, map info) ->commands add(p.resource_level[int<- info.school], int<- info.levels)),
					revert_fn: (def(class player p, map info) ->commands add(p.resource_level[int<- info.school], -(int<- info.levels))),
					info: { school: school, levels: levels },
				}))
		]",

		add_static_cost_filter: "def(class cost_filter new_filter) ->commands [
			add(me.static_cost_filters, [new_filter])
		]",

		remove_static_effects: "def(int duration=DURATION_STATIC) ->commands [
			[if(effect.revert_fn, effect.revert_fn(me, effect.info)) | effect <- me.static_effects, effect.duration = duration],
			set(me.static_effects, filter(me.static_effects, value.duration != duration)),

			if(duration = DURATION_STATIC, set(me.static_cost_filters, [])),
		]",

		add_static_effect: "def(class static_effect effect) ->commands [
			if(effect.apply_fn, effect.apply_fn(me, effect.info)),
			add(me.static_effects, [effect]),
		]",

		apply_static_effect: "def(function(class player, map) ->commands apply, function(class player, map) ->commands revert, map info, int duration=DURATION_STATIC) ->commands [
			add_static_effect(construct('static_effect', {apply_fn: apply, revert_fn: revert, info: info, duration: duration}))
		]",

		static_effects: { default: [], type: '[class static_effect]' },

		level_up: "overload(
		  def([int] schools) ->commands map(schools, level_up(value)),
		  def(int school) ->commands bind_command(level_up_internal, school)
		)",

		level_up_internal: "def(int school) ->commands
		if(school != 0,
		  if(xp_level[school]+1 >= xp_needed[school],
			[
				add(me.resource_level[school], 1),
				add(me.xp_needed[school], 1),
				set(me.xp_level[school], 0),
			],
			[
				add(me.xp_level[school], 1)
			])
		  )",

		xp_level: { default: '@eval {1:0,2:0,3:0,4:0,5:0}', type: '{int -> int}' },
		xp_needed: { default: '@eval {1:1,2:1,3:1,4:1,5:1}', type: '{int -> int}' },
		resource_level: { default: '@eval {1:0,2:0,3:0,4:0,5:0}', type: '{int -> int}' },
		resources: { variable: true, default: 3, type: 'int' },

		static_cost_filters: { type: "[class cost_filter]", default: [] },

		_run_cost_filters: "def(class card_base card, int cost, [class cost_filter] filters) ->int
		  if(filters = [], cost, _run_cost_filters(card, filters[0].filter_cost(me, card, cost), filters[1:]))",

		calculate_cost: "def(class card_base card) ->int
		  _run_cost_filters(card, actual_cost(card.school, card.cost, card.loyalty_cost), static_cost_filters)",

		actual_cost: "def([int] resource_types, int cost, int loyalty_cost) ->int
		    cost + fold(map(resource_types, max(0, loyalty_cost - resource_level[value])), a+b)
			asserting is_list(resource_types), is_int(cost), is_int(loyalty_cost) | [resource_types, cost, loyalty_cost]",

		can_afford: "def(class card_base card) ->bool
		    resources >= calculate_cost(card)",

		spend: "def(class card_base card) ->commands
		  add(me.resources, -calculate_cost(card))",

		//we can summon in front of any buildings we control.
		summoning_loc_in_row: "def(class game game, int row, int nmove=0) -> Loc
		  if(creature = null or creature.controller != team_index or
		     (not creature.summoned) or creature.is_building = false,
			 [row, column],
			 summoning_loc_in_row(game, row, nmove+1))
		  where creature = game.creature_at_loc([row,column])
		  where column = if(team_index = 0, lane.begin + nmove, lane.begin + lane.length - 1 - nmove)
		  where lane = game.lanes[row]
		  ",


		construct_loc_in_row: "def(class game game, int row, int nmove=0) ->Loc
		  if(creature = null or creature.controller != team_index or
		     (not creature.summoned),
			 [row, column],
			 construct_loc_in_row(game, row, nmove+1))
		  where creature = game.construct_at_loc([row,column])
		  where column = if(team_index = 0, lane.begin + nmove, lane.begin + lane.length - 1 - nmove)
		  where lane = game.lanes[row]
		  ",

		summoning_locs: "def(class game game, class creature target) ->[Loc]
		 if(target.hero and count(game.creatures, value.hero and value.controller = player_index and value.name = target.name) > 0, [], //hero duplicate check, not summonable.
		 
		 filter(

		  fold([creature.allows_summoning(game, target) |
		        creature <- game.permanents, creature.controller = player_index],
				a+b) +
		  filter(map(range(game.rows), if(target.is_construct, construct_loc_in_row(game, value), summoning_loc_in_row(game, value))),
		    if(target.is_construct, game.construct_at_loc(value),
					                game.creature_at_loc(value)) = null),

			//filter for the game rule that you can never summon onto
			//a tile that an enemy creature is on.
			(creature_at_loc = null or creature_at_loc.controller = player_index)
			where creature_at_loc = game.creature_at_loc(value))
		)",

		has_possible_play: "def(class game game) ->bool
		if(game.in_response_phase, has_possible_response(game),
			//do we have a card in hand we can play?
			find(hand, calculate_cost(value) <= resources) != null or

			//do we have a creature with an activated ability we can use?
			find(game.creatures,
			     value.controller = player_index and
				 find(value.activated_abilities, calculate_cost(value) <= resources) != null) != null
		)
		",

		has_possible_response: "def(class game game) ->bool
		  if(game.stack != [] and msg is class message.play_card and msg.card != null and msg.card.is_cantrip where msg = back(game.stack),
		  false,
		  //do we have a response card we can play?
		  find(hand, value.is_response and can_afford(value) and value.possible_targets(game, game.nplayer, []) != []) != null or

		  //do we have a response ability we can use?
		  find(game.creatures,
		       value.controller = player_index and
		       find(value.activated_abilities,
			        value.is_response and can_afford(value)) != null) != null
		)
		",
	},

	test: [
		{ command: "set(vars.player, construct('player', { name: 'test', hand: [] }))" },
		{ command: "add(vars.player.resources, 5)",
		  assert: "vars.player.resources = 8" },
	]
}
