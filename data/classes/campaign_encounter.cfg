//This class contains the data for an encounter within the campaign
//mode of the game. An encounter consists of an image, some text,
//and options for the player. When the player selects an option,
//the choose_option function will execute, which will implement the
//outcome for that option.
{
	title: { type: "string", default: '' },

	//The image to display. TODO: We might want to have image manipulation
	//like panning/zooming/animation/color modification/etc.
	image: { type: "string", default: '' },

	image_area: { type: "null|[decimal,decimal,decimal,decimal]" },
	next_image_area: { type: "null|[decimal,decimal,decimal,decimal]" },

	image_focus_x: { type: "decimal", default: 400.0 },
	image_focus_y: { type: "decimal", default: 200.0 },
	image_zoom: { type: "decimal", default: 1.0 },

	next_image_focus_x: { type: "null|decimal" },
	next_image_focus_y: { type: "null|decimal" },
	next_image_zoom: { type: "null|decimal" },

	image_animate_time: { type: "int", default: 20 },
	image_animate_easing: { type: "null|function(decimal)->decimal" },

	image_transition: { type: "null|enum {fade}", init: "enum fade" },
	image_transition_time: { type: "int", default: 20 },

	//The main text to display.
	text: { type: "string", default: "" },

	//The scenario to make the player face. This will generally start as
	//null, set it to a scenario in choose_option when the option they
	//have chosen will cause them to enter a fight.
	scenario: {
		type: "null|Scenario",
		set: "
			set(_data, if(value, Scenario<- (if(map is string, lib.maps.get_map(map), {}) + value)))
		",
	},

	map: { type: "null|string" },

	//A list of the possible options the player can click.
	options: { type: "[string]", get: "if(_options != null, map(_options, value.text), _data)", default: [] },

	_options: { type: "null|[{ text: string, goto: string|null }]" },

	//A tag we can easily use for the current state. Allows us to distinguish
	//between different options where needed.
	tag: { type: "string", default: "start" },

	//any random vars to store.
	vars: { type: "{string -> any}", default: {} },

	//Set this to true in choose_option when the encounter is done
	//and should be closed.
	finished: { type: "bool", default: false },

	quest_id: { type: "null|string" },

	min_quest_progress: { type: "int", default: 0 },
	max_quest_progress: { type: "int", default: 100 },

	filter_encounter: "def() ->bool true",

	location: { type: "null|string|[string]" },

	once_only: { type: "bool", default: false },
	prerequisite: { type: "null|string" },

	//The function that controls what happens when an encounter option
	//is chosen. It can modify the image/text/scenario/options/finished fields
	//as needed. It gets access to the title_controller object which has
	//access to everything in the game so it can modify whatever it needs
	//to to get its thing done.
	choose_option: "def(obj title_controller ctrl, string option) ->commands
	if(_options != null,
		if(op != null and op.goto is string, set(node, op.goto))
		where op = find(_options, value.text = option)
	)
	",

	win_battle: "def(obj title_controller ctrl) ->commands
	if(_options != null,
		if(op != null and op.goto is string, set(node, op.goto))
		where op = find(_options, value.text = 'Victory')
	)
	",

	lose_battle: "def(obj title_controller ctrl) ->commands
	if(_options != null,
		if(op != null and op.goto is string, set(node, op.goto))
		where op = find(_options, value.text = 'Defeat')
	)
	",

	set_node: "def(CampaignDialogNode nd) ->commands [
		set(text, nd.text),
		set(_options, nd.options),
		if(nd.image, set(image, nd.image)),
		if(nd.image_area, set(image_area, nd.image_area)),
		if(nd.next_image_area, set(next_image_area, nd.next_image_area)),
		if(nd.image_animate_time, set(image_animate_time, nd.image_animate_time)),
		if(nd.image_transition_time, set(image_transition_time, nd.image_transition_time)),

		set(map, nd.map),
		if(nd.battle != null, set(scenario, nd.battle)),

		if(nd.image_animate_easing != null, set(image_animate_easing, lib.easing.get(nd.image_animate_easing))),
	]",

	node: {
		type: "string",
		default: "",
		set: "[
			set_node(lib.campaign_encounter.get_campaign_dialog_node(value))
		]",
	},

	campaign_doc: {
		type: "{string->map}",
		init: "{string->map}<- get_document('data/campaign-dialog.cfg')",
		set: "[
			write_document('data/campaign-dialog.cfg', value, [enum game_dir]),
			set(_data, value),
		]",
	},

	get_campaign_dialog_node: "def(string name) ->CampaignDialogNode
	CampaignDialogNode<-
	(if(res, res, campaign_doc['default']) + {id: name})
	    where res = campaign_doc[name]
	",

	save_campaign_dialog_node: "def(CampaignDialogNode node) ->commands
	set(campaign_doc, campaign_doc + {(node.id): node})
	",
}
