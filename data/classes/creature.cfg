{
	private: {
		//temporary modifications to a creature.
		static_effects: [],
		this_turn_effects: [],
		this_turn_abilities: [],

		abilities: [],

		triggered_abilities: [],

		//record the last turn damage was dealt to us and a list of creatures
		//that inflicted damage on us.
		damage_dealt_turn: -1,
		damage_dealt_by: {}, //maps creatures to amounts.
	},

	properties: {
		summon_id: { variable: true, default: 0 }, //unique within a game.
		name: { variable: true },
		school: { variable: true, default: 0 },

		overlays: { variable: true, default: [] },

		summoning_time: { variable: true, default: 1 },
		summoning_counters: { variable: true, default: 0 },

		increment_summoning: "add(me.summoning_counters, 1)",
		summoned: "summoning_counters >= summoning_time",

		is_building: "false",

		tags: { variable: true, default: [] },

		abilities: { get: "private.abilities",
		             set: "set(private.abilities,
					        map(value, if(is_map(value), construct('activated_ability', value), value)))" },

		triggered_abilities: { get: "private.triggered_abilities",
		             set: "set(private.triggered_abilities,
					        map(value, if(is_map(value), construct('triggered_ability', value), value)))" },

		image_num: { variable: true, default: 0 },

		range: { variable: true, default: 1 },
		attack: { variable: true, default: 0 },
		life: { variable: true, default: 1 },
		move: { variable: true, default: 0 },
		move_left_this_turn: { variable: true, default: 0 },
		initiative: { variable: true, default: 1 },

		resistance: { variable: true, default: 0 },

		resistance_against: "def(game, attacker, damage) me.resistance",

		level: { variable: true, default: 0 },

		reached_endzone: { variable: true, default: false },

		on_summoned: "def(game) null",

		on_deal_damage: "def(game, target, damage) 
			map(me.abilities, switch(value, 'Life Drain', if(not target.is_building, add(me.wounds, -damage))))",

		inflict_combat_damage: "def(game, attacker, damage) if(damage_dealt > 0,
		    [add(me.wounds, damage_dealt),
			 attacker.fire_event('on_deal_damage', [game, me, damage]),
			 if(private.damage_dealt_turn = game.turn,
			    private.damage_dealt_by + {
				  str(attacker.summon_id): damage_dealt + private.damage_dealt_by[str(attacker.summon_id)]
				},
				[set(private.damage_dealt_turn, game.turn),
				 set(private.damage_dealt_by, {str(attacker.summon_id): damage_dealt})]
			   )])
		  where damage_dealt = damage - me.resistance_against(game, attacker, damage)",

		hit_by_this_turn: "def(game) if(private.damage_dealt_turn = game.turn, map(private.damage_dealt_by, key), [])",

		on_kill: "def(game, victim) null",
		on_another_creature_died: "def(game, victim) null",

		on_die: "def(game) [
		   map(game.creatures, value.fire_event('on_another_creature_died', [game, me])),
		   map(hit_by_this_turn(game), if(killer, killer.fire_event('on_kill', [game, me])) where killer = find(game.creatures, context.value = str(value.summon_id)))
		   ]",

		on_reach_endzone: "def(game) [
			set(me.reached_endzone, true),
			add(game.players[if(controller = 0, 1, 0)].life, -1)
		]",

		wounds: { variable: true, set: "set(private.wounds, max(0, value))", default: 0 },

		alive: "life > wounds",

		loc: { variable: true, default: null },

		controller: { variable: true, default: -1 },

		stats_label_size: "18",
		
		on_moved_over: "def(game, creature) null",

		//formula which takes {creature, target, game} argument and applies the
		//static effect on the target.
		static_ability_effect: { variable: true, default: null },

		apply_static_abilities: "def(game) [
		if(wounds < 0, set(wounds, 0)),
		if(me.static_ability_effect,
		    [map(game.creatures, eval_no_recover(me.static_ability_effect, {creature: me, target: value, game: game}))])]",

		apply_static_effect: "def(attr, delta) [add(me[attr], delta), add(private.static_effects, [{attr: attr, delta: delta}])]",

		remove_static_effects: "def() [map(private.static_effects, add(me[value.attr], -value.delta)), set(private.static_effects, [])]",

		apply_effect_until_end_of_turn: "def(attr, delta) [add(me[attr], delta), add(private.this_turn_effects, [{attr: attr, delta: delta}])]",

		add_ability_until_end_of_turn: "def(ability) [
		  add(private.this_turn_abilities, [size(private.abilities)]),
		  add(private.abilities, [ability])
		]",

		fire_event: "def(event_name, args) [
		  call(query(me, event_name), args),
		  [ call(query(ability, event_name), [me] + args) |
		    ability <- triggered_abilities, not is_string(ability)]
		]",

		on_begin_turn: "def(game) null",

		on_end_turn: "def(game) [
		 map(private.this_turn_effects, add(me[value.attr], -value.delta)),
		 set(private.this_turn_effects, []),
		 set(private.abilities, filter(private.abilities, not (index in private.this_turn_abilities))),
		 set(private.this_turn_abilities, [])]",

		do_move: "def(game) do_move_internal(game, find_blocker(game, 1, move), 0)",
		do_move_remaining: "def(game) [do_move_internal(game, find_blocker(game, 1, move_left_this_turn), move - move_left_this_turn), debug('move_left_this_turn 1', move - move_left_this_turn),]",

		do_move_internal: "def(game, move_spaces, moves_used) if(move_spaces = 0, null,
		  [if(creature != null, [debug('fire on_moved_over'), creature.fire_event('on_moved_over', [game, me]), me.fire_event('on_moved_over', [game, creature]), do_move_internal(game, move_spaces-1, moves_used+1)],
		  if((game.is_loc_on_board(target_loc) or game.is_loc_in_endzone(target_loc, controller)),
			  [
			  map(range(1, move_spaces+1), game.capture(
			    [loc[0], loc[1] + value*direction_moving], if(is_marauder, -1, controller), if(is_marauder, -1, school))) where is_marauder = ('Marauder' in abilities),
			  set(me.loc, target_loc),
			  set(move_left_this_turn, move - moves_used),
			  debug('move_left_this_turn 1', move - moves_used),
			  ], do_move_internal(game, move_spaces-1, moves_used+1)
		  ))]
		  where creature = game.creature_at_loc(target_loc)
		  where target_loc = [loc[0], loc[1] + move_spaces*direction_moving])",

		do_attack: "def(game) map(search_directions, if(target != null, target.inflict_combat_damage(game, me, attack)) where target = find_target(game, value, value*range))
		
		  //we want to attack in both directions if we're neutral, otherwise
		  //attack in the direction we're going.
		  where search_directions = if(controller = -1, [-1,1], [direction_moving])",

		find_target: "def(game, moves_ahead, max_moves)
		  if(potential != null and potential.controller != me.controller, potential, if(moves_ahead = max_moves, null, find_target(game, moves_ahead + sign(moves_ahead), max_moves)))
		  where potential = game.summoned_creature_at_loc([loc[0], loc[1] + moves_ahead])",

		find_blocker: "def(game, moves_ahead, max_moves)
		   if(blocking_creature != null and blocking_creature.controller != me.controller and ('Flying' in blocking_creature.abilities) = ('Flying' in me.abilities) , moves_ahead, if(moves_ahead+1 < max_moves, find_blocker(game, moves_ahead+1, max_moves), max_moves))
		   where blocking_creature = game.summoned_creature_at_loc([loc[0], loc[1] + moves_ahead*direction_moving])",

		transform: "def(game, new_type) [
		  set(game.creatures, filter(game.creatures, value.summon_id != me.summon_id) + [new_creature]),

		  set(new_creature.wounds, me.wounds),
		  set(new_creature.loc, me.loc),
		  set(new_creature.controller, me.controller),
		  set(new_creature.summon_id, me.summon_id)
		] where new_creature = construct('creature', new_type)",

		direction_moving: "if(controller = 1, -1, 1)",

		//has an enemy immediately in front
		is_engaged: "def(game) enemy != null and enemy.controller != controller
		     where enemy = game.summoned_creature_at_loc(
			                      [loc[0], loc[1] + direction_moving])",

		gui_stats_grid: "
		 	{
				type: 'grid',
				padding: [10,10],
				columns: 2,
				x: 40,
				y: 0,
				children: [] +

				if((not is_building) or attack > 0,
				[
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [40,0,47,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(attack),
						size: stats_label_size,
					},
				], []) +

				if(range > 1, [
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [24,0,31,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(range),
						size: stats_label_size,
					},
				], []) +

				if(resistance != 0, [
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: if(resistance < 0, [8,0,15,7], [16,0,23,7]),
					},

					{
						type: 'label',
						color: if(resistance < 0, 'red', 'black'),
						border_color: 'white',
						text: str(resistance),
						size: stats_label_size,
					},
				], []) +

				if((not is_building) or move > 0,
				[
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [32,0,39,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(move),
						size: stats_label_size,
					},
				], []) +

				if(is_building or level > 0, [
					{
						type: 'image',
						image: 'citadel-buildings.png',
						area: [117 + 9*level,3,126 + 9*level,12],
					},

					{
						type: 'label',
						color: 'black',
						text: '',
						size: 12,
					}
				], [])
			}
		"
	},
}
