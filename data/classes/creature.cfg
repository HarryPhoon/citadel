{
	private: {
		//temporary modifications to a creature.
		static_effects: [],
		static_abilities: [],
		this_turn_effects: [],
		this_turn_abilities: [],

		abilities: [],

		triggered_abilities: [],

		//record the last turn damage was dealt to us and a list of creatures
		//that inflicted damage on us.
		damage_dealt_turn: -1,
		damage_dealt_by: {}, //maps creatures to amounts.
		destroyed: false,
		ability_id: 1,
	},

	properties: {
		summon_id: { variable: true, default: 0 }, //unique within a game.
		name: { variable: true },
		school: { variable: true, default: 0 },

		death_animation_hint: { variable: true },
		attack_hint: { variable: true, default: { turn: -1, attacks: [] } },

		overlays: { variable: true, default: [] },

		summoning_time: { variable: true, default: 1 },
		summoning_counters: { variable: true, default: 0 },

		increment_summoning: "add(me.summoning_counters, 1)",
		summoned: "summoning_counters >= summoning_time",

		is_building: "false",

		tags: { variable: true, default: [] },

		abilities: { get: "private.abilities",
		             set: "set(private.abilities,
					        map(value, if(is_map(value), construct('activated_ability', value), value)))" },

		activated_abilities: "filter(abilities, not is_string(value))",

		triggered_abilities: { get: "private.triggered_abilities",
		             set: "set(private.triggered_abilities,
					        map(value, if(is_map(value), construct('triggered_ability', value), value)))" },

		sprite_sheet: { variable: true, default: null },
		image_num: { variable: true, default: 0 },

		range: { variable: true, default: 1 },
		attack: { variable: true, default: 0 },
		life: { variable: true, default: 1 },
		move: { variable: true, default: 0 },
		spaces_moved_this_turn: { variable: true, default: 0 },
		initiative: { variable: true, default: 1 },

		resistance: { variable: true, default: 0 },

		resistance_against: "def(game, attacker, damage) me.resistance",

		level: { variable: true, default: 0 },

		reached_endzone: { variable: true, default: false },

		is_valid_target: "def(game, nplayer, obj)
		    not (nplayer != controller and has_cover(game))",

		has_cover: "def(game) ('Cover' in abilities) or
		 (game.terrain_at_loc(loc) = 'forest' and not ('Flying' in abilities))",

		on_summoned: "def(game) null",

		on_deal_damage: "def(game, target, damage) 
			map(me.abilities, switch(value, 'Life Drain', if(not target.is_building, add(me.wounds, -damage))))",

		inflict_combat_damage: "def(game, attacker, damage) if(damage_dealt > 0,
		    [add(me.wounds, damage_dealt),
			 attacker.fire_event('on_deal_damage', [game, me, damage]),
			 if(private.damage_dealt_turn = game.turn,
			    private.damage_dealt_by + {
				  str(attacker.summon_id): damage_dealt + private.damage_dealt_by[str(attacker.summon_id)]
				},
				[set(private.damage_dealt_turn, game.turn),
				 set(private.damage_dealt_by, {str(attacker.summon_id): damage_dealt})]
			   )])
		  where damage_dealt = damage - me.resistance_against(game, attacker, damage)",

		hit_by_this_turn: "def(game) if(private.damage_dealt_turn = game.turn, map(private.damage_dealt_by, key), [])",

		on_kill: "def(game, victim) null",
		on_another_creature_died: "def(game, victim) null",

		on_die: "def(game) null",

		fire_events_on_death: "def(game) [
		   map(game.creatures, value.fire_event('on_another_creature_died', [game, me])),
		   map(hit_by_this_turn(game), if(killer, killer.fire_event('on_kill', [game, me])) where killer = find(game.creatures, context.value = str(value.summon_id)))
		   ]",

		on_reach_endzone: "def(game) [
			set(me.reached_endzone, true),
			add(game.players[if(controller = 0, 1, 0)].life, -1)
		]",

		wounds: { variable: true, set: "set(private.wounds, max(0, value))", default: 0 },

		destroyed: { get: "alive", set: "set(private.destroyed, true)" },
		alive: "life > wounds and not private.destroyed",

		loc: { variable: true, default: null },

		controller: { variable: true, default: -1 },

		stats_label_size: "18",
		
		on_moved_over: "def(game, creature) null",
		on_move: "def(game) null",

		//formula which takes {creature, target, game} argument and applies the
		//static effect on the target.
		static_ability_effect: { variable: true, default: null },

		apply_static_abilities: "def(game) [
		if(wounds < 0, set(wounds, 0)),
		if(me.static_ability_effect,
		    [map(game.creatures, eval_no_recover(me.static_ability_effect, {creature: me, target: value, game: game}))])]",

		apply_static_effect: "def(attr, delta) [add(me[attr], delta), add(private.static_effects, [{attr: attr, delta: delta}])]",

		remove_static_effects: "def() [
		   map(private.static_effects, add(me[value.attr], -value.delta)),
		   set(private.static_effects, []),
		   set(private.abilities, remove_abilities(private.abilities, private.static_abilities)),
		   set(private.static_abilities, [])]",

		add_ability_static_duration: "def(ability)
		if(is_string(ability), [
		  add(private.static_abilities, [ability]),
		  add(private.abilities, [ability])
		],
		[
		  add(private.static_abilities, [ability_id]),
		  add(private.abilities, [ability + {unique_id: ability_id}])
		]
		)",


		apply_effect_until_end_of_turn: "def(attr, delta) [add(me[attr], delta), add(private.this_turn_effects, [{attr: attr, delta: delta}])]",

		add_ability_until_end_of_turn: "def(ability) 
		if(is_string(ability), [
		  add(private.this_turn_abilities, [ability]),
		  add(private.abilities, [ability])
		],
		[
		  add(private.this_turn_abilities, [ability_id]),
		  add(private.abilities, [ability + {unique_id: ability_id}])
		]
		)",

		fire_event: "def(event_name, args) [
		  call(query(me, event_name), args),
		  [ call(query(ability, event_name), [me] + args) |
		    ability <- triggered_abilities, not is_string(ability)]
		]",

		on_begin_turn: "def(game) null",

		remove_abilities: "def(abilities, removal) if(removal = [], abilities,
		  remove_abilities(remove_single_ability(abilities, removal[0]),
		                   removal[1:]))",

		remove_single_ability: "def(abilities, item)
		  if(is_string(item), if(i = -1, abilities, abilities[0:i] + abilities[i+1:]) where i = index(abilities, item),
		   filter(abilities, value != ability)
		    where ability = find(abilities, value.unique_id = item.unique_id))",

		on_end_turn: "def(game) [
		 map(private.this_turn_effects, add(me[value.attr], -value.delta)),
		 set(private.this_turn_effects, []),
		 set(private.abilities, remove_abilities(private.abilities, private.this_turn_abilities)),
		 set(private.this_turn_abilities, [])]",

		do_move: "def(game) do_move_internal(game, find_first_vacant(game, find_blocker(game, 1, move+1) - 1))",

		do_move_internal: "def(game, move_spaces) [
		  set(me.spaces_moved_this_turn, move_spaces),
		  if(move_spaces = 0, null,
		  
		  if((game.is_loc_on_board(target_loc) or game.is_loc_in_endzone(target_loc, controller)),
			  [
			  map(range(1, move_spaces+1), [game.capture(
			    [loc[0], loc[1] + value*direction_moving], if(is_marauder, -1, controller), if(is_marauder, -1, school)),
				if(creature != null, [creature.fire_event('on_moved_over', [game, me])]) where creature = game.creature_at_loc([loc[0], loc[1] + value*direction_moving])
				]) where is_marauder = ('Marauder' in abilities),
			  set(me.loc, target_loc),
			  if('Charge' in abilities, apply_effect_until_end_of_turn('attack', move - move_spaces)),
			  ], do_move_internal(game, move_spaces-1)
		  )
		  where target_loc = [loc[0], loc[1] + move_spaces*direction_moving])]",

		targets_attacking: "def(game) filter(map(search_directions, find_target(game, value, value*range)), value != null)
		  //we want to attack in both directions if we're neutral, otherwise
		  //attack in the direction we're going.
		  where search_directions = if(controller = -1, [-1,1], [direction_moving])",

		do_attack: "def(game) [
		  set(me.attack_hint, { turn: game.turn, attacks:
		      map(targets_attacking(game), { target: value, target_loc: value.loc, damage: attack})}),
		  map(targets_attacking(game),
		      value.inflict_combat_damage(game, me, attack))
		]",
		

		find_target: "def(game, moves_ahead, max_moves)
		  if(potential != null and potential.controller != me.controller and
		     (abs(moves_ahead) = 1 or potential.is_valid_target(game, me.controller, me)), potential, if(moves_ahead = max_moves, null, find_target(game, moves_ahead + sign(moves_ahead), max_moves)))
		  where potential = game.summoned_creature_at_loc([loc[0], loc[1] + moves_ahead])",

		find_blocker: "def(game, moves_ahead, max_moves)
		   if(blocking_creature != null and
		      blocking_creature.controller != me.controller and
			  ('Flying' in blocking_creature.abilities) = ('Flying' in me.abilities),
			  moves_ahead,
			  if(moves_ahead+1 < max_moves,
				 find_blocker(game, moves_ahead+1, max_moves), max_moves))
		   where blocking_creature = game.summoned_creature_at_loc([loc[0], loc[1] + moves_ahead*direction_moving])",

		find_first_vacant: "def(game, moves_ahead)
		  if(game.creature_at_loc([loc[0],
				                  loc[1] + moves_ahead*direction_moving]),
			    find_first_vacant(game, moves_ahead-1),
				moves_ahead)",

		transform: "def(game, new_type) [
		  set(game.creatures, filter(game.creatures, value.summon_id != me.summon_id) + [new_creature]),

		  set(new_creature.wounds, me.wounds),
		  set(new_creature.loc, me.loc),
		  set(new_creature.controller, me.controller),
		  set(new_creature.summon_id, me.summon_id)
		] where new_creature = construct('creature', new_type)",

		direction_moving: "if(controller = 1, -1, 1)",

		//has an enemy immediately in front
		is_engaged: "def(game) enemy != null and enemy.controller != controller
		     where enemy = game.summoned_creature_at_loc(
			                      [loc[0], loc[1] + direction_moving])",

		gui_stats_grid: "
		 	{
				type: 'grid',
				padding: [10,10],
				columns: 2,
				x: 40,
				y: 0,
				children: [] +

				if((not is_building) or attack > 0,
				[
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [40,0,47,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(attack),
						size: stats_label_size,
					},
				], []) +

				if(range > 1, [
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [24,0,31,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(range),
						size: stats_label_size,
					},
				], []) +

				if(resistance != 0, [
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: if(resistance < 0, [8,0,15,7], [16,0,23,7]),
					},

					{
						type: 'label',
						color: if(resistance < 0, 'red', 'black'),
						border_color: 'white',
						text: str(resistance),
						size: stats_label_size,
					},
				], []) +

				if((not is_building) or move > 0,
				[
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [32,0,39,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(move),
						size: stats_label_size,
					},
				], []) +

				if(is_building or level > 0, [
					{
						type: 'image',
						image: 'citadel-buildings.png',
						area: [117 + 9*level,3,126 + 9*level,12],
					},

					{
						type: 'label',
						color: 'black',
						text: '',
						size: 12,
					}
				], [])
			}
		"
	},
}
