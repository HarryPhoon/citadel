{
	private: {
		//temporary modifications to a creature.
		static_effects: [],
		static_abilities: [],
		this_turn_effects: [],
		this_turn_abilities: [],
		this_turn_triggered_abilities: [],

		abilities: [],

		triggered_abilities: [],

		//record the last turn damage was dealt to us and a list of creatures
		//that inflicted damage on us.
		damage_dealt_turn: -1,
		damage_dealt_by: {}, //maps creatures to amounts.
		destroyed: false,
		ability_id: 1,
	},

	properties: {
		summon_id: { variable: true, default: 0 }, //unique within a game.
		name: { variable: true },
		school: { variable: true, default: 0 },

		animation_hints: { variable: true, default: [] },
		animation_hint_id: { variable: true, default: 1 },

		add_animation_hint: "def(hint) [add(me.animation_hints, [hint + {hint_id: animation_hint_id}]), add(me.animation_hint_id, 1)]",

		death_animation_hint: { variable: true },
		attack_hint: { variable: true, default: { turn: -1, attacks: [] } },

		overlays: { variable: true, default: [] },

		summoning_time: { variable: true, default: 2, get: "if(is_building, private.summoning_time, 0)" },
		summoning_counters: { variable: true, default: 0 },
		force_summon: "set(me.summoning_counters, me.summoning_time)",

		increment_summoning: "add(me.summoning_counters, 1)",
		summoned: "summoning_counters >= summoning_time",

		is_building: "false",

		//the base card that this creature came from.
		card_name: { variable: true, default: null, type: ['string', 'null'] },

		tags: { variable: true, default: [] },
		status_effects: { variable: true, default: [], type: ['list'] },

		exhaust_on_summon: "def(game) if(not 'Haste' in abilities, me.set_exhausted())",
		set_exhausted: "def() if(not ('Exhausted' in status_effects),
		             add(me.status_effects, ['Exhausted']))",

		is_exhausted: "'Exhausted' in status_effects",

		abilities: { get: "if(summoned, private.abilities, [])",
		             set: "set(private.abilities,
					        map(value, if(is_map(value), construct('activated_ability', value), value)))" },

		activated_abilities: "if(summoned, filter(abilities, not is_string(value)), [])",

		triggered_abilities: { get: "if(summoned, private.triggered_abilities, [])",
		             set: "set(private.triggered_abilities,
					        map(value, if(is_map(value), construct('triggered_ability', value), value)))" },

		sprite_sheet: { variable: true, default: null },
		image_num: { variable: true, default: 0 },

		range: { variable: true, default: 1 },
		attack: { variable: true, default: 0, get: "if(summoned, private.attack, 0)" },
		life: { variable: true, default: 1, get: "if(summoned, private.life, min(private.life, summoning_counters+1))" },
		move: { variable: true, default: 0 },
		spaces_moved_this_turn: { variable: true, default: 0 },
		initiative: { variable: true, default: 1 },

		resistance: { variable: true, default: 0, get: "if(summoned, private.resistance, 0)" },

		resistance_against: "def(game, attacker, damage) me.resistance",

		level: { variable: true, default: 0 },

		reached_endzone: { variable: true, default: false },

		is_valid_target: "def(game, nplayer, obj)
		    not (nplayer != controller and has_cover(game))",

		has_cover: "def(game) ('Cover' in abilities) or
		 (game.terrain_at_loc(loc) = 'forest' and not ('Flying' in abilities))",

		on_summoned: "def(game) null",

		on_attacked: "def(game, attacker, damage) null",

		on_deal_damage: "def(game, target, damage) 
			map(me.abilities, switch(value, 'Life Drain', if(not target.is_building, add(me.wounds, -damage))))",

		inflict_combat_damage: "def(game, attacker, damage) if(damage_dealt > 0,
		    [add(me.wounds, damage_dealt),
			 me.fire_event('on_attacked', [game, attacker, damage]),
			 attacker.fire_event('on_deal_damage', [game, me, damage]),
			 if(private.damage_dealt_turn = game.turn,
			    private.damage_dealt_by + {
				  str(attacker.summon_id): damage_dealt + private.damage_dealt_by[str(attacker.summon_id)]
				},
				[set(private.damage_dealt_turn, game.turn),
				 set(private.damage_dealt_by, {str(attacker.summon_id): damage_dealt})]
			   )])
		  where damage_dealt = damage - me.resistance_against(game, attacker, damage)",

		hit_by_this_turn: "def(game) if(private.damage_dealt_turn = game.turn, map(private.damage_dealt_by, key), [])",

		on_kill: "def(game, victim) null",
		on_another_creature_died: "def(game, victim) null",

		on_die: "def(game) null",

		fire_events_on_death: "def(game) [
		   game.fire_creature_event('on_another_creature_died', [me]),
		   map(hit_by_this_turn(game), if(killer, killer.fire_event('on_kill', [game, me])) where killer = find(game.creatures, context.value = str(value.summon_id)))
		   ]",

		on_reach_endzone: "def(game) [
			set(me.reached_endzone, true),
			add(game.players[if(controller = 0, 1, 0)].life, -1)
		]",

		wounds: { variable: true, set: "set(private.wounds, max(0, value))", default: 0 },

		destroyed: { get: "alive", set: "set(private.destroyed, value)" },
		alive: "life > wounds and not private.destroyed",

		loc: { variable: true, default: null },

		controller: { variable: true, default: -1 },

		stats_label_size: "18",
		
		on_moved_over: "def(game, creature) null",
		on_move: "def(game) null",


		//formula which takes {creature, target, game} argument and applies the
		//static effect on the target.
		static_ability_effect: { variable: true, default: null },

		apply_static_abilities: "def(game) if(summoned, [
		if(wounds < 0, set(wounds, 0)),
		if(me.static_ability_effect,
		    [map(game.creatures, eval_no_recover(me.static_ability_effect, {creature: me, target: value, game: game}))])])",

		apply_static_effect: "def(attr, delta) if(summoned, [add(me[attr], delta), add(private.static_effects, [{attr: attr, delta: delta}])])",

		remove_static_effects: "def() [
		   map(private.static_effects, add(me[value.attr], -value.delta)),
		   set(private.static_effects, []),
		   set(private.abilities, remove_abilities(private.abilities, private.static_abilities)),
		   set(private.static_abilities, [])]",

		add_ability_static_duration: "def(ability)
		if(is_string(ability), [
		  add(private.static_abilities, [ability]),
		  add(private.abilities, [ability])
		],
		[
		  add(private.ability_id, 1),
		  add(private.static_abilities, [private.ability_id]),
		  add(private.abilities, [ability + {unique_id: private.ability_id}])
		]
		)",


		apply_effect_until_end_of_turn: "def(attr, delta) [add(me[attr], delta), add(private.this_turn_effects, [{attr: attr, delta: delta}])]",

		add_ability_until_end_of_turn: "def(ability) 
		if(is_string(ability), [
		  add(private.this_turn_abilities, [ability]),
		  add(private.abilities, [ability])
		],
		[
		  add(private.ability_id, 1),
		  add(private.this_turn_abilities, [private.ability_id]),
		  add(me.abilities, [ability + {unique_id: private.ability_id}])
		]
		)",

		add_triggered_ability_until_end_of_turn: "def(ability)
		[
			add(private.ability_id, 1),
			add(private.this_turn_triggered_abilities, [private.ability_id]),
			add(me.triggered_abilities, [ability + {unique_id: private.ability_id}])
		]",

		fire_event: "def(event_name, args) if(summoned, [
		  call(query(me, event_name), args),
		  [ call(query(ability, event_name), [me] + args) |
		    ability <- triggered_abilities, not is_string(ability)]
		]) asserting is_list(args) | [event_name, args]",

		begin_turn: "def(game) [
		  if(game.current_player = controller, [
				if('Regeneration' in abilities, add_animation_hint({
						type: 'regeneration'
					})),
		  		add(me.wounds, -count(abilities, value = 'Regeneration')
		  		               +count(status_effects, value = 'Poisoned')),
			]
		  ),
		  me.fire_event('on_begin_turn', [game])
		]",

		on_begin_turn: "def(game) null",

		remove_abilities: "def(abilities, removal) if(removal = [], abilities,
		  remove_abilities(remove_single_ability(abilities, removal[0]),
		                   removal[1:]))",

		remove_single_ability: "def(abilities, item)
		  if(is_string(item), if(i = -1, abilities, abilities[0:i] + abilities[i+1:]) where i = index(abilities, item),
		   filter(abilities, value != ability)
		    where ability = find(abilities, value.unique_id = item.unique_id))",

		on_end_turn: "def(game) [
		 set(me.status_effects, filter(me.status_effects, value != 'Exhausted')),
		 map(private.this_turn_effects, add(me[value.attr], -value.delta)),
		 set(private.this_turn_effects, []),
		 set(private.abilities, remove_abilities(private.abilities, private.this_turn_abilities)),
		 set(private.triggered_abilities, remove_abilities(private.triggered_abilities, private.this_turn_triggered_abilities)),
		 set(private.this_turn_abilities, [])]",

		//the number of spaces this creature wants to move, according to its
		//behavior. (Which includes stopping when in range of an enemy).
		desired_moves: "def(game, movement)
		 if(range <= 1 or ('Flying' in abilities), movement,
		   if(nmoves = null, movement, nmoves)
		 where nmoves = find(range(movement), find_target(game, direction_moving, (value+range)*direction_moving)))",

		do_move: "def(game) if(move > 0, do_move_internal(game, find_first_vacant(game, find_blocker(game, 1, desired_moves(game, move)+1) - 1)))",

		do_trample_move: "def(game) if(moves_left > 0,
		(
		  [
		  	do_move_internal(game, move_spaces),
		  	if(move_spaces <= 0, set(me.status_effects,
				 filter(me.status_effects, value != 'Trampling') +
				 ['Exhausted'])
			)
		  ]
		   where move_spaces = find_blocker(game, 1,
		                        desired_moves(game, moves_left)+1) - 1
		 ),

		   set(me.status_effects, filter(me.status_effects, value != 'Trampling'))

		  )
		  where moves_left = move - spaces_moved_this_turn",

		do_move_internal: "def(game, move_spaces) [
		  set(me.spaces_moved_this_turn, move_spaces),
		  if(move_spaces = 0, null,
		  
		  if((game.is_loc_on_board(target_loc) or game.is_loc_in_endzone(target_loc, controller)),
			  [
			  map(range(1, move_spaces+1), [game.capture(
			    moveover_loc, if(is_marauder, -1, controller), if(is_marauder, -1, school)),
				if(creature != null, [creature.fire_event('on_moved_over', [game, me])]) where creature = game.creature_at_loc([loc[0], loc[1] + value*direction_moving])
				] where moveover_loc = [loc[0], loc[1] + value*direction_moving]
				) where is_marauder = ('Marauder' in abilities),
			  set(me.loc, target_loc),
			  if('Charge' in abilities, apply_effect_until_end_of_turn('attack', move - move_spaces)),
			  ], do_move_internal(game, move_spaces-1)
		  )
		  where target_loc = [loc[0], loc[1] + move_spaces*direction_moving])]",

		targets_attacking: "def(game) filter(map(search_directions, find_target(game, value, value*range)), value != null)
		  //we want to attack in both directions if we're neutral, otherwise
		  //attack in the direction we're going.
		  where search_directions = if(controller = -1, [-1,1], [direction_moving])",

		do_attack: "def(game) if(attack > 0, [
		  set(me.attack_hint, { turn: game.turn, attacks:
		      map(targets, { target: value, target_loc: value.loc, damage: attack})}),
		  map(targets, value.inflict_combat_damage(game, me, attack)),
		  if(targets, add(me.status_effects,
		    if(('Trample' in abilities) and spaces_moved_this_turn < move,
			    ['Trampling'], ['Exhausted'])))
		] where targets = targets_attacking(game)
		)",
		

		find_target: "def(game, moves_ahead, max_moves)
		  if(potential != null and potential.controller != me.controller and
		     (abs(moves_ahead) = 1 or potential.is_valid_target(game, me.controller, me)), potential, if(moves_ahead = max_moves, null, find_target(game, moves_ahead + sign(moves_ahead), max_moves)))
		  where potential = game.creature_at_loc([loc[0], loc[1] + moves_ahead])",

		//overridable to allow evasion.
		can_evade: "def(game, target) false",

		find_blocker: "def(game, moves_ahead, max_moves)
		   if(blocking_creature != null and
			  blocking_creature != me and
		      blocking_creature.controller != me.controller and
			  (not me.can_evade(game, blocking_creature)) and
			  ('Flying' in blocking_creature.abilities) = ('Flying' in me.abilities),
			  moves_ahead,
			  if(moves_ahead+1 < max_moves,
				 find_blocker(game, moves_ahead+1, max_moves), max_moves))
		   where blocking_creature = game.creature_at_loc([loc[0], loc[1] + moves_ahead*direction_moving])",

		find_first_vacant: "def(game, moves_ahead)
		  if(moves_ahead <= 0, 0,
		  if(game.creature_at_loc([loc[0],
				                  loc[1] + moves_ahead*direction_moving]),
			    find_first_vacant(game, moves_ahead-1),
				moves_ahead))",

		transform: "def(game, new_type) [
		  set(game.creatures, filter(game.creatures, value.summon_id != me.summon_id) + [new_creature]),

		  set(new_creature.wounds, me.wounds),
		  set(new_creature.loc, me.loc),
		  set(new_creature.controller, me.controller),
		  set(new_creature.summon_id, me.summon_id)
		] where new_creature = construct('creature', new_type)",

		direction_moving: "if(controller = 1, -1, 1)",

		//has an enemy immediately in front
		is_engaged: "def(game) enemy != null and enemy.controller != controller
		     where enemy = game.creature_at_loc(
			                      [loc[0], loc[1] + direction_moving])",

		//if this creature allows summoning in additional tiles.
		allows_summoning: "def(game) []",

		gui_status_grid: "
			if(status_effects = [], null,
				{
					type: 'grid',
					padding: [10,10],
					columns: 1,
					x: 10, y: 0,
					zorder: 2,
					children: map(status_effects,
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [icon_num*8, 0, (icon_num+1)*8, 8]
						   where icon_num = switch(value,
						   'Exhausted', 6,
						   'Poisoned', 7,
						   6)
					})
				}
			)
		",

		gui_stats_grid: "
		 	{
				type: 'grid',
				padding: [10,10],
				columns: 2,
				x: 40,
				y: 0,
				children: [] +

				if((not is_building) or attack > 0,
				[
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [40,0,47,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(attack),
						size: stats_label_size,
					},
				], []) +

				if(range > 1, [
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [24,0,31,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(range),
						size: stats_label_size,
					},
				], []) +

				if(resistance != 0, [
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: if(resistance < 0, [8,0,15,7], [16,0,23,7]),
					},

					{
						type: 'label',
						color: if(resistance < 0, 'red', 'black'),
						border_color: 'white',
						text: str(resistance),
						size: stats_label_size,
					},
				], []) +

				if((not is_building) or move > 0,
				[
					{
						type: 'image',
						image: 'citadel-icons.png',
						area: [32,0,39,7],
					},

					{
						type: 'label',
						color: 'black',
						border_color: 'white',
						text: str(move),
						size: stats_label_size,
					},
				], []) +

				if(is_building or level > 0, [
					{
						type: 'image',
						image: 'citadel-buildings.png',
						area: [117 + 9*level,3,126 + 9*level,12],
					},

					{
						type: 'label',
						color: 'black',
						text: '',
						size: 12,
					}
				], [])
			}
		"
	},
}
