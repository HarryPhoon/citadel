{
	properties: {
		session_id: { variable: true, default: 0 },

		score_summons: "def(game, card, loc)
		 (
		 	//score for there being an unowned glyph with no other creature
			//claiming it.
			if(nearest_unowned_glyph != null,
			   if(find(game.creatures,
					   value.loc[0] = loc[0] and
					   value.loc[1] >= nearest_unowned_glyph[1]) = null,
					   nearest_unowned_glyph[1]*10, 0), 0)
		 )
			  where nearest_glyph = choose(filter(keys(game.villages), value[0] = loc[0]), value[1])
			  where nearest_unowned_glyph = choose(filter(keys(game.villages), value[0] = loc[0] and game.villages[value].owner != game.current_player), value[1])
		",

		playable_creatures: "def(game)
		  filter(player.hand,
		   value.type = 'creature' and
		   player.resources + (size(player.hand)-1) >=
		   player.actual_cost(value.school, value.cost, value.loyalty_cost) and
		   (value.is_response or game.response_phase = 0) and
		   value.possible_targets(game, game.nplayer, []))
		        where player = game.players[game.nplayer]",

		possible_summons: "def(game) fold(map(playable_creatures(game),
		   map(value.possible_targets(game, game.nplayer, []),
		       [context.value, value])),
			   a+b, [])",

		best_summons: "def(game) choose(possible_summons(game),
		          score_summons(game, value[0], value[1]))",

		handle_message: "def(message, bot) [
		  if(message.type = 'game' and message.state.players[message.state.nplayer].deck = null,
			//submit our deck to the server.
			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'submit_deck',
					deck: get_document('data/ai-deck.cfg'),
				}
			}]),

			if(message.type = 'game' and message.state.nplayer = message.state.current_player,
			     if(playable_creatures(message.state),
				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'moves',
						state_id: message.state_id,
						moves: 

						if(ndiscards > 0, [{
							type: 'discard',
							indexes: discard_indexes
						}]) +
						
						[
						{
							type: 'play_card',
							index: final_index asserting final_index >= 0 | [final_index, hand_index, discard_indexes, size(player.hand)],
							targets: [summons[1]],
						} where final_index = hand_index - count(discard_indexes, value < hand_index)
						]
					}
				where discard_indexes = if(hand_index >= ndiscards, range(ndiscards), filter(range(ndiscards+1), value != hand_index))
				where hand_index = (index(player.hand, summons[0]) asserting find(player.hand, summons[0]) | summons)
				where ndiscards = max(0, player.actual_cost(summons[0].school, summons[0].cost, summons[0].loyalty_cost) - player.resources)
				where summons = best_summons(message.state)
				where player = message.state.players[message.state.nplayer],
				  }]),
				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'moves',
						state_id: message.state_id,
						moves: [
							{ type: 'end_turn' }
						]
					}
				  }])),
				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'request_updates'
					}
				  }])
			))
		]",
	}
}
