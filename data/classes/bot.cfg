{
	properties: {
		session_id: { variable: true, default: 0 },

		score_summons: "def(game, card, loc)
		 (
		 	//score for there being an unowned glyph with no other creature
			//claiming it.
			if(nearest_unowned_glyph != null,
			   if(find(game.creatures,
					   value.loc[0] = loc[0] and
					   value.loc[1] >= nearest_unowned_glyph[1]) = null,
					   nearest_unowned_glyph[1]*10, 0), 0)
		 )
			  where nearest_glyph = choose(filter(keys(game.villages), value[0] = loc[0]), value[1])
			  where nearest_unowned_glyph = choose(filter(keys(game.villages), value[0] = loc[0] and game.villages[value].owner != game.current_player), value[1])
		",

		score_spell: "def(game, card, targets) 0",

		score_play: "def(game, card, targets) if(card.creature and size(targets) = 1, score_summons(game, card, targets[0]), score_spell(game, card, targets))",

		calculate_card_play: "def(game, card)
		  if(targets = [], null,
			if(targets = null, {card: card, targets: [], score: score_play(game, card, [])},
			  {card: card, targets: [best_target], score: score_play(game, card, [best_target])}
			  where best_target = choose(targets, score_play(game, card, [value]))
			))
		  where targets = card.possible_targets(game, game.nplayer, [])
		",

		get_best_play: "def(game)
		 if(is_list(best_combo) and size(best_combo) >= 1,
			plays[best_combo[0].name] + {discards: filter(map(player.hand, if(value in best_combo, null, index)), value != null)}, null)
		  where best_combo = choose(combinations, fold(map(value, plays[value.name].score), a+b))
		  where player = game.players[game.nplayer]
		  where combinations = playable_combinations(game, plays)
		  where plays = calculate_plays(game)",

		calculate_plays: "def(game) fold(map(playable_cards(game), if(info, {(value.name): info}, null) where info = calculate_card_play(game, value)), a+b)",

		playable_combinations: "def(game, plays_map, play=[], existing_cost=0)
		   map(candidates, play + [value]) + fold(map(candidates, playable_combinations(game, plays_map, play + [value], existing_cost + player.calculate_cost(value))), a+b)
		   where candidates = filter(player.hand[starting_index:],
		    (not (value in play)) and
		    (player.resources + size(player.hand) - (size(play)+1+existing_cost)) >= player.calculate_cost(value) and
			plays_map[value.name] != null and
			value.possible_targets(game, game.nplayer, []) != [])
		   where starting_index = if(play = [], 0, index(player.hand, play[size(play)-1])+1)
		   where player = game.players[game.nplayer]
		",

		playable_cards: "def(game)
		  filter(cards_to_consider(game, player),
		   player.resources + (size(player.hand)-1) >=
		   player.actual_cost(value.school, value.cost, value.loyalty_cost) and
		   (value.is_response or game.response_phase = 0) and
		   value.possible_targets(game, game.nplayer, []) != [])
		        where player = game.players[game.nplayer]",

		cards_to_consider: "def(game, player) player.hand",

		handle_message: "def(message, bot) [
		  if(message.type = 'game' and message.state.players[message.state.nplayer].deck = null,
			//submit our deck to the server.
			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'submit_deck',
					deck: deck,
				}
			}]),

			if(message.type = 'game' and message.state.nplayer = message.state.current_player,
				handle_game_message(message, bot),

				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'request_updates'
					}
				  }])
			))
		]",

		handle_game_message: "def(message, bot)
		    if(summons,
				  send_moves(message, bot,
					[
						{
							type: 'discard',
							indexes: discard_indexes
						},
						
						{
							type: 'play_card',
							index: final_index asserting final_index >= 0 | [final_index, hand_index, discard_indexes, size(player.hand)],
							targets: summons.targets,
						} where final_index = hand_index - count(discard_indexes, value < hand_index)
					]
				where discard_indexes = summons.discards
				where hand_index = (index(player.hand, summons.card) asserting find(player.hand, summons.card) | summons)
				  ),
				  end_turn(message, bot))
				where summons = get_best_play(message.state)
				where player = message.state.players[message.state.nplayer],
		",

		end_turn: "def(message, bot) send_moves(message, bot, [{type: 'end_turn'}])",

		send_moves: "def(message, bot, moves)
				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'moves',
						state_id: message.state_id,
						moves: moves
					}
				  }])",

		deck: "get_document('data/ai-deck.cfg')"
	},
}
