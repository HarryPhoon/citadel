{
	private: {
		nturn: 0,
		creature_summon_id: 100,
		log: [],
		state_based_deaths: {}, // temporary used during state based actions.
	},

	constructor: "[
	   set(terrain, {([1,2]): {type: 'forest'},
	                 ([1,6]): {type: 'forest'},
					 ([4,4]): {type: 'mountain'}}),
		if(doc, add(me.creatures,
			map(doc, construct('creature', value + {summon_id: 10+index})))
		) where doc = get_document('data/starting-creatures.cfg'),
	   add(me.creatures, map(
	     map([1,2,3,4,5],
	       {
			  name: 'Guard Tower',
			  summoning_time: 0,
			  controller: -1,
			  attack: if(value = 1, 2, 1),
			  range: 2,
			  abilities: ['Fortification'],
			  life: if(value = 1, 4, 3),
			  is_building: true,
			  image_num: 6,
			  loc: village_locs[value],
			  summon_id: 1 + index,

			  settings: if(value = 1, '{ spoils: 4 }', '{ spoils: 2 }'),

			  rules: 'Spoils for destroying: ' + if(value = 1, 4, 2) + ' cards',

			  on_die: q(def(game)
			    map(game.players, if(index in victors, value.draw_cards(game, settings.spoils)))
			    where victors = map(me.hit_by_this_turn(game), if(target, target.controller, null) where target = game.creature_by_summon_id(value))),
		   }), construct('creature', value))),
	   set(me.villages,
	       fold(map(village_locs,
		            {(value): {owner: -1, type: -1,
					           level: [0,0,0,1,2,1,0,0,0][value[1]]}}), a+b))
	  ]
	      where village_locs =
		    fold(map(range(5), [loc, [loc[0], 8 - loc[1]]]
		         where loc = [[2,4], [0,3], [4,3], [2,1], [3,2]][value]), a + b)
	",
	properties: {
		nplayer: { variable: true },
		players: { variable: true },
		current_player: "current_player_index", // deprecated due to poor naming
		current_player_index: "if(current_choice != null, current_choice.player_index, (private.nturn + precombat_phase + size(stack))%size(players))",
		player_obj: "players[current_player_index]",
		opponent_obj: "players[next_player_index]",
		next_player_index: "(current_player_index+1)%size(players)",
		next_player: "(current_player_index+1)%size(players)",

		player_init: "def(player) if(player.player_index = 0, player.begin_turn(me))",

		current_choice: { variable: true, default: null },

		turn: "private.nturn",
		precombat_phase: { variable: true, default: 0 },
		response_played: { variable: true, default: false },
		done_movement: { variable: true, default: false },

		stack: { variable: true, default: [] },
		stack_id: { variable: true, default: 1 },

		in_response_phase: "precombat_phase or stack",

		log_message: "def(msg) add(private.log, [msg])",
		log: "private.log",

		creatures: { variable: true, default: [] },
		creatures_and_avatars: "creatures + map(players, value.creature_avatar)",
		permanents: "creatures + constructs",
		permanents_and_avatars: "creatures + constructs + map(players, value.creature_avatar)",

		constructs: { variable: true, default: [] },

		//dead creatures, keyed by summon_id.
		graveyard: { variable: true, default: {} },

		villages: { variable: true, default: {} },

		//maps loc -> terrain
		terrain: { variable: true, default: {} },

		terrain_at_loc: "def(loc) if(t, t.type) where t = terrain[loc]",

		capture: "def(loc, owner, type) [
		  if(me.villages[loc] != null,
		    [set(me.villages[loc].owner, owner),
			 set(me.villages[loc].type, type),
			 ]),
		  if(construct and construct.controller != owner,
		    set(construct.destroyed, true))
		      where construct = construct_at_loc(loc)
		]",

		rows: { variable: true, default: 6},
		columns: { variable: true, default: 9},

		animation_hints: { variable: true, type: 'list', default: [] },
		animation_hints_id: { variable: true, type: 'int', default: 1 },
		
		winner: "if(count(players, value.life > 0) = 1, find(players, value.life > 0), null)",

		process_moves: "def(info)
		  map(info.moves, { execute: q(game.process_game_move(move)), arg: { game: me, move: value } })
		",

		process_game_move: "def(info)
		 if(info.type = 'debug', me.process_debug(info),
		  if(current_choice and info.type = 'make_choice',
		     me.make_choice(info),
		  switch(info.type,
		     'discard', me.discard_cards(info),
			 'play_card', me.play_card(info),
			 'play_ability', me.play_ability(info),
			 'end_turn', me.end_turn(info),
			 'movement', me.movement(info),
			 log_message('bad message received: ' + info.type + ' ' +
			      if(current_choice, 'while has choice', 'while no choice')
		  ))))
		",

		process_debug: "def(info) [
			log_message('PROCESS DEBUG MESSAGE'),
			if(info.exe, if(result, result, log_message('failed to eval debug expression')) where result = eval(info.exe))
		]",

		discard_cards: "def(info) players[current_player].discard_cards(info.indexes)",

		resolve_ability: "def(info) [
		if(info.ability.targets_valid(me, info.creature, info.targets), [
			debug('resolve ability'),
			info.ability.on_play(me, info.creature, info),
			state_based_actions,
			if(info.stack_id, add(me.animation_hints, [{
				type: 'resolve',
				stack_id: info.stack_id,
			}]))
		],
		if(info.stack_id, add(me.animation_hints, [{
			type: 'fizzle',
			stack_id: info.stack_id,
		}]))
		)
		]",

		play_ability: "def(info) [
		if(creature and ((not ability.exhausts_creature) or
		                 (not creature.is_exhausted)), ([
		  player.spend(ability.school, ability.cost, ability.loyalty_cost),
		  if(ability.exhausts_creature, creature.set_exhausted()),

		  //resolve_ability(play_info)
		  add(me.stack_id, 1),
		  (add(me.stack, [play_info])
		    where play_info = info + {
				ability: ability,
				creature: creature,
				player_index: current_player,
				stack_id: stack_id,
		    }),

		  add(me.animation_hints, [{
			type: 'play_ability',
			ability: ability,
			player: current_player,
			stack_id: stack_id,
			targets: [creature.loc] + info.targets
		  }]),
		  state_based_actions,
		  set(me.response_played, true)
		] asserting ability, player.can_afford(ability.school, ability.cost, ability.loyalty_cost),
		  (not in_response_phase) or ability.is_response),
		  ability.targets_valid(me, creature, info.targets)
		 )
		  where ability = if(creature, find(creature.abilities, value.name = info.ability))
		  where creature = find(permanents, value.summon_id = info.creature)
		  where player = players[current_player]
		]",

		set_current_choice: "def(info)
			set(me.current_choice, construct('choice', info + if(info.player_index = null, {player_index: current_player}, {})))
		",

		make_choice: "def(info) if(current_choice, [
			set(me.current_choice, null),
			{ execute: q(card.on_play(game, info)),
			  arg: { card: current_choice.card, game: me,
			         info: current_choice.info + {choices: (current_choice.info.choices or []) + [info.choice]} } },
			{ execute: q(debug('has choice: ' + if(game.current_choice, 'yes', 'no'))), arg: {game: me}},
		])",

		resolve_card: "def(info) [
			if(not info.card.creature, add(players[info.player_index].discard_pile, [info.card.name])),

			//check the targets are still valid, otherwise the spell fizzles.
			if(info.card.targets_valid(me, info.player_index, info.targets),
				[
					{ execute: q(info.card.on_play(game, info)),
					  arg: { info: info, game: me } },
					if(info.stack_id, add(me.animation_hints, [{
						type: 'resolve',
						stack_id: info.stack_id,
					}]))
				],
				
				if(info.stack_id, add(me.animation_hints, [{
					type: 'fizzle',
					stack_id: info.stack_id,
				}]))
			),

			state_based_actions,
		]",

		play_card: "def(info) ([
		  log_message(player.name + ' plays ' + player.hand[info.index].name),
		  player.spend(player.hand[info.index].school,
		               player.hand[info.index].cost,
					   player.hand[info.index].loyalty_cost),
		  set(player.hand, filter(player.hand, index != info.index)),
		  player.hand[info.index].record_animation(me, info, stack_id),

		  if(player.hand[info.index].plays_on_stack,
			 [
		     	add(me.stack, [play_info + {stack_id: stack_id}]),
				add(me.stack_id, 1),
			 ],
		     resolve_card(play_info)) where play_info = info + {card: player.hand[info.index], player_index: current_player},

		  set(me.response_played, true),
		  player.level_up(player.hand[info.index].school)
		  ]
		  asserting info.index >= 0 and info.index < size(player.hand),
		            player.can_afford(player.hand[info.index].school,
					                  player.hand[info.index].cost,
									  player.hand[info.index].loyalty_cost),
					(not in_response_phase) or player.hand[info.index].is_response,
					player.hand[info.index].targets_valid(me, current_player, info.targets)
				| [info.index, map(player.hand, value.name), in_response_phase])
		  where player = players[current_player]",

		summon_creature: "def(new_creature) [
		  { execute: q([
		                set(new_creature.summon_id, private.creature_summon_id),
		                add(private.creature_summon_id, 1),
					  ]),
			arg: { new_creature: new_creature, private: private } },
			 add(me.creatures, [new_creature]),
		  { execute: q(new_creature.handle_summoning(game)),
		     arg: { new_creature: new_creature, game: me} },
			 state_based_actions,
		  { execute: q(new_creature.exhaust_on_summon(game)),
		     arg: { new_creature: new_creature, game: me } }
			  ]",

		summon_construct: "def(new_construct) [
		  { execute: q([
		                set(new_construct.summon_id, private.creature_summon_id),
		                add(private.creature_summon_id, 1),
					  ]),
			arg: { new_construct: new_construct, private: private } },
			 add(me.constructs, [new_construct]),
		  { execute: q(new_construct.handle_summoning(game)),
		     arg: { new_construct: new_construct, game: me} },
			 state_based_actions,
		  { execute: q(new_construct.exhaust_on_summon(game)),
		     arg: { new_construct: new_construct, game: me } }
		]",

		return_from_graveyard: "def(creature)
		if(me.graveyard[creature.summon_id], [
			set(me.graveyard, remove_from_map(me.graveyard, creature.summon_id)),
			add(me.creatures, [creature]) asserting (not (creature in me.creatures))
		])",

		return_from_graveyard_to_hand: "def(creature)
		if(target and target.card_name and target.controller >= 0 and target.controller < size(players), [
			set(me.graveyard, remove_from_map(me.graveyard, creature.summon_id)),
			add(me.players[creature.controller].hand, [target.card_name])
			
		]) where target = graveyard[creature.summon_id]",


		remove_static_effects: "map(me.permanents_and_avatars, value.remove_static_effects())",
		apply_static_effects: "map(me.permanents_and_avatars, value.apply_static_abilities(me))",
		state_based_actions_internal: "[
		    set(me.creatures, new_creatures),
			set(me.constructs, new_constructs),
			map(me.creatures, if(not value.alive, add(me.graveyard, {value.summon_id: value}))),
			[ add(me.players[construct.controller].discard_pile, [construct.card_name]) |
			  construct <- constructs,
			  construct.controller >= 0,
			  not construct.alive ],

			map(me.permanents, if(not value.alive, [value.fire_events_on_death(me), { execute: q([creature.fire_event('on_die', [game])]), arg: {creature: value, game: me} }])),
		 if(new_creatures != me.creatures, { execute: q(game.state_based_actions), arg: {game: me}})]
				 
			where new_creatures = filter(me.creatures, value.alive)
			where new_constructs = filter(me.constructs, value.alive)
				 ",

		state_based_actions: "
		 [
		   { execute: q(game.remove_static_effects), arg: {game: me}},
		   { execute: q(game.apply_static_effects), arg: {game: me}},
		   { execute: q(game.state_based_actions_internal), arg: {game: me}},
		 ]
		",

		do_moves: "[
		   set(me.done_movement, true),
		   map(creatures, set(value.spaces_moved_this_turn, 0)),
		   map(filter(creatures, value.controller = current_player and not ('Exhausted' in value.status_effects)),
		       { execute: q(creature.do_move(game)), arg: {creature: value, game: me} }),
		   map(filter(creatures, value.controller = current_player and not ('Exhausted' in value.status_effects)),
		       { execute: q(creature.fire_event('on_move', [game])), arg: {creature: value, game: me} })
			   ]",


		do_first_strike_attacks: "
		   map(filter(creatures, ('First Strike' in value.abilities) and not ('Exhausted' in value.status_effects)),
		       { execute: q(creature.do_attack(game)), arg: {creature: value, game: me} })",
		do_attacks: "
		   map(filter(creatures, (not ('First Strike' in value.abilities)) and not ('Exhausted' in value.status_effects)),
		       { execute: q(creature.do_attack(game)), arg: {creature: value, game: me} })",

		do_trampling: "if(find(creatures, ('Trampling' in value.status_effects)), [
		  map(filter(creatures, ('Trampling' in value.status_effects)),
		    { execute: q(creature.do_trample_move(game)), arg: {creature: value, game: me} }),
		  { execute: q(game.do_first_strike_attacks), arg: {game: me} },
		  { execute: q(game.do_attacks), arg: {game: me} },
		  { execute: q(game.cleanup_trampling), arg: {game: me} },
		])",

		cleanup_trampling: "map(me.creatures, set(value.status_effects, filter(value.status_effects, value != 'Trampling')))",
		
		do_endzone: "[
		  map(filter(creatures, is_loc_in_endzone(value.loc, value.controller)), [value.fire_event('on_reach_endzone', [me])]),
		  set(me.creatures, filter(creatures, not is_loc_in_endzone(value.loc, value.controller))),
		  [add(me.graveyard, {(creature.summon_id): creature}) | creature <- creatures, is_loc_in_endzone(creature.loc, creature.controller)],
		]",

		fire_creature_event: "def(event_name, args=[])
			map(permanents_and_avatars, value.fire_event(event_name, [me] + args))
		",

		do_begin_turn: "map(permanents_and_avatars, value.begin_turn(me))",
		do_end_turn: "map(permanents_and_avatars, value.end_turn(me))",

		// any creatures in the graveyard have cards dis-assocated with them,
		// and those cards moved to their owner's discard pile.
		do_cleanup_graveyard: " [
			map(me.graveyard, if(value.card_name, [
				add(players[value.controller].discard_pile, [value.card_name]),
				set(value.card_name, null)
			]))
		]
		",

		end_turn: "def(info)
		  if(stack != [], [
			set(me.stack, stack[0:size(stack)-1]),
			{ execute: q(if(card.ability, game.resolve_ability(card), game.resolve_card(card))), arg: {game: me, card: stack.last} },
		   ],
		   if(not done_movement, movement(info),
		   if(precombat_phase, if((response_played or precombat_phase = 1) and players[(current_player+1)%size(players)].has_possible_response(me),
				    [add(me.precombat_phase, 1), set(me.response_played, false)],
				    [set(me.precombat_phase, 0), combat(info)]),
		   [
		   set(me.animation_hints, []),
		   add(me.animation_hints_id, 1),

		   state_based_actions,

		   { execute: q(game.do_end_turn), arg: {game: me}},
		   { execute: q(game.do_cleanup_graveyard), arg: {game: me}},
		   players[private.nturn%size(players)].end_turn(me, info.keep),
		   state_based_actions,

		   log_message(players[next_player].name + ', Turn ' + ((me.private.nturn+1)/size(players)+1)),
			   
		   add(me.private.nturn, 1),
		   set(me.done_movement, false),
		   set(me.precombat_phase, 0),
		   set(me.response_played, false),
		   players[(private.nturn+1)%size(players)].begin_turn(me),
		   map(me.permanents, if(value.controller = next_player, value.increment_summoning)),
		   { execute: q(game.do_begin_turn), arg: {game: me} },
		   ])))",

		movement: "def(info)
		   if(not done_movement, [
		     { execute: q(game.do_moves), arg: {game: me}},
		     state_based_actions,
		     { execute: q(game.do_endzone), arg: {game: me}},
		     state_based_actions,

			 if(players[next_player].has_possible_response(me),
				[
			      add(me.precombat_phase, 1),
			      set(me.response_played, false)
				],
			 if(players[(next_player+1)%size(players)].has_possible_response(me),
				[
			      add(me.precombat_phase, 2),
			      set(me.response_played, false)
				],

				[
				  set(me.precombat_phase, 0),
			      set(me.response_played, false),
				  { execute: q(game.combat(info)), arg: {game: me, info: info} },
				  if(info.type = 'end_turn',
					//the player asked to end the turn, not just do movement
					//and there was no response, so end turn.
				    { execute: q(game.end_turn(info)), arg: {game: me, info: info} },
				   )
				])
			  )
		   ])
		",

		combat: "def(info) [

		   //first strike combat
		   if(find(creatures, 'First Strike' in value.abilities),
			[
		      { execute: q(game.do_first_strike_attacks), arg: {game: me}},
		      state_based_actions
			]),
		   
		   //regular combat.
		   { execute: q(game.do_attacks), arg: {game: me}},

		   state_based_actions,

		   { execute: q(game.do_trampling), arg: {game: me}},
		   state_based_actions,
		   { execute: q(game.do_endzone), arg: {game: me}},
		]
		",

		locs_adjacent: "def(a, b)
		  a[0] = b[0] and abs(a[1] - b[1]) = 1 or  //same row
		  abs(a[0] - b[0]) = 1  and (a[1] = b[1] or //one row apart
		        abs(a[1] - b[1]) = 1 and
				  ((a[0]%2 = 0 and a[1] = b[1]+1) or 
				   (a[0]%2 = 1 and a[1] = b[1]-1)))",

		all_locs: "[[row,col] | row <- range(rows), col <- range(columns)]",

		is_loc_on_board: "def(loc) loc[0] >= 0 and loc[0] < rows and
		                           loc[1] >= 0 and loc[1] < columns",
		is_loc_in_endzone: "def(loc, controller) loc[0] >= 0 and loc[0] < rows and
		                         (controller = 0 and loc[1] = columns or
								  controller = 1 and loc[1] = -1)",
		construct_at_loc: "def(loc) find(constructs, value.loc = loc)",
		creature_at_loc: "def(loc) find(creatures, value.loc = loc)",
		creature_by_summon_id: "def(id) find(creatures, value.summon_id = id) or graveyard[id]",
	},

	test: [
		{ command: "set(vars.game, construct('game', {players: [construct('player')]}))",
		  assert: "vars.game.rows = 6 and vars.game.columns = 9" }
	]
}
