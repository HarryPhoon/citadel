{
	private: {
		nturn: 0,
		creature_summon_id: 10,
		log: [],
	},

	constructor: "[
	   set(terrain, {([1,2]): {type: 'forest'},
	                 ([1,6]): {type: 'forest'},
					 ([4,4]): {type: 'mountain'}}),
	   add(me.creatures, map(
	     map([1,2,3,4,5],
	       {
			  name: 'Guard Tower',
			  controller: -1,
			  attack: if(value = 1, 2, 1),
			  range: 2,
			  life: if(value = 1, 4, 3),
			  is_building: true,
			  image_num: 6,
			  summoning_time: 0,
			  loc: village_locs[value],
			  summon_id: 1 + index
		   }), construct('creature', value))),
	   set(me.villages,
	       fold(map(village_locs,
		            {(value): {owner: -1, type: -1,
					           level: [0,0,0,1,2,1,0,0,0][value[1]]}}), a+b))
	  ]
	      where village_locs =
		    fold(map(range(5), [loc, [loc[0], 8 - loc[1]]]
		         where loc = [[2,4], [0,3], [4,3], [2,1], [3,2]][value]), a + b)
	",
	properties: {
		nplayer: { variable: true },
		players: { variable: true },
		current_player: "(private.nturn + response_phase)%size(players)",
		next_player: "(private.nturn + response_phase+1)%size(players)",

		player_init: "def(player) if(player.player_index = 0, player.begin_turn(me))",

		turn: "private.nturn",
		response_phase: { variable: true, default: 0 },
		response_played: { variable: true, default: false },
		done_movement: { variable: true, default: false },

		log_message: "def(msg) add(private.log, [msg])",
		log: "private.log",

		creatures: { variable: true, default: [] },

		//creatures being summoned.
		summonings: { variable: true, default: [] },

		//dead creatures, keyed by summon_id.
		graveyard: { variable: true, default: {} },

		villages: { variable: true, default: {} },

		//maps loc -> terrain
		terrain: { variable: true, default: {} },

		terrain_at_loc: "def(loc) if(t, t.type) where t = terrain[loc]",

		capture: "def(loc, owner, type) if(me.villages[loc] != null,
		    [set(me.villages[loc].owner, owner),
			 set(me.villages[loc].type, type)])",

		rows: { variable: true, default: 5},
		columns: { variable: true, default: 9},

		process_moves: "def(info)
		  map(info.moves, { execute: q(game.process_game_move(move)), arg: { game: me, move: value } })
		",

		process_game_move: "def(info)
		  switch(info.type,
		     'discard', me.discard_cards(info),
			 'play_card', me.play_card(info),
			 'play_ability', me.play_ability(info),
			 'end_turn', me.end_turn(info),
			 'movement', me.movement(info),
			 log_message('bad message received: ' + info.type)
		  )
		",

		discard_cards: "def(info) players[current_player].discard_cards(info.indexes)",

		play_ability: "def(info) [if(creature, ([
		  player.spend(ability.school, ability.cost, ability.loyalty_cost),
		  ability.on_play(me, creature, info),
		  state_based_actions,
		  set(me.response_played, true)
		] asserting ability, player.can_afford(ability.school, ability.cost, ability.loyalty_cost),
		  response_phase = 0 or ability.is_response)
		  where ability = find(creature.abilities, value.name = info.ability)
		 )
		  where creature = find(creatures, value.summon_id = info.creature)
		  where player = players[current_player]]",

		play_card: "def(info) [
		  log_message(player.name + ' plays ' + player.hand[info.index].name),
		  player.spend(player.hand[info.index].school,
		               player.hand[info.index].cost,
					   player.hand[info.index].loyalty_cost),
		  set(player.hand, filter(player.hand, index != info.index)),
		  player.hand[info.index].on_play(me, info),
		  state_based_actions,
		  set(me.response_played, true),
		  player.level_up(player.hand[info.index].school)
		  ]
		  asserting info.index >= 0 and info.index < size(player.hand),
		            player.can_afford(player.hand[info.index].school,
					                  player.hand[info.index].cost,
									  player.hand[info.index].loyalty_cost),
					response_phase = 0 or player.hand[info.index].is_response
		  where player = players[current_player]",

		summon_creature: "def(new_creature) [
		  { execute: q([set(new_creature.summon_id, private.creature_summon_id),
		                add(private.creature_summon_id, 1)]),
			arg: { new_creature: new_creature, private: private } },
		  if(not new_creature.summoned,
		     add(me.summonings, [new_creature]),
			 add(me.creatures, [new_creature])),
		  { execute: q(new_creature.fire_event('on_summoned', [game])),
		     arg: { new_creature: new_creature, game: me} } ]",

		return_from_graveyard: "def(creature)
		if(me.graveyard[creature.summon_id], [
			set(me.graveyard, remove_from_map(me.graveyard, creature.summon_id)),
			add(me.creatures, [creature]) asserting (not (creature in me.creatures))
		])",

		remove_static_effects: "map(me.creatures, value.remove_static_effects())",
		apply_static_effects: "map(me.creatures, value.apply_static_abilities(me))",
		state_based_actions_internal: "[
			set(me.summonings, filter(me.summonings, not value.summoned)),
		    set(me.creatures, new_creatures),
			map(me.creatures, if(not value.alive, add(me.graveyard, {value.summon_id: value}))),
			map(me.creatures, if(not value.alive, { execute: q([creature.fire_events_on_death(game), creature.fire_event('on_die', [game])]), arg: {creature: value, game: me} })),
		 if(new_creatures != me.creatures, { execute: q(game.state_based_actions), arg: {game: me}})]
				 
			where new_creatures = filter(me.creatures, value.alive) + filter(me.summonings, value.summoned)
				 ",

		state_based_actions: "
		 [
		   { execute: q(game.remove_static_effects), arg: {game: me}},
		   { execute: q(game.apply_static_effects), arg: {game: me}},
		   { execute: q(game.state_based_actions_internal), arg: {game: me}},
		 ]
		",

		do_moves: "[
		   set(me.done_movement, true),
		   map(creatures, set(value.spaces_moved_this_turn, 0)),
		   map(filter(creatures, value.controller = current_player),
		       { execute: q(creature.do_move(game)), arg: {creature: value, game: me} }),
		   map(filter(creatures, value.controller = current_player),
		       { execute: q(creature.fire_event('on_move', game)), arg: {creature: value, game: me} })
			   ]",


		do_first_strike_attacks: "
		   map(filter(creatures, 'First Strike' in value.abilities),
		       { execute: q(creature.do_attack(game)), arg: {creature: value, game: me} })",
		do_attacks: "
		   map(filter(creatures, not ('First Strike' in value.abilities)),
		       { execute: q(creature.do_attack(game)), arg: {creature: value, game: me} })",

		do_endzone: "[
		  map(filter(creatures, is_loc_in_endzone(value.loc, value.controller)), [value.fire_event('on_reach_endzone', [me])]),
		  set(me.creatures, filter(creatures, not is_loc_in_endzone(value.loc, value.controller))),
		  [add(me.graveyard, {(creature.summon_id): creature}) | creature <- creatures, is_loc_in_endzone(creature.loc, creature.controller)],
		]",

		do_summonings: "[
			map(filter(me.summonings, value.controller = current_player), value.increment_summoning),
			{ execute: q(game.do_summonings_internal), arg: {game: me}}
		]",

		do_summonings_internal: "[
			set(me.summonings, filter(me.summonings, not value.summoned)),
			add(me.creatures, filter(me.summonings, value.summoned)),
		]",

		fire_creature_event: "def(event_name, args=[])
			map(creatures, value.fire_event(event_name, [me] + args))
		",

		do_begin_turn: "fire_creature_event('on_begin_turn')",
		do_end_turn: "fire_creature_event('on_end_turn')",

		end_turn: "def(info)
		   if(not done_movement, movement(info),
		   if(response_phase, if(response_played and players[(current_player+1)%size(players)].has_possible_response(me),
				    [add(me.response_phase, 1), set(me.response_played, false)],
				    [set(me.response_phase, 0), combat(info)]),
		   [
		   state_based_actions,

		   { execute: q(game.do_summonings), arg: {game: me}},
		   { execute: q(game.do_end_turn), arg: {game: me}},
		   state_based_actions,

		   log_message(players[next_player].name + ', Turn ' + ((me.private.nturn+1)/size(players)+1)),
			   
		   add(me.private.nturn, 1),
		   set(me.done_movement, false),
		   set(me.response_phase, 0),
		   set(me.response_played, false),
		   players[(private.nturn+1)%size(players)].begin_turn(me),
		   players[(private.nturn+1)%size(players)].draw_cards(1),
		   { execute: q(game.do_begin_turn), arg: {game: me} },
		   ]))",

		movement: "def(info)
		   if(not done_movement, [
		     { execute: q(game.do_moves), arg: {game: me}},
		     state_based_actions,
		     { execute: q(game.do_endzone), arg: {game: me}},
		     state_based_actions,

			 if(players[next_player].has_possible_response(me),
				[
			      add(me.response_phase, 1),
			      set(me.response_played, false)
				],
				[
				  set(me.response_phase, 0),
			      set(me.response_played, false),
				  { execute: q(game.combat(info)), arg: {game: me, info: info} },
				  if(info.type = 'end_turn',
					//the player asked to end the turn, not just do movement
					//and there was no response, so end turn.
				    { execute: q(game.end_turn(info)), arg: {game: me, info: info} },
				   )
				]
			  )
		   ])
		",

		combat: "def(info) [

		   //first strike combat
		   if(find(creatures, 'First Strike' in value.abilities),
			[
		      { execute: q(game.do_first_strike_attacks), arg: {game: me}},
		      state_based_actions
			]),
		   
		   //regular combat.
		   { execute: q(game.do_attacks), arg: {game: me}},
		   state_based_actions,
		]
		",

		locs_adjacent: "def(a, b)
		  a[0] = b[0] and abs(a[1] - b[1]) = 1 or  //same row
		  abs(a[0] - b[0]) = 1  and (a[1] = b[1] or //one row apart
		        abs(a[1] - b[1]) = 1 and
				  ((a[0]%2 = 0 and a[1] = b[1]+1) or 
				   (a[0]%2 = 1 and a[1] = b[1]-1)))",

		is_loc_on_board: "def(loc) loc[0] >= 0 and loc[0] < rows and
		                           loc[1] >= 0 and loc[1] < columns",
		is_loc_in_endzone: "def(loc, controller) loc[0] >= 0 and loc[0] < rows and
		                         (controller = 0 and loc[1] = columns or
								  controller = 1 and loc[1] = -1)",
		creature_at_loc: "def(loc) find(creatures, value.loc = loc) or find(summonings, value.loc = loc)",
		summoned_creature_at_loc: "def(loc) find(creatures, value.loc = loc)",
	},

	test: [
		{ command: "set(vars.game, construct('game', {players: [construct('player')]}))",
		  assert: "vars.game.rows = 5 and vars.game.columns = 9" }
	]
}
