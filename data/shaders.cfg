{
    "shaders": {
		////////////////////////////////////////////////////////////////
		// vertex shaders
        "vertex": {

            "basic_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec4 a_position;
                attribute vec2 a_texcoord;
                varying vec2 v_texcoord;
                void main()
                {
                    v_texcoord = a_texcoord;
                    gl_Position = u_mvp_matrix * a_position;
                }",

			"card_halo_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec2 a_position;
				attribute vec2 a_texcoord;
                varying vec2 v_texcoord;
				void main()
				{
                    v_texcoord = a_texcoord;
					vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
					gl_Position = u_mvp_matrix * v;
				}",

	
            "card_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec4 a_position;
                attribute vec2 a_texcoord;
				uniform int resolve_cycle;
				uniform int fizzle_cycle;
                varying vec2 v_texcoord;
                void main()
                {
                    v_texcoord = a_texcoord;
                    gl_Position = u_mvp_matrix * a_position;
					if(resolve_cycle > 0) {
						if(v_texcoord[0] > 0.05) {
							gl_Position[0] += float(resolve_cycle)/400.0;
						} else {
							gl_Position[0] -= float(resolve_cycle)/400.0;
						}

						if(v_texcoord[1] > 0.05) {
							gl_Position[1] -= float(resolve_cycle)/200.0;
						} else {
							gl_Position[1] += float(resolve_cycle)/200.0;
						}
					}
                }",
						
            "tile_shader_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec4 a_position;
                attribute vec2 a_texcoord;
                varying vec2 v_texcoord;
                void main()
                {
                    v_texcoord = a_texcoord;
                    gl_Position = u_mvp_matrix * a_position;
                }
			",
			
			particle1_v: "
				#version 120
                uniform mat4 u_mvp_matrix;
				uniform int u_cycle;
				uniform int u_start_cycle;
				uniform int u_end_cycle;
				uniform vec2 u_centre_position;
                attribute vec2 a_position;
				attribute float a_start_cycle;
				varying float v_lifetime;
                void main()
                {
					float cycle = float(u_cycle - u_start_cycle);
					if(u_cycle >= u_start_cycle && u_cycle < u_end_cycle && cycle >= a_start_cycle) {
						vec4 v = vec4(a_position.x + u_centre_position.x, a_position.y + u_centre_position.y - cycle, 0.0, 1.0);
						gl_Position = u_mvp_matrix * v;
						v_lifetime = clamp(100.0 / cycle, 0.0, 1.0);
					} else {
						gl_Position = vec4(-3000, -3000, 0, 0);
						v_lifetime = 0.0;
					}
					gl_PointSize = 10.0;
                }
			",
				
        },
		
		////////////////////////////////////////////////////////////////
		// fragment shaders
        "fragment": {

            "hurt_flash_f": "
                uniform sampler2D u_tex_map;
				uniform vec4 u_color;
				varying vec2 v_texcoord;
				uniform int start_cycle;
				uniform int end_cycle;
				uniform int cycle;
				uniform bool is_poisoned;
                void main()
                {
					vec4 col = u_color;
					float cf = mod(cycle - start_cycle, 5) / 5.0;
					if(is_poisoned) {
						col *= vec4(0.0, 0.8, 0.0, 0.5);
					}
					if(cycle >= start_cycle && cycle < end_cycle && cf > 0.5) {
						col *= vec4(1.0, 0.0, 0.0, 0.8);
					}
                    gl_FragColor = texture2D(u_tex_map, v_texcoord) * col;
                }",

			"card_halo_f": "
                varying vec2 v_texcoord;
				void main()
				{
					gl_FragColor[0] = 1.0;
					gl_FragColor[1] = 1.0;
					gl_FragColor[2] = 1.0;
					gl_FragColor[3] = 1.0;

					float edge = 0.1;

					if(v_texcoord[0] < edge) {
						float ratio = v_texcoord[0]/edge;
						gl_FragColor[3] = gl_FragColor[3]*ratio;
					} else if(v_texcoord[0] > 1.0 - edge) {
						float ratio = (1.0 - v_texcoord[0])/edge;
						gl_FragColor[3] = gl_FragColor[3]*ratio;
					}

					if(v_texcoord[1] < edge) {
						float ratio = v_texcoord[1]/edge;
						gl_FragColor[3] = gl_FragColor[3]*ratio;
					} else if(v_texcoord[1] > 1.0 - edge) {
						float ratio = (1.0 - v_texcoord[1])/edge;
						gl_FragColor[3] = gl_FragColor[3]*ratio;
					}
				}
			",
	
            "card_f": "
                uniform sampler2D u_tex_map;
                uniform sampler2D u_tex_noise;
				uniform vec4 u_color;
				varying vec2 v_texcoord;
				uniform int resolve_cycle;
				uniform int fizzle_cycle;
                void main()
                {
					vec4 col = u_color;
					if(resolve_cycle > 0) {
						col[3] = 1.0;
                    	gl_FragColor = texture2D(u_tex_map, v_texcoord)*col;
						if(resolve_cycle < 10) {
							float ratio = sin(float(resolve_cycle)*3.14/10.0)*0.5;
							gl_FragColor[0] += (1.0 - gl_FragColor[0])*ratio;
							gl_FragColor[1] += (1.0 - gl_FragColor[1])*ratio;
							gl_FragColor[2] += (1.0 - gl_FragColor[2])*ratio;
						}

						gl_FragColor[3] = 1.0 - float(resolve_cycle)/50.0;
					} else if(fizzle_cycle > 0) {
                    	gl_FragColor = texture2D(u_tex_map, v_texcoord) * col;

						if(float(fizzle_cycle)/25.0 > texture2D(u_tex_noise, v_texcoord)[0]) {
							gl_FragColor[3] = 0.0;
						}
					} else {
                    	gl_FragColor = texture2D(u_tex_map, v_texcoord) * col;
					}
                }",
						
            "tile_shader_f": "
                uniform sampler2D u_tex_map;
				uniform vec4 u_color;
                uniform bool do_highlight;
				varying vec2 v_texcoord;
                void main()
                {
					vec4 col;
                    if(do_highlight) {
                        gl_FragColor = texture2D(u_tex_map, v_texcoord) * u_color;
                        gl_FragColor = clamp(gl_FragColor * 1.3, 0.0, 1.0);
					} else { 
						gl_FragColor = texture2D(u_tex_map, v_texcoord) * u_color;
					}
                }
			",
			
			particle1_f: "
				#version 120
                uniform sampler2D u_tex_map;
				uniform vec4 u_color;
				varying float v_lifetime;
                void main()
                {
					vec4 texColor = texture2D(u_tex_map, gl_PointCoord);
					gl_FragColor = u_color * texColor;
					gl_FragColor.a *= v_lifetime;
				}
			",
				
		},
	},
    
    "programs": [
        {
            "name": "hurt_flash", 
            "vertex": "basic_v", 
            "fragment": "hurt_flash_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
				"color": "u_color",
			},
        },

		{
			name: "card",
			vertex: "card_v",
			fragment: "card_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
				"color": "u_color",
			},
		},

		{
			name: "card_halo",
			vertex: "card_halo_v",
			fragment: "card_halo_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
			},
		},
        
        {
            "name": "tile_shader", 
            "vertex": "tile_shader_v", 
            "fragment": "tile_shader_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
				"color": "u_color",
			},
        },
 		{
			"name": "particle1",
			"vertex": "particle1_v",
			"fragment": "particle1_f",
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
			},
		},
   ],
}
