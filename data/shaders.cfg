{
    "shaders": {
		////////////////////////////////////////////////////////////////
		// vertex shaders
        "vertex": {

            "basic_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec4 a_position;
                attribute vec2 a_texcoord;
                varying vec2 v_texcoord;
                void main()
                {
                    v_texcoord = a_texcoord;
                    gl_Position = u_mvp_matrix * a_position;
                }",

            "card_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec4 a_position;
                attribute vec2 a_texcoord;
				uniform int resolve_cycle;
				uniform int fizzle_cycle;
                varying vec2 v_texcoord;
                void main()
                {
                    v_texcoord = a_texcoord;
                    gl_Position = u_mvp_matrix * a_position;
					if(resolve_cycle > 0) {
						if(v_texcoord[0] > 0.05) {
							gl_Position[0] += float(resolve_cycle)/400.0;
						} else {
							gl_Position[0] -= float(resolve_cycle)/400.0;
						}

						if(v_texcoord[1] > 0.05) {
							gl_Position[1] -= float(resolve_cycle)/200.0;
						} else {
							gl_Position[1] += float(resolve_cycle)/200.0;
						}
					}
                }",
						
            "tile_shader_v": "
                uniform mat4 u_mvp_matrix;
                attribute vec4 a_position;
                attribute vec2 a_texcoord;
                varying vec2 v_texcoord;
                void main()
                {
                    v_texcoord = a_texcoord;
                    gl_Position = u_mvp_matrix * a_position;
                }
			",
			
			particle1_v: "
				#version 120
                uniform mat4 u_mvp_matrix;
				uniform int u_cycle;
				uniform int u_start_cycle;
				uniform int u_end_cycle;
				uniform vec2 u_centre_position;
                attribute vec2 a_position;
				attribute float a_start_cycle;
				varying float v_lifetime;
                void main()
                {
					float cycle = float(u_cycle - u_start_cycle);
					if(u_cycle >= u_start_cycle && u_cycle < u_end_cycle && cycle >= a_start_cycle) {
						vec4 v = vec4(a_position.x + u_centre_position.x, a_position.y + u_centre_position.y - cycle, 0.0, 1.0);
						gl_Position = u_mvp_matrix * v;
						v_lifetime = clamp(100.0 / cycle, 0.0, 1.0);
					} else {
						gl_Position = vec4(-3000, -3000, 0, 0);
						v_lifetime = 0.0;
					}
					gl_PointSize = 10.0;
                }
			",
				
        },
		
		////////////////////////////////////////////////////////////////
		// fragment shaders
        "fragment": {

            "hurt_flash_f": "
            	#version 120
                uniform sampler2D u_tex_map;
				uniform vec4 u_color;
				varying vec2 v_texcoord;
				uniform int start_cycle;
				uniform int end_cycle;
				uniform int cycle;
				uniform bool is_poisoned;
                void main()
                {
					vec4 col = u_color;
					float cf = mod(cycle - start_cycle, 5) / 5.0;
					if(is_poisoned) {
						col *= vec4(0.0, 0.8, 0.0, 0.5);
					}
					if(cycle >= start_cycle && cycle < end_cycle && cf > 0.5) {
						col *= vec4(1.0, 0.0, 0.0, 0.8);
					}
                    gl_FragColor = texture2D(u_tex_map, v_texcoord) * col;
                }",

            "card_f": "
                uniform sampler2D u_tex_map;
                uniform sampler2D u_tex_noise;
				uniform vec4 u_color;
				varying vec2 v_texcoord;
				uniform int resolve_cycle;
				uniform int fizzle_cycle;
                void main()
                {
					vec4 col = u_color;
					if(resolve_cycle > 0) {
						col[3] = 1.0;
                    	gl_FragColor = texture2D(u_tex_map, v_texcoord)*col;
						if(resolve_cycle < 10) {
							float ratio = sin(float(resolve_cycle)*3.14/10.0)*0.5;
							gl_FragColor[0] += (1.0 - gl_FragColor[0])*ratio;
							gl_FragColor[1] += (1.0 - gl_FragColor[1])*ratio;
							gl_FragColor[2] += (1.0 - gl_FragColor[2])*ratio;
						}

						gl_FragColor[3] = 1.0 - float(resolve_cycle)/50.0;
					} else if(fizzle_cycle > 0) {
                    	gl_FragColor = texture2D(u_tex_map, v_texcoord) * col;

						if(float(fizzle_cycle)/25.0 > texture2D(u_tex_noise, v_texcoord)[0]) {
							gl_FragColor[3] = 0.0;
						}
					} else {
                    	gl_FragColor = texture2D(u_tex_map, v_texcoord) * col;
					}
                }",
						
            "tile_shader_f": "
                uniform sampler2D u_tex_map;
				uniform vec4 u_color;
                uniform bool do_highlight;
				varying vec2 v_texcoord;
                void main()
                {
					vec4 col;
                    if(do_highlight) {
                        gl_FragColor = texture2D(u_tex_map, v_texcoord) * u_color;
                        gl_FragColor = clamp(gl_FragColor * 1.3, 0.0, 1.0);
					} else { 
						gl_FragColor = texture2D(u_tex_map, v_texcoord) * u_color;
					}
                }
			",
			
			particle1_f: "
				#version 120
                uniform sampler2D u_tex_map;
				uniform vec4 u_color;
				varying float v_lifetime;
                void main()
                {
					vec4 texColor = texture2D(u_tex_map, gl_PointCoord);
					gl_FragColor = u_color * texColor;
					gl_FragColor.a *= v_lifetime;
				}
			",
				
		},
	},
    
    "programs": [
        {
            "name": "hurt_flash", 
            "vertex": "basic_v", 
            "fragment": "hurt_flash_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
				"color": "u_color",
			},
        },

		{
			name: "card",
			vertex: "card_v",
			fragment: "card_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
				"color": "u_color",
			},
		},
        
        {
            "name": "tile_shader", 
            "vertex": "tile_shader_v", 
            "fragment": "tile_shader_f",
            "attributes": {
                "vertex": "a_position",
                "texcoord": "a_texcoord",
            },
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
				"color": "u_color",
			},
        },
 		{
			"name": "particle1",
			"vertex": "particle1_v",
			"fragment": "particle1_f",
			"uniforms": {
				"mvp_matrix": "u_mvp_matrix",
			},
		},
   ],

   instances: [
   {
		name: "citadel_board_shader",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",

		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_hex_tex;
			uniform float u_hex_intensity[84];
			uniform float u_level_width;
			uniform float u_level_height;
			uniform float u_cycle;
			//uniform sampler2D u_hex_tex2;
			//uniform float u_intensity;
			//uniform vec4 u_water_area[2];
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				gl_FragColor = texture2D(u_anura_tex_map, v_texcoord);

				vec2 hex_coord = vec2(v_texcoord[0]*u_level_width/1024.0 + sin(u_cycle/1000.0), v_texcoord[1]*u_level_height/512.0 + 2.0*cos(u_cycle/1824.0));

				vec4 hex_color = texture2D(u_hex_tex, hex_coord);
				int xindex = int(hex_color[0]*12.0);
				int yindex = int(hex_color[1]*7.0);
				int index = xindex*6 + yindex;

				if(hex_color[3] != 1 || u_cycle < 1) {
					return;
				}

				//calculate intensity_mul which multiplies the intensity based
				//on x position to make it fade out at the edges
				float intensity_mul = 0.0;
				if(v_texcoord[0] >= 0.3 && v_texcoord[0] <= 0.7) {
					intensity_mul = 1.0;
				} else if(v_texcoord[0] >= 0.1 && v_texcoord[0] <= 0.9) {
					if(v_texcoord[0] < 0.5) {
						intensity_mul = (v_texcoord[0] - 0.1)*5.0;
					} else {
						intensity_mul = (0.9 - v_texcoord[0])*5.0;
					}

					//easing formula
					intensity_mul = 0.5*(1 - cos(intensity_mul*3.14));
				} else {
					return;
				}

				float dodge_ratio = 0.4;
				float inv_dodge_ratio = 1.0 - dodge_ratio;

				vec3 base_color;
				if(mod(xindex,2) == 0) {
					if(mod(yindex,2) == 0) {
						//base_color = vec3(1,0,0);
						base_color = vec3(0.110, 0.149, 0.141);
					} else {
						//base_color = vec3(0,1,0);
						base_color = vec3(0.106, 0.145, 0.145);
					}
				} else {
					if(mod(yindex,2) == 0) {
						//base_color = vec3(1,1,1);
						base_color = vec3(0.11, 0.12, 0.12);
					} else {
						//base_color = vec3(1,1,0);
						base_color = vec3(0.1333, 0.1412, 0.137);
					}
				}

				vec3 dodge_color = base_color * (0.5 + u_hex_intensity[index]*0.5) * intensity_mul;

				gl_FragColor[0] = gl_FragColor[0]*inv_dodge_ratio + dodge_ratio*gl_FragColor[0]/(1 - dodge_color[0]);
				gl_FragColor[1] = gl_FragColor[1]*inv_dodge_ratio + dodge_ratio*gl_FragColor[1]/(1 - dodge_color[1]);
				gl_FragColor[2] = gl_FragColor[2]*inv_dodge_ratio + dodge_ratio*gl_FragColor[2]/(1 - dodge_color[2]);
			}
		",

		draw: "[
			bind_texture(load_texture('hex_2.png').id, 1),
			//bind_texture(load_texture('hex_2.png').id, 2),
			set(uniform_commands.u_hex_tex, 1),
			set(uniform_commands.u_hex_intensity, find(level.chars, value is obj citadel_controller).background_hex_intensity),
			set(uniform_commands.u_level_width, level.dimensions[2]),
			set(uniform_commands.u_level_height, level.dimensions[3]),
			set(uniform_commands.u_cycle, level.cycle),
			//set(uniform_commands.u_hex_tex2, 2),
		]",
	}],
}
