{
	id: "matchmaking_base",

	properties: {
		_mm_client_state: { type: "class mm_client_state", dynamic_initialization: true },
		mm_client: "object|null :: _mm_client_state.client",
		account_info: "AccountDetails :: _mm_client_state.account_info",
		username: "string :: _mm_client_state.username",

		//selected_deck: { type: "string", default: "" },

		get_server_info: "commands<- if(mm_client != null, [tbs_send(mm_client, {type: 'get_server_info'})])",

		is_online: "bool :: mm_client != null",

		award_cards: "def([string] card_names, int gold) ->commands null",

		get_player_status: "def() ->string 'idle'",

		_current_throttling_baseline: { type: "int|null" },
		_requests_sent: { type: "int", default: 0 },
		_throttled: { type: "bool", default: false },

		_known_state_id: { type: "null|int" },

		_request_server_info: "bool :: false",

		process_matchmaking_connection: "def() ->commands
		execute(me,
		if(mm_client != null and not _throttled, [
			if(mm_client.in_flight = 0, [
				set(lib.citadel.notified_status, [username,get_player_status()]),
				if(throttling_baseline != _current_throttling_baseline, set(_requests_sent, 0)),
				add(_requests_sent, 1),
				tbs_send(mm_client, {type: 'request_updates', status: get_player_status(), info_version: _mm_client_state.account_info_version, state_id: _known_state_id, request_server_info: _request_server_info}),
				set(_current_throttling_baseline, throttling_baseline),
				if(_requests_sent >= 10, [
					set(_throttled, true),
					schedule(60*30, set(_throttled, false)),
				]),
			] where throttling_baseline = cycle%600,
			
			if([username,get_player_status()] != lib.citadel.notified_status, [
				set(lib.citadel.notified_status, [username,get_player_status()]),
				tbs_send(mm_client, {type: 'status_change', status: get_player_status()})
			])),
			tbs_process(mm_client),
		])
		)",

		//function which tells us if we should notify when a player queues up for multiplayer
		should_notify_multiplayer_queue: "def() ->bool true",

		_last_notify_multiplayer: { type: "int|null" },
		notify_multiplayer_queue: "def(string username) ->commands
		if(should_notify_multiplayer_queue() and ('MULTIPLAYER' in _mm_client_state.account_info.unlocks) and (_last_notify_multiplayer = null or cycle > _last_notify_multiplayer + 500), [
			spawn_notification(username + q( is searching for a multiplayer game right now. Click here to go to the <i>Multiplayer Lobby</i> if you want to play with them!), execute(me, fire_event('go_multiplayer')))
		])",

		notify_challenge: "def(string username) ->commands
		[
		add(lib.citadel.open_challenges, [{user: username, expiry_time: time().unix + 60}]),
		if(should_notify_multiplayer_queue() and not multi_lobby_controller,
			spawn_notification(username + q( has challenged you to a game! Click here to go to the multiplayer lobby to play them.), bind_command(me.click_challenge, username))
		);
		if(multi_lobby_controller, multi_lobby_controller.update_challenges())
		] where multi_lobby_controller = find(level.chars, value is obj multi_lobby_controller)
		",

		click_challenge: "def(string username) ->commands
		[
		debug(['CLICK CHALLENGE', type]),
		if(title_controller != null,
			if(title_controller.get_screen_controller and not title_controller.in_multi_lobby,
				title_controller.transition_screen(; execute(title_controller.get_screen_controller, title_controller.enter_multi(title_controller.get_screen_controller)))
			)
		) where title_controller = find(level.chars, value is obj title_controller)
		]
		",

		spawn_notification: "def(string text, commands on_click=null) ->commands [
			spawn('notification_toast', 0, 0, { _text: text, _on_click: on_click })
		]",

		send_user_command: "def(map msg) ->commands [
			execute(me, tbs_send(object<- mm_client, { type: 'user_operation' } + msg))
		]",

		do_auto_login: "def(string cookie) ->commands [
			debug('TRY auto login'),
			set(_mm_client_state.client, cl),
			execute(me, tbs_send(cl, {
				type: 'auto_login',
				cookie: cookie,
			})),
		] where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, { id: 'matchmake' })",

		complete_login: "def(int session_id, string username, string|null cookie, AccountDetails info, int info_version) ->commands [
			debug('TRY COMPLETE LOGIN: ' + str(session_id)),
			lib.citadel.write_cookie(cookie),

			set(me._mm_client_state, construct('mm_client_state', {
				client: tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, {
					session: session_id,
					id: 'matchmake'
				}),
				username: username,
				session_id: session_id,
				account_info_version: info_version,
				account_info: info,
				quests: if(info.quests is [Quest], map(info.quests, lib.quest.create(value)), []),
			}
			))
		]",

		update_account_info: "def(AccountDetails info, int info_version) ->commands [
			set(me._mm_client_state.account_info, info),
			set(me._mm_client_state.account_info_version, info_version),

			if(info.quests != _mm_client_state.account_info.quests, set(_mm_client_state.quests, if(info.quests is [Quest], map(info.quests, lib.quest.create(value)), []))),
		]",

		matchmaking_handle_message: "def(map message) ->commands [

	switch(message.type,
		'server_info', [
			if(message.bot_types, set(_mm_client_state.bot_types, [string]<- message.bot_types)),
		],
		'heartbeat', [

		] where user_list = [OnlineUser]<- message.user_list,

		'matchmaking_queued', [
		],

		'match_made', [
		],

		'challenge', [
			notify_challenge(string<- message.challenger)
		],

		'new_cards', [
			add(_mm_client_state.account_info.collection, new_cards),
			award_cards(map(new_cards, value.name), if(new_gold, new_gold, 0)),
			if(new_gold != null, add(_mm_client_state.account_info.gold, new_gold)),
		] where new_cards = [CardInstance]<- message.cards
		  where new_gold = int|null<- message.gold,

		'login_success', [
			complete_login(int<- message.session_id, string<- message.username, string|null<- message.cookie, AccountDetails<- message.info, int<- message.info_version)
		],

		'account_info', [
			update_account_info(AccountDetails<- message.info, int<- message.info_version)
		],

		'auto_login_fail', [
			teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0)),
		],

		'error', [
			if(message.message = 'unknown session', [
				if(cookie != null,
					do_auto_login(cookie),
					teleport('titlescreen.cfg', '', 'instant', object_playable('login_controller', 0, 0, 0))
				) where cookie = lib.citadel.read_cookie()
			],
			debug('Error message from server: ' + str(message.message))),
		],
	)
	]",

	play_interface_sound: "def(string name) ->commands execute(me,
		if(sfx is string, sound(sfx, lib.citadel.sound_volume(sfx)))
		where sfx = lib.citadel.choose_interface_sound(name)
	)
	",
	},

	timer_frequency: 5,

	on_go_multiplayer: "teleport('lobby.cfg', '', 'instant', playable)
	  where playable = object_playable('title_controller', 0, 0, 1, {
		_mm_client_state: _mm_client_state,
		_default_section: 2, //multiplayer tab.
	  })",

	on_timer: "process_matchmaking_connection()",

	on_matchmake_connection_error: "
		debug('Error in game server connection')
	",

	on_matchmake_message_received: "
		matchmaking_handle_message(map<- arg.message)
	"

}
