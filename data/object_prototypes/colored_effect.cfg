{
	id: "colored_effect",
	is_strict: true,

	properties: {
		custom_color: { type: "[decimal,decimal,decimal]", default: [0.0,0.0,0.0] },
		use_custom_color: "bool :: custom_color != [0.0,0.0,0.0]",
	},

	shader: {
		fragment: """
		uniform sampler2D u_anura_tex_map;
		uniform bool u_property_use_custom_color;
		uniform vec3 u_custom_color;
		varying vec2 v_texcoord;
		vec3 rgb_to_hsv(vec3 col) {
			float r = col[0];
			float g = col[1];
			float b = col[2];
			float max_col = max(max(r,g), b);
			float min_col = min(min(r,g), b);
			float delta = max_col - min_col;
			float h = 0.0;
			float s = 0.0;
			float v = max_col;
			vec3 hsv = vec3(0.0);
			if (max_col != 0.0) {
			  s = (max_col - min_col ) / max_col;
			}
			if (delta != 0.0) {
				if (r == max_col) {
					h = (g - b) / delta;
				} else if (g == max_col) {		
					h = 2.0 + (b - r) / delta;
				} else {	
					h = 4.0 + (r - g) / delta;
				}
				h *= 60.0;
				if (h < 0.0) {
					h += 360.0;
				}
			}
			hsv[0] = h;
			hsv[1] = s;
			hsv[2] = v;
			return hsv;
		}
		vec3 hsv_to_rgb(vec3 col) {
			float h = col.x;
			float s = col.y;
			float v = col.z;
			if (s == 0.0) {
				return vec3(v, v, v);
			}
			if (h == 360.0) {
				h = 0.0;
			}
			int hi = int(h);
			float f = h - float(hi);
			float p = v * (1.0 - s);
			float q = v * (1.0 - (s * f));
			float t = v * (1.0 - (s * (1.0 - f)));
			vec3 res;
			if (hi == 0) {
				res = vec3(v, t, p);
			} else if (hi == 1) {
				res = vec3(q, v, p);
			} else if (hi == 2) {
				res = vec3(p, v, t);
			} if(hi == 3) {
				res = vec3(p, q, v);
			} else if (hi == 4) {
				res = vec3(t, p, v);
			} else {
				res = vec3(v, p, q);
			}
			return res;
		}


		void main()
		{
			vec4 col = texture2D(u_anura_tex_map, v_texcoord);

			if(u_property_use_custom_color) {
				vec3 hsv = rgb_to_hsv(col.rgb);
				hsv[0] = rgb_to_hsv(u_custom_color)[0];
				col.rgb = hsv_to_rgb(hsv);
				
				gl_FragColor = col;
			} else {
				gl_FragColor = col;
			}
		}
		""",
	},
}
