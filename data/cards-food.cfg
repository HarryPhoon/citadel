{
	"Call of the Pack": {
		name: "Call of the Pack",
		type: "spell",
		cost: 5,
		loyalty_cost: 3,
		school: 3,
		rules: "Summon three 1/1/2 wolves. They each get +1 attack for each other wolf you control.",
		possible_targets: "def(game, nplayer, targets)
		   if(size(targets) = 3, null,
		      filter(game.players[nplayer].summoning_locs(game, construct('creature', {name: 'Wolf', school: 3, image_num: 5})),
			         not (value in targets)))",
		on_play: "def(game, info) map(info.targets, game.summon_creature(construct('creature', {
			name: 'Wolf',
			tags: ['Wolf'],
			school: 3,
			controller: game.current_player,
			loc: value,
			attack: 1,
			life: 1,
			move: 2,
			initiative: 20,
			image_num: 5,
			static_ability_effect: q(if(creature = target,
			   creature.apply_static_effect('attack', bonus) where bonus = count(game.creatures, value.controller = creature.controller and value != creature and ('Wolf' in value.tags))))

		})))"
	},

	"Nature's Blessing": {
		name: "Nature's Blessing",
		type: "spell",
		cost: 0,
		loyalty_cost: 4,
		school: 3,
		rules: "+2 Mana",
		on_play: "def(game, info) add(game.players[game.current_player].resources, 2)"
	},

	"Primal Rage": {
		name: "Primal Rage",
		type: "spell",
		cost: 2,
		loyalty_cost: 2,
		school: 3,
		is_response: true,
		rules: "Target creature gains +2 attack this turn",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info)
		   target.apply_effect_until_end_of_turn('attack', 2)
		   where target = game.creature_at_loc(info.targets[0])"
	},

	"Rampage": {
		name: "Rampage",
		type: "spell",
		cost: 4,
		loyalty_cost: 4,
		school: 3,
		is_response: true,
		rules: "Target creature gains +2 attack, +2 life, +2 move, and gains trample this turn",
		possible_targets: "def(game, nplayer, targets)
		  if(size(targets) > 0, null,
		   [creature.loc | creature <- game.creatures, not creature.is_building,
			       creature.is_valid_target(game, nplayer, me)])",
		on_play: "def(game, info) [
		   target.apply_effect_until_end_of_turn('attack', 2),
		   target.apply_effect_until_end_of_turn('life', 2),
		   target.apply_effect_until_end_of_turn('move', 2),
		   target.add_ability_until_end_of_turn('Trample')
		  ]
		   where target = game.creature_at_loc(info.targets[0])"
	},

	"Outsmart the Guards": {
		name: "Outsmart the Guards",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: 3,
		is_response: true,
		rules: "Swap position of two adjacent creatures in the same lane",
		possible_targets: "def(game, nplayer, targets)
		  if(size(targets) = 0,
		    [creature.loc | creature <- game.creatures,
			                not creature.is_building,
							creature.is_valid_target(game, nplayer, me)],
			if(size(targets) = 1,
		     [creature.loc | creature <- game.creatures,
			                 not creature.is_building,
							 creature.is_valid_target(game, nplayer, me),
							 creature.loc[0] = targets[0][0],
							 abs(creature.loc[1] - targets[0][1]) = 1],
			 null))",
		on_play: "def(game, info) [
			set(target_a.loc, target_b.loc),
			set(target_b.loc, target_a.loc),
		] where target_a = game.creature_at_loc(info.targets[0]),
		        target_b = game.creature_at_loc(info.targets[1])"
	},

	"Goblin King": {
		name: "Goblin King",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: 3,
		rules: "When Goblin King is summoned, it summons a goblin in each adjacent lane. Adjacent goblins get +1 attack, +1 life.",
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder'],
			image_num: 15,
			on_summoned: "def(game) map([[loc[0]-1,loc[1]], [loc[0]+1,loc[1]]],
			               if(game.is_loc_on_board(value) and
						      game.creature_at_loc(value) = null,
							  game.summon_creature(construct('creature',
							    {
									name: 'Goblin',
									school: 3,
									tags: ['Goblin'],
									abilities: ['Marauder'],
									attack: 1,
									life: 2,
									move: 2,
									image_num: 40,
									controller: controller,
									loc: value
								})
							  
							  )))",
			static_ability_effect: "if(creature != target and creature.controller = target.controller and game.locs_adjacent(creature.loc, target.loc) and ('Goblin' in target.tags),
			   [target.apply_static_effect('life', 1),
			    target.apply_static_effect('attack', 1)])",
			attack: 2,
			life: 3,
			move: 2,
			
		}
	},

	"Wolf Rider": {
		name: "Wolf Rider",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 3,
		creature: {
			tags: ['Mounted', 'Goblin'],
			abilities: ['Marauder', 'Haste'],
			attack: 2,
			life: 2,
			move: 3,
			image_num: 50
		}
	},

	"If-Uluk, the Swift": {
		name: "If-Uluk, the Swift",
		type: "creature",
		cost: 5,
		loyalty_cost: 3,
		school: 3,
		hero: true,
		creature: {
			tags: ['Mounted', 'Goblin'],
			abilities: ['Marauder', 'Haste', 'Cover'],
			attack: 5,
			life: 3,
			move: 3,
			image_num: 50,
			overlays: [{image_num: 8}],
		}
	},

	"Goblin Grenadier": {
		name: "Goblin Grenadier",
		type: "creature",
		cost: 3,
		loyalty_cost: 1,
		school: 3,
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder', {
				name: 'Detonate',
				cost: 0,
				loyalty_cost: 1,
				school: 3,
				rules: "Goblin Grenadier is destroyed, each adjacent creature and building takes 2 damage.",
				is_response: true,
				on_play: "def(game, creature, info) [
					set(creature.destroyed, true),
					set(creature.death_animation_hint, 'explosion'),
					[ target.inflict_combat_damage(game, creature, 2)
					  | target <- game.creatures,
					    game.locs_adjacent(creature.loc, target.loc) ]
					]
				",
			}],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 30,
			image_num: 40,
			overlays: [{image_num: 2}],
		}
	},

	"Goblin": {
		name: "Goblin",
		type: "creature",
		cost: 0,
		loyalty_cost: 2,
		school: 3,
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder', 'Haste'],
			attack: 2,
			life: 1,
			move: 2,
			initiative: 30,
			image_num: 40,
		}
	},

	"Goblin Sapper": {
		name: "Goblin Sapper",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 3,
		rules: "&2;&resist; vs &range; attacks.\n&3;&attack; vs buildings.",
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder'],
			attack: 1,
			life: 1,
			move: 3,
			initiative: 30,
			image_num: 40,
			overlays: [{image_num: 4}],
			static_ability_effect: "if(creature.controller != target.controller and game.locs_adjacent(creature.loc, target.loc) and target.is_building, 
				creature.apply_static_effect('attack', 3)
			)",
			resistance_against: "def(game, attacker, damage) me.resistance + if(attacker.range > 1, 2, 0)",
		}
	},
	
	"Wolf": {
		name: "Wolf",
		type: "creature",
		cost: 2,
		loyalty_cost: 1,
		school: 3,
		creature: {
			tags: ['Wolf'],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 20,
			image_num: 5,
		}
	},

	"Cave Troll": {
		name: "Cave Troll",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: 3,
		creature: {
			tags: ['Troll'],
			abilities: ['Regeneration'],
			attack: 4,
			life: 4,
			move: 2,
			image_num: 11,
		},
	},
	
	"Rampaging Troll": {
		name: "Rampaging Troll",
		type: "creature",
		cost: 5,
		loyalty_cost: 4,
		school: 3,
		rules: "At the start of your turn the Rampaging Troll is healed to full health",
		creature: {
			tags: ['Troll'],
			abilities: ['Marauder', 'Haste'],
			attack: 3,
			life: 2,
			move: 2,
			initiative: 30,
			image_num: 11,
			overlays: [{image_num: 27}],
			on_begin_turn: "def(game) if(game.current_player = controller, set(me.wounds, 0))",
		},
	},

	"Lumbering Ogre": {
		name: "Lumbering Ogre",
		type: "creature",
		cost: 6,
		loyalty_cost: 4,
		school: 3,
		rules: "At start of turn, if an enemy is immediately in front of Ogre, Ogre gains +5 until end of turn",
		creature: {
			tags: ['Ogre'],
			attack: 0,
			life: 8,
			move: 2,
			image_num: 17,
			on_begin_turn: "def(game) if(is_engaged(game), me.apply_effect_until_end_of_turn('attack', 5))",
		}
	},

	"Green Adder": {
		name: "Green Adder",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 3,
		creature: {
			tags: ['Serpent'],
			attack: 3,
			life: 1,
			move: 2,
			image_num: 64
		}
	},

	"Exploration": {
		name: "Exploration",
		type: "spell",
		rules: "If there are less than seven rows, add a new lane to the bottom of the map. Otherwise, draw a card.",
		cost: 1,
		loyalty_cost: 4,
		school: 3,
		on_play: "def(game, info) if(game.rows < 7, add(game.rows, 1),
		                game.players[controller].draw_cards(game, 1))"
	},

	"Wose": {
		name: "Wose",
		type: "creature",
		cost: 5,
		loyalty_cost: 3,
		school: 3,
		rules: "At start of your turn, if Wose is in forest it regenerates to full health. If it is not in forest, it takes one damage.",
		creature: {
			tags: ['Wose'],
			attack: 8,
			life: 8,
			move: 1,
			image_num: 59,
			on_begin_turn: "def(game) if(game.current_player = controller,
			      if(game.terrain_at_loc(loc) = 'forest',
				     set(me.wounds, 0),
					 add(me.wounds, 1)))"
		}
	},

	"Cavern Wurm": {
		name: "Cavern Wurm",
		type: "creature",
		cost: 4,
		loyalty_cost: 3,
		school: 3,
		creature: {
			tags: ['Wurm'],
			attack: 5,
			life: 3,
			move: 2,
			image_num: 65
		}
	},

	"Hydra": {
		name: "Hydra",
		type: "creature",
		cost: 6,
		loyalty_cost: 3,
		school: 3,
		creature: {
			tags: ['Serpent'],
			attack: 4,
			life: 4,
			move: 2,
			abilities: [
				{
					name: "Regrow",
					cost: 1,
					school: 3,
					rules: "Heal 1, then get +1/+1",

					is_usable: "def(game, creature) creature.wounds > 0",
					on_play: "def(game, creature, info) [
					  add(creature.wounds, -1),
					  add(creature.attack, 1),
					  add(creature.life, 1)
					]",
				}
			],
			image_num: 63
		}
	},

	"Minotaur": {
		name: "Minotaur",
		type: "creature",
		cost: 4,
		loyalty_cost: 3,
		school: 1,
		creature: {
			tags: ['Creature'],
			abilities: ['Trample'],
			attack: 3,
			life: 4,
			move: 5,
			initiative: 30,
			image_num: 30,
		}
	},
	
	"Grove of Sanctity": {
		name: "Grove of Sanctity",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: 3,
		rules: "Creatures you control in this lane have regeneration",
		creature: {
			tags: ["Grove"],
			life: 3,
			is_building: true,
			image_num: 2,
			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0] and not target.is_building, target.add_ability_static_duration('Regeneration'))"
		}
	},
	
	"Grove of Vigor": {
		name: "Grove of Vigor",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: 3,
		rules: "Creatures you control in this lane have +1 move and Haste",
		creature: {
			tags: ["Grove"],
			life: 3,
			is_building: true,
			image_num: 2,
			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0] and not target.is_building, [target.add_ability_static_duration('Haste'), target.apply_static_effect('move', 1)])"
		}
	},

	"Grove of the Restless": {
		name: "Grove of the Restless",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: 3,
		rules: "Creatures you control in this lane have +1 attack",
		creature: {
			tags: ["Grove"],
			life: 3,
			is_building: true,
			image_num: 2,
			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0] and not target.is_building, target.apply_static_effect('attack', 1))"
		}
	},
	
	"Trample": {
		name: "Trample",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: 3,
		rules: "Target creature gains Trample",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) add(creature.abilities, ['Trample'])
					asserting creature != null
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc(info.targets[0])",
	},
	
	"Cover": {
		name: "Cover",
		type: "spell",
		is_response: true,
		cost: 2,
		loyalty_cost: 1,
		school: 3,
		rules: "Gives target creature Cover",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) add(creature.abilities, ['Cover'])
					asserting creature != null
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc(info.targets[0])",
	},
	
	"Quick Step": {
		name: "Quick Step",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: 3,
		rules: "Gives target creature +1 move",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) add(creature.move, 1)
					asserting creature != null
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc(info.targets[0])",
	},
	
	"Hill Giant": {
		name: "Hill Giant",
		type: "creature",
		cost: 8,
		loyalty_cost: 3,
		school: 3,
		creature: {
			tags: ['Giant'],
			abilities: ['Trample', 'Haste'],
			attack: 8,
			life: 8,
			move: 2,
			initiative: 30,
			image_num: 61,
		},		
	},
	
	"Hurl": {
		name: "Hurl",
		type: "spell",
		cost: 2,
		school: 3,
		loyalty_cost: 2,
		is_response: true,
		rules: "Sacrifice a goblin. Deal 4 damage to target creature in the same lane.",
		possible_targets: "def(game, nplayer, targets)
		  if(size(targets) = 0,
		    [creature.loc | creature <- game.creatures,
			                not creature.is_building,
							'Goblin' in creature.tags,
							creature.is_valid_target(game, nplayer, me)],
			if(size(targets) = 1, [creature.loc | creature <- game.creatures, not creature.is_building, creature.loc[0] = targets[0][0], creature.is_valid_target(game, nplayer, me)],
			 null))",
		on_play: "def(game, info) [
			set(goblin.destroyed, true),
			add(target.wounds, 4)
		]
			asserting goblin != null
			asserting target != null
			where goblin = game.creature_at_loc(info.targets[0]), target = game.creature_at_loc(info.targets[1])",
	},

	"Strip the Carcass": {
		name: "Strip the Carcass",
		type: "spell",
		school: 3,
		cost: 1,
		loyalty_cost: 1,
		is_response: true,
		rules: "When target creature dies this turn, owner gains resources equal to the creature's life",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) co.add_triggered_ability_until_end_of_turn({
			name: 'Strip the Carcass',
			rules: 'If creature dies this turn, owner gains resources equal to the creatures life',
			duration_hint: 'end of turn',
			on_die: 'def(creature, game) add(game.players[creature.controller].resources, creature.life)'})
			asserting co != null
			asserting size(info.targets) = 1
			where co = game.creature_at_loc(info.targets[0])",
	},
	
	"Feral Rampage": {
		name: "Feral Rampage",
		type: "spell",
		school: 3,
		cost: 2,
		loyalty_cost: 2,
		rules: "Target creature gains +3 attack, +3 life, and trample for the rest of the turn",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) [
			creature.add_ability_until_end_of_turn('Trample'),
			creature.apply_effect_until_end_of_turn('attack', 3),
			creature.apply_effect_until_end_of_turn('life', 3),
			] asserting creature != null
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc(info.targets[0])",
	},

	"Slathering Wolf": {
		name: "Slathering Wolf",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 3,
		rules: 'On damaging an opponent infects them with a disease giving them -1 movement and poisoned',
		creature: {
			tags: ['Wolf'],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 20,
			image_num: 70,
			triggered_abilities: [{
				name: "Infectious disease",
				rules: "-1 movement and poisoned",
				on_deal_damage: "def(creature, game, target, damage) [add(target.move, -1), 
					if(not ('Poisoned' in target.status_effects), add(target.status_effects, ['Poisoned']))]",
			}],
		}
	},

	"The Great Horde": {
		name: "The Great Horde",
		type: "spell",
		cost: 8,
		loyalty_cost: 2,
		school: 3,
		rules: "Summon a 1/1/2 Goblin in every tile you can summon a creature",
		on_play: "def(game, info) map(
		  game.player_obj.summoning_locs(game, construct('creature', goblin)),
		  game.summon_creature(construct('creature', goblin + {loc: value})))
			where goblin = {
				name: 'Goblin',
				attack: 1,
				range: 1,
				life: 1,
				move: 2,
				image_num: 40,
			}"
	},

	"Intense Warfare": {
		name: "Intense Warfare",
		type: "spell",
		cost: 4,
		loyalty_cost: 3,
		school: 3,
		rules: "Your creatures refresh. The turn is returned to the pre-combat phase.",
		on_play: "def(game, info) [
		  [ creature.refresh() | creature <- game.creatures,
		    not creature.is_building,
		    creature.controller = game.current_player_index ],

		  set(game.done_movement, false),
		  set(game.precombat_phase, 0),
		]",
		
	},
}
