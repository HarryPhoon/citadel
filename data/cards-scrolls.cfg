{
	"Ilz Apprentice": {
		name: "Ilz Apprentice",
		type: "creature",
		cost: 2,
		loyalty_cost: 0,
		school: 4,
		creature: {
			tags: ['Human'],
			attack: 1,
			life: 2,
			move: 2,
			image_num: 9
		}
	},

	"Acolyte": {
		name: "Acolyte",
		type: "creature",
		cost: 2,
		loyalty_cost: 1,
		school: 4,
		rules: "When you cast Acolyte, draw a card.",
		on_play: "def(game, info) [
		  me.do_summons(game, info),
		  game.players[game.current_player].draw_cards(game, 1)
		]",
		creature: {
			tags: ['Human'],
			attack: 1,
			life: 2,
			move: 2,
			image_num: 20
		}
	},

	"Mystic Scholar": {
		name: "Mystic Scholar",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 4,
		creature: {
			abilities: [
				{
					name: 'Consume',
					cost: 1,
					school: 4,
					rules: "Sacrifice Mystic Scholar, draw 2 cards",
					on_play: "def(game, creature, info) [
						set(creature.destroyed, true),
						game.players[creature.controller].draw_cards(game, 2)
					]"
				}
			],
			tags: ['Human'],
			attack: 1,
			life: 2,
			move: 2,
			image_num: 20
		}
	},

	"Golem": {
		name: "Golem",
		type: "creature",
		cost: 4,
		loyalty_cost: 2,
		school: 4,
		creature: {
			abilities: [
				{
					name: 'Rebuild',
					cost: 2,
					school: 4,
					rules: "Fully heal Golem",
					on_play: "def(game, creature, info) [
						set(creature.wounds, 0)
					]"
				}
			],
			tags: ['Construct'],
			attack: 4,
			life: 4,
			move: 1,
			image_num: 61
		}
	},

	"Fireball": {
		name: "Fireball",
		type: "spell",
		school: 4,
		cost: 3,
		loyalty_cost: 3,
		rules: "Deal 3 damage to target creature",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) add(creature.wounds, 3)
			asserting creature != null
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc(info.targets[0])"
	},

	"Blink": {
		name: "Blink",
		type: "spell",
		school: 4,
		cost: 2,
		loyalty_cost: 3,
		is_response: true,
		
		rules: "Target creature is moved to target lane",

		possible_targets: "def(game, nplayer, targets)
		  if(targets = [],
			 [creature.loc | creature <- game.creatures, creature.is_valid_target(game, nplayer, me), not creature.is_building],
			 if(size(targets) = 1,
				[[row, targets[0][1]] | row <- range(game.rows), game.creature_at_loc([row, targets[0][1]]) = null]
			 ))",
		on_play: "def(game, info)
		  set(game.creature_at_loc(info.targets[0]).loc, info.targets[1])"
	},

	"Astral Walk": {
		name: "Astral Walk",
		type: "spell",
		school: 4,
		cost: 2,
		loyalty_cost: 3,
		is_response: true,
		
		rules: "Target creature is moved to a vacant tile up to two spaces ahead or behind",

		possible_targets: "def(game, nplayer, targets)
		  if(targets = [],
			 [creature.loc | creature <- game.creatures, creature.is_valid_target(game, nplayer, me), not creature.is_building],
			 if(size(targets) = 1,
			   filter([[targets[0][0], targets[0][1]+col] | col <- [-2,-1,1,2]],
				      game.is_loc_on_board(value) and
					  game.creature_at_loc(value) = null)
			 ))",
		on_play: "def(game, info)
		  set(game.creature_at_loc(info.targets[0]).loc, info.targets[1])"
	},

	"Library": {
		name: "Library",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 4,
		creature: {
			tags: ["Library"],
			life: 3,
			is_construct: true,
			image_num: 8,
			abilities: [
				{
					name: 'Study',
					cost: 1,
					loyalty_cost: 0,
					exhausts_creature: true,
					school: 4,
					rules: "Draw a card",
					on_play: "def(game, creature, info) [
						game.players[creature.controller].draw_cards(game, 1)
					]"
				}
			]
		}
	},
	
	"Polymorph": {
		name: "Polymorph",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: 4,
		is_response: true,
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) [game.summon_creature(construct('creature', {
			name: 'Giant Frog',			
			tags: ['Giant Frog', 'Animal'],
			school: 4, 
			attack: 3,
			controller: target.controller,
			life: 3,
			move: 2,
			initiative: 20,
			image_num: 73,
			loc: info.targets[0],
			})), set(target.destroyed, true)]
			asserting target != null
			asserting size(info.targets) = 1
			where target = game.creature_at_loc(info.targets[0])
		",
	},

	"Charge!": {
		name: "Charge!",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: 4,
		rules: "Target creature gains Charge",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) add(game.creature_at_loc(info.targets[0]).abilities, ['Charge'])
					asserting game.creature_at_loc(info.targets[0]) != null
					asserting size(info.targets) = 1",
	},
	
	"Council of Seven": {
		name: "Council of Seven",
		type: "spell",
		school: 4,
		cost: 4,
		loyalty_cost: 3,
		rules: "Discard your hand. Draw seven cards.",
		possible_targets: "def(game, nplayer, targets) null",
		on_play: "def(game, info) [
			game.player_obj.discard_cards(range(size(game.player_obj.hand))),
			game.player_obj.draw_cards(game, 7)
		]",
	},
	
	"Confusion": {
		name: "Confusion",
		type: "spell",
		school: 4,
		is_response: true,
		cost: 3,
		loyalty_cost: 3,
		rules: "Gain control of target creature this turn",
		possible_targets: "enemy_creatures_as_possible_targets",
		on_play: "def(game, info) [set(creature.controller, game.current_player_index),
			set(creature.can_enter_endzone, false),
			creature.add_triggered_ability_until_end_of_turn({
				on_end_turn: 'def(creature, game) [set(creature.controller, args.original_controller), 
					set(creature.can_enter_endzone, args.original_enter_endzone)]',
				args: { original_controller: creature.controller, original_enter_endzone: creature.can_enter_endzone }
			})]
			asserting creature != null
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc(info.targets[0])",
	},
	
	"Humboldt's Curse": {
		name: "Humboldt's Curse",
		type: "spell",
		school: 4,
		is_response: true,
		cost: 2,
		loyalty_cost: 1,
		rules: "Target creature gets -1 movement permanently",
		possible_targets: "all_creatures_as_possible_targets",
		on_play_on_creature: "def(game, target) [add(target.move, -1), debug('Play Burden')]",
	},
	
	"Humboldt's Trick": {
		name: "Humboldt's Trick",
		type: "spell",
		school: 4,
		is_response: true,
		cost: 3,
		loyalty_cost: 2,
		rules: "Target's movement is increased by 1, Target's attack is reduced by 2",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(game, info) [add(creature.move, 1), add(creature.attack, -2)]
					asserting creature != null
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc(info.targets[0])",
	},
	
	"Rolland's Little Helper": {
		name:  "Rolland's Little Helper",
		type: "creature",
		school: 4,
		cost: 3,
		loyalty_cost: 2,
		creature: {
			abilities: [
				{
					name: 'Sacrifice',
					school: 4,
					is_response: true,
					cost: 2,
					rules: "Little Helper dies, Draw three cards",
					on_play: "def(game, creature, info) [
						game.player_obj.draw_cards(game,3), 
						set(creature.destroyed, true)]",
				}
			],
			tags: ['Arcane'],
			attack: 3,
			life: 3,
			move: 2,
			image_num: 49
		}
		
	},

	"Endless Studies": {
		name: "Endless Studies",
		type: "spell",
		school: 4,
		cost: 0,
		loyalty_cost: 2,
		rules: "Draw a card",
		on_play: "def(game, info)
		  game.players[game.current_player].draw_cards(game, 1)",
	},

	"Divine the Future": {
		name: "Divine the Future",
		type: "spell",
		school: 4,
		cost: 2,
		loyalty_cost: 3,
		rules: "Look at the top 5 cards of your deck. Discard them or put them back.",
		on_play: "def(game, info) if(info.choices, [
			if(info.choices[0] = 1, [
				add(game.player_obj.discard_pile, game.player_obj.deck[:5]),
				set(game.player_obj.deck, game.player_obj.deck[5:]),
			])
		],
		 if(game.player_obj.no_cards_to_draw, null,
		 [
		 	set(game.player_obj.deck, cards.deck),
		 	set(game.player_obj.discard_pile, cards.discard_pile),
			game.set_current_choice({
				card: me,
				info: info,
				text: 'Choose whether to discard the cards',
				options:
				map(cards.deck[:depth],
				{
					type: 'card',
					card: value,
					value: null,
				}) +
				
				[
				{
					type: 'button',
					value: 0,
					text: 'Keep',
				},
				{
					type: 'button',
					value: 1,
					text: 'Discard',
				}
				]
			}),
		 ] where cards = game.player_obj.guarantee_deck_size(game, depth))
		) where depth = 5
		",
	},

	"Tactical Blunder": {
		name: "Tactical Blunder",
		type: "spell",
		school: 4,
		cost: 1,
		loyalty_cost: 3,
		is_response: true,
		rules: "Play in response to summoning. Change target location of summoning of creature or construct.",
		possible_targets: "def(game, nplayer, targets)
		  if(targets != [], null, 
			 if(summoning, summoning.card.possible_targets(game, summoning.player_index, []), [])
			 where summoning = find(reverse(game.stack),
			        (not value.ability) and
					value.card.type = 'creature' and size(value.targets) = 1))",
		on_play: "def(game, info)
		  set(summoning.targets, info.targets)
			 where summoning = find(reverse(game.stack),
			         (not value.ability) and
					 value.card.type = 'creature' and size(info.targets) = 1)",

	},

	"Scry": {
		name: "Scry",
		type: "spell",
		school: 4,
		cost: 0,
		loyalty_cost: 4,
		rules: "Look at the top 5 cards of your deck. Put one of them into your hand, and the rest on the bottom.",
		on_play: "def(game, info) if(info.choices,
		 [
		   set(game.player_obj.deck,
		       filter(game.player_obj.deck, index != info.choices[0])),
		   add(game.player_obj.hand,
		       [game.player_obj.deck[info.choices[0]]]),
		 ],
		 if(size(game.player_obj.deck) + size(game.player_obj.discard_pile) = 0, null,
		 [
		 	set(game.player_obj.deck, new_deck),
		 	set(game.player_obj.discard_pile, new_discard_pile),
			game.set_current_choice({
				card: me,
				info: info,
				text: 'Choose a card to put in your hand',
				options: map(new_deck[:min(size(new_deck), depth)],
				   {
						type: 'card',
						card: value,
						value: index,
				   }),
			}),
		 ]
		where new_deck = if(size(game.player_obj.deck) < depth, game.player_obj.deck + shuffle(game.player_obj.discard_pile), game.player_obj.deck)
		where new_discard_pile = if(size(game.player_obj.deck) < depth, game.player_obj.discard_pile, [])
	  )) where depth = 5",
	},
	
	"Flesh Golem": {
		name: "Flesh Golem",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: 4,
		creature: {
			abilities: [
				{
					name: 'Re-make',
					cost: 2,
					school: [1,4],
					is_response: false,
					rules: "Sacrifice Golem, summon a new Golem that gets +1 attack/+1 life",
					is_usable: "def(game, creature) creature.wounds > 0 and not ('Exhausted' in creature.status_effects)",
					on_play: "def(game, creature, info) [
						set(creature.destroyed, true),
						game.summon_creature(construct('creature', {
							name: 'Flesh Golem',			
							tags: ['Construct', 'Golem'],
							school: 4, 
							attack: creature.attack + 1,
							controller: creature.controller,
							life: creature.life + 1,
							move: 1,
							wounds: creature.wounds / 2,
							initiative: 20,
							image_num: 75,
							loc: creature.loc,
							abilities: creature.abilities,
							}))
					]"
				}
			],
			tags: ['Construct', 'Golem'],
			attack: 4,
			life: 4,
			move: 1,
			image_num: 75
		}
	},

	"Read Mind": {
		name: "Read Mind",
		type: "spell",
		cost: 0,
		loyalty_cost: 3,
		school: 4,
		rules: "Look at your opponent's hand. +1 Mana.",

		on_play: "def(game, info) if(info.choices, null, [
		add(game.player_obj.resources, 1),
		if(game.opponent_obj.hand, game.set_current_choice({
			card: me,
			info: info,
			text: q(Look at your opponent's hand. Click a card when they're done.),
			options: map(game.opponent_obj.hand, {
				type: 'card',
				card: value,
				value: index,
			})
		}))])",
	},
}
